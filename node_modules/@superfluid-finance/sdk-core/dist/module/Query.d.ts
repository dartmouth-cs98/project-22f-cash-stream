import { AllEvents, IEventFilter } from "./events";
import { IAccountTokenSnapshotFilter, IIndex, IIndexRequestFilter, IIndexSubscription, IIndexSubscriptionRequestFilter, ILightAccountTokenSnapshot, ILightEntity, IStream, IStreamRequestFilter, ISuperToken, ISuperTokenRequestFilter } from "./interfaces";
import { Ordering } from "./ordering";
import { PagedResult, Paging } from "./pagination";
import { SubgraphClient } from "./subgraph/SubgraphClient";
import { AccountTokenSnapshot_OrderBy, Event_OrderBy, Index_OrderBy, IndexSubscription_OrderBy, Stream_OrderBy, Token_OrderBy } from "./subgraph/schema.generated";
export interface IQueryOptions {
    readonly customSubgraphQueriesEndpoint: string;
}
/**
 * Query Helper Class
 * @description A helper class to create `Query` objects which can be used to query different data.
 */
export default class Query {
    options: IQueryOptions;
    subgraphClient: SubgraphClient;
    constructor(options: IQueryOptions);
    listAllSuperTokens: (filter: ISuperTokenRequestFilter, paging?: Paging, ordering?: Ordering<Token_OrderBy>) => Promise<PagedResult<ISuperToken>>;
    listIndexes: (filter: IIndexRequestFilter, paging?: Paging, ordering?: Ordering<Index_OrderBy>) => Promise<PagedResult<IIndex>>;
    listIndexSubscriptions: (filter: IIndexSubscriptionRequestFilter, paging?: Paging, ordering?: Ordering<IndexSubscription_OrderBy>) => Promise<PagedResult<IIndexSubscription>>;
    listStreams: (filter: IStreamRequestFilter, paging?: Paging, ordering?: Ordering<Stream_OrderBy>) => Promise<PagedResult<IStream>>;
    listUserInteractedSuperTokens: (filter: IAccountTokenSnapshotFilter, paging?: Paging, ordering?: Ordering<AccountTokenSnapshot_OrderBy>) => Promise<PagedResult<ILightAccountTokenSnapshot>>;
    listEvents: (filter: IEventFilter, paging?: Paging, ordering?: Ordering<Event_OrderBy>) => Promise<PagedResult<AllEvents>>;
    on(callback: (events: AllEvents[], unsubscribe: () => void) => void, ms: number, account?: string, timeout?: number): () => void;
}
/**
 * A recursive function to fetch all possible results of a paged query.
 * @param pagedQuery A paginated query that takes {@link Paging} as input.
 */
export declare const listAllResults: <T extends ILightEntity>(pagedQuery: (paging: Paging) => Promise<PagedResult<T>>) => Promise<T[]>;
//# sourceMappingURL=Query.d.ts.map