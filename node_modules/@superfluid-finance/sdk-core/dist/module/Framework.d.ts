import { Signer } from "@ethersproject/abstract-signer";
import { HardhatEthersHelpers } from "@nomiclabs/hardhat-ethers/types";
import { ethers } from "ethers";
import Web3 from "web3";
import BatchCall from "./BatchCall";
import ConstantFlowAgreementV1 from "./ConstantFlowAgreementV1";
import Governance from "./Governance";
import Host from "./Host";
import InstantDistributionAgreementV1 from "./InstantDistributionAgreementV1";
import Operation from "./Operation";
import Query from "./Query";
import SuperToken, { NativeAssetSuperToken, PureSuperToken, WrapperSuperToken } from "./SuperToken";
import { IConfig, IContracts, ISignerConstructorOptions } from "./interfaces";
declare type SupportedProvider = ethers.providers.Provider | (typeof ethers & HardhatEthersHelpers) | Web3;
export interface IFrameworkOptions {
    chainId: number;
    customSubgraphQueriesEndpoint?: string;
    resolverAddress?: string;
    protocolReleaseVersion?: string;
    provider: SupportedProvider;
}
export interface IFrameworkSettings {
    chainId: number;
    customSubgraphQueriesEndpoint: string;
    networkName: string;
    protocolReleaseVersion: string;
    provider: ethers.providers.Provider;
    config: IConfig;
}
/**
 * Superfluid Framework Class
 * @description The entrypoint for the SDK-core, `create` an instance of this for full functionality.
 */
export default class Framework {
    readonly userInputOptions: IFrameworkOptions;
    settings: IFrameworkSettings;
    contracts: IContracts;
    cfaV1: ConstantFlowAgreementV1;
    governance: Governance;
    host: Host;
    idaV1: InstantDistributionAgreementV1;
    query: Query;
    private constructor();
    /**
     * Creates the Framework object based on user provided `options`.
     * @param options.chainId the chainId of your desired network (e.g. 137 = matic)
     * @param options.customSubgraphQueriesEndpoint your custom subgraph endpoint
     * @param options.resolverAddress a custom resolver address (advanced use for testing)
     * @param options.protocolReleaseVersion a custom release version (advanced use for testing)
     * @param options.provider a provider object (injected web3, injected ethers, ethers provider) necessary for initializing the framework
     * @returns `Framework` class
     */
    static create: (options: IFrameworkOptions) => Promise<Framework>;
    /**
     * Create a signer which can be used to sign transactions.
     * @param options.web3Provider a Web3Provider object (e.g. client side - metamask, web3modal)
     * @param options.provider an ethers Provider object (e.g. via Hardhat ethers)
     * @param options.privateKey a test account private key
     * @param options.signer a signer object (e.g. ethers.Wallet instance)
     * @returns `ethers.Signer` object
     */
    createSigner: (options: ISignerConstructorOptions) => Signer;
    /**
     * Create a `BatchCall` class from the `Framework`.
     * @param operations the list of operations to execute
     * @returns `BatchCall` class
     */
    batchCall: (operations: Operation[]) => BatchCall;
    /**
     * Loads `NativeAssetSuperToken` class from the `Framework`. Will throw if token is not NativeAssetSuperToken.
     * @param tokenAddressOrSymbol
     * @returns `NativeAssetSuperToken` class
     */
    loadNativeAssetSuperToken: (tokenAddressOrSymbol: string) => Promise<NativeAssetSuperToken>;
    /**
     * Loads `PureSuperToken` class from the `Framework`. Will throw if token is not PureSuperToken.
     * @param tokenAddressOrSymbol
     * @returns `PureSuperToken` class
     */
    loadPureSuperToken: (tokenAddressOrSymbol: string) => Promise<PureSuperToken>;
    /**
     * Loads `WrapperSuperToken` class from the `Framework`. Will throw if token is not WrapperSuperToken.
     * @param tokenAddressOrSymbol
     * @returns `WrapperSuperToken` class
     */
    loadWrapperSuperToken: (tokenAddressOrSymbol: string) => Promise<WrapperSuperToken>;
    /**
     * Loads `SuperToken` class from the `Framework`. Use this when you're unsure of the token type.
     * @param tokenAddressOrSymbol the `SuperToken` address or symbol (if symbol, it must be on the resolver)
     * @returns `SuperToken` class
     */
    loadSuperToken: (tokenAddressOrSymbol: string) => Promise<SuperToken>;
    /**
     * Try to get the token address given an address (returns if valid) or the token symbol via the resolver.
     * @param tokenAddressOrSymbol
     * @returns token address
     */
    private _tryGetTokenAddress;
}
export {};
//# sourceMappingURL=Framework.d.ts.map