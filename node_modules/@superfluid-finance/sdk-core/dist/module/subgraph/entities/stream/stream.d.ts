import { Address, BigNumber, BlockNumber, SubgraphId, Timestamp } from "../../mappedSubgraphTypes";
import { Stream_Filter, Stream_OrderBy } from "../../schema.generated";
import { RelevantAddressesIntermediate, SubgraphListQuery, SubgraphQueryHandler } from "../../subgraphQueryHandler";
import { StreamsQuery, StreamsQueryVariables } from "./streams.generated";
export interface Stream {
    id: SubgraphId;
    createdAtBlockNumber: BlockNumber;
    createdAtTimestamp: Timestamp;
    updatedAtTimestamp: Timestamp;
    updatedAtBlockNumber: BlockNumber;
    currentFlowRate: BigNumber;
    streamedUntilUpdatedAt: BigNumber;
    receiver: Address;
    sender: Address;
    token: Address;
    tokenSymbol: string;
}
export declare type StreamListQuery = SubgraphListQuery<Stream_Filter, Stream_OrderBy>;
export declare class StreamQueryHandler extends SubgraphQueryHandler<Stream, StreamListQuery, StreamsQuery, StreamsQueryVariables> {
    getAddressFieldKeysFromFilter: () => {
        accountKeys: (keyof Stream_Filter)[];
        tokenKeys: (keyof Stream_Filter)[];
    };
    getRelevantAddressesFromResultCore: (result: Stream) => RelevantAddressesIntermediate;
    mapFromSubgraphResponse: (response: StreamsQuery) => Stream[];
    requestDocument: import("@graphql-typed-document-node/core").TypedDocumentNode<StreamsQuery, import("../../schema.generated").Exact<{
        first?: import("../../schema.generated").InputMaybe<number>;
        orderBy?: import("../../schema.generated").InputMaybe<Stream_OrderBy>;
        orderDirection?: import("../../schema.generated").InputMaybe<import("../../schema.generated").OrderDirection>;
        skip?: import("../../schema.generated").InputMaybe<number>;
        where?: import("../../schema.generated").InputMaybe<Stream_Filter>;
        block?: import("../../schema.generated").InputMaybe<import("../../schema.generated").Block_Height>;
    }>>;
}
//# sourceMappingURL=stream.d.ts.map