import { TypedDocumentNode } from "@graphql-typed-document-node/core";
import { ILightEntity } from "../interfaces";
import { Ordering } from "../ordering";
import { PagedResult, Paging } from "../pagination";
import { SubgraphClient } from "./SubgraphClient";
import { Address, SubgraphId } from "./mappedSubgraphTypes";
import { Block_Height, Exact, InputMaybe, OrderDirection, Scalars } from "./schema.generated";
/**
 * An argument object type that is used for paginated Subgraph queries.
 */
export interface SubgraphListQuery<TFilter extends {
    id?: InputMaybe<Scalars["ID"]>;
    id_gt?: InputMaybe<Scalars["ID"]>;
}, TOrderBy extends string> {
    filter?: TFilter;
    pagination?: Paging;
    order?: Ordering<TOrderBy>;
    block?: Block_Height;
}
/**
 * An argument object type that is used for single object queries by ID from Subgraph.
 */
export interface SubgraphGetQuery {
    id: SubgraphId;
    block?: Block_Height;
}
/**
 * Capable of handling the {@link SubgraphGetQuery} request.
 */
export interface SubgraphGetQueryHandler<TResult extends ILightEntity> {
    get(subgraphClient: SubgraphClient, query: SubgraphGetQuery): Promise<TResult | null>;
}
/**
 * Capable of handling the {@link SubgraphGetQuery} request.
 */
export interface SubgraphListQueryHandler<TResult extends ILightEntity, TQuery extends SubgraphListQuery<TFilter, TOrderBy>, TFilter extends {
    [key: string]: unknown;
} = NonNullable<TQuery["filter"]>, TOrderBy extends string = NonNullable<TQuery["order"]>["orderBy"]> {
    list(subgraphClient: SubgraphClient, query: SubgraphListQuery<TFilter, TOrderBy>): Promise<PagedResult<TResult>>;
}
/**
 * "Relevant" means that it's connected.
 * NOTE: Currently, the relevancy is used to create a caching logic on the SDK-Redux layer.
 */
export interface RelevantAddresses {
    tokens: Address[];
    accounts: Address[];
}
/**
 * Intermediate data object to pass relevant addresses from query results with less boilerplate code.
 */
export interface RelevantAddressesIntermediate {
    tokens: (Address | Address[] | null | undefined)[];
    accounts: (Address | Address[] | null | undefined)[];
}
/**
 * Provides relevant address from a inputted filter.
 */
export interface RelevantAddressProviderFromFilter<TFilter> {
    getRelevantAddressesFromFilter(filter?: TFilter): RelevantAddresses;
}
/**
 * Provides relevant address from a query result.
 */
export interface RelevantAddressProviderFromResult<TResult> {
    getRelevantAddressesFromResult(result?: TResult | null): RelevantAddresses;
}
/**
 * A base class to handle common Subgraph query logic.
 */
export declare abstract class SubgraphQueryHandler<TResult extends ILightEntity, TListQuery extends SubgraphListQuery<TFilter, TOrderBy>, TSubgraphQuery, TSubgraphQueryVariables extends Exact<{
    first?: InputMaybe<Scalars["Int"]>;
    orderBy?: InputMaybe<TOrderBy>;
    orderDirection?: InputMaybe<OrderDirection>;
    skip?: InputMaybe<Scalars["Int"]>;
    where?: InputMaybe<TFilter>;
    block?: InputMaybe<Block_Height>;
}>, TFilter extends {
    id?: InputMaybe<Scalars["ID"]>;
    id_gt?: InputMaybe<Scalars["ID"]>;
} = NonNullable<TListQuery["filter"]>, TOrderBy extends string = NonNullable<TListQuery["order"]>["orderBy"]> implements SubgraphGetQueryHandler<TResult>, SubgraphListQueryHandler<TResult, TListQuery, TFilter, TOrderBy>, RelevantAddressProviderFromFilter<TFilter>, RelevantAddressProviderFromResult<TResult> {
    abstract getAddressFieldKeysFromFilter(): {
        accountKeys: (keyof TFilter)[];
        tokenKeys: (keyof TFilter)[];
    };
    getRelevantAddressesFromFilter(filter?: TFilter): RelevantAddresses;
    /**
     * For every primary address field key there are more fields generated which it should look for addresses.
     * NOTE: The implementation is a bit "magical" but it rids of a bunch of boilerplate and creates a single point for editing.
     */
    private getRelevantAddressesFromFilterByAddressFieldKeys;
    protected abstract getRelevantAddressesFromResultCore(result: TResult): RelevantAddressesIntermediate;
    getRelevantAddressesFromResult(result?: TResult | null): RelevantAddresses;
    abstract mapFromSubgraphResponse(response: TSubgraphQuery): TResult[];
    get(subgraphClient: SubgraphClient, query: SubgraphGetQuery): Promise<TResult | null>;
    list(subgraphClient: SubgraphClient, query: SubgraphListQuery<TFilter, TOrderBy>): Promise<PagedResult<TResult>>;
    protected querySubgraph(subgraphClient: SubgraphClient, variables: TSubgraphQueryVariables): Promise<TSubgraphQuery>;
    abstract requestDocument: TypedDocumentNode<TSubgraphQuery, TSubgraphQueryVariables>;
}
//# sourceMappingURL=subgraphQueryHandler.d.ts.map