import { ethers } from "ethers";
import Operation from "./Operation";
import { SFError } from "./SFError";
import ERC20WithTokenInfoABI from "./abi/ERC20WithTokenInfo.json";
import { normalizeAddress } from "./utils";
export default class ERC20Token {
    constructor(address) {
        /** ### ERC20 Token Contract Read Functions ### */
        /**
         * Returns the allowance the `owner` has granted the `spender`.
         * @param owner the owner who has allotted the allowance
         * @param spender the spender who has received the allowance
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @returns {Promise<string>} the allowance amount
         */
        this.allowance = async ({ owner, spender, providerOrSigner, }) => {
            const normalizedOwner = normalizeAddress(owner);
            const normalizedSpender = normalizeAddress(spender);
            try {
                const allowance = await this.contract
                    .connect(providerOrSigner)
                    .allowance(normalizedOwner, normalizedSpender);
                return allowance.toString();
            }
            catch (err) {
                throw new SFError({
                    type: "SUPERTOKEN_READ",
                    customMessage: "There was an error getting allowance",
                    errorObject: err,
                });
            }
        };
        /**
         * Returns the ERC20 balanceOf the `account`, this can't be negative and will just display 0.
         * @param account the account you would like to query
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @returns {Promise<string>} the token balance of `account`
         */
        this.balanceOf = async ({ account, providerOrSigner, }) => {
            try {
                const normalizedAccount = normalizeAddress(account);
                const balanceOf = await this.contract
                    .connect(providerOrSigner)
                    .balanceOf(normalizedAccount);
                return balanceOf.toString();
            }
            catch (err) {
                throw new SFError({
                    type: "SUPERTOKEN_READ",
                    customMessage: "There was an error getting balanceOf",
                    errorObject: err,
                });
            }
        };
        /**
         * Returns the token name
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @returns {string} the token name
         */
        this.name = async ({ providerOrSigner, }) => {
            try {
                const name = await this.contract.connect(providerOrSigner).name();
                return name;
            }
            catch (err) {
                throw new SFError({
                    type: "SUPERTOKEN_READ",
                    customMessage: "There was an error getting name",
                    errorObject: err,
                });
            }
        };
        /**
         * Returns the token symbol
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @returns {string} the token symbol
         */
        this.symbol = async ({ providerOrSigner, }) => {
            try {
                const symbol = await this.contract
                    .connect(providerOrSigner)
                    .symbol();
                return symbol;
            }
            catch (err) {
                throw new SFError({
                    type: "SUPERTOKEN_READ",
                    customMessage: "There was an error getting symbol",
                    errorObject: err,
                });
            }
        };
        /**
         * Returns the total supply of the token.
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @returns {Promise<string>} the total supply of the token
         */
        this.totalSupply = async ({ providerOrSigner, }) => {
            try {
                const totalSupply = await this.contract
                    .connect(providerOrSigner)
                    .totalSupply();
                return totalSupply.toString();
            }
            catch (err) {
                throw new SFError({
                    type: "SUPERTOKEN_READ",
                    customMessage: "There was an error getting totalSupply",
                    errorObject: err,
                });
            }
        };
        /** ### ERC20 Token Contract Write Functions ### */
        /**
         * Approve `receiver` to spend `amount` tokens.
         * @param receiver The receiver approved.
         * @param amount The amount approved.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.approve = (params) => {
            const normalizedReceiver = normalizeAddress(params.receiver);
            const txn = this.contract.populateTransaction.approve(normalizedReceiver, params.amount, params.overrides || {});
            return new Operation(txn, "ERC20_APPROVE");
        };
        /**
         * Transfer `receiver` `amount` tokens.
         * @param receiver The receiver of the transfer.
         * @param amount The amount to be transferred.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.transfer = (params) => {
            const normalizedReceiver = normalizeAddress(params.receiver);
            const txn = this.contract.populateTransaction.transfer(normalizedReceiver, params.amount, params.overrides || {});
            return new Operation(txn, "UNSUPPORTED");
        };
        /**
         * Transfer from `sender` to `receiver` `amount` tokens.
         * @param sender The sender of the transfer.
         * @param receiver The receiver of the transfer.
         * @param amount The amount to be transferred.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.transferFrom = (params) => {
            const normalizedSender = normalizeAddress(params.sender);
            const normalizedReceiver = normalizeAddress(params.receiver);
            const txn = this.contract.populateTransaction.transferFrom(normalizedSender, normalizedReceiver, params.amount, params.overrides || {});
            return new Operation(txn, "ERC20_TRANSFER_FROM");
        };
        this.address = address;
        this.contract = new ethers.Contract(this.address, ERC20WithTokenInfoABI.abi);
    }
}
//# sourceMappingURL=ERC20Token.js.map