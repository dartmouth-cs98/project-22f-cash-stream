import { ethers } from "ethers";
import { SFError } from "./SFError";
/**
 * Operation Helper Class
 * @description A helper class to create `Operation` objects which can be executed or batched.
 */
export default class Operation {
    constructor(txn, type) {
        /**
         * Executes the operation via the provided signer.
         * @description Populates all fields of the transaction, signs it and sends it to the network.
         * @param signer The signer of the transacation
         * @returns {ethers.providers.TransactionResponse} A TransactionResponse object which can be awaited
         */
        this.exec = async (signer) => {
            try {
                const populatedTransaction = await this.getPopulatedTransactionRequest(signer);
                return await signer.sendTransaction(populatedTransaction);
            }
            catch (err) {
                throw new SFError({
                    type: "EXECUTE_TRANSACTION",
                    customMessage: "There was an error executing the transaction",
                    errorObject: err,
                });
            }
        };
        /**
         * Get the populated transaction by awaiting `populateTransactionPromise`.
         * @description Note that we need to populate the txn with the signer.
         * @returns {Promise<TransactionRequest>}
         */
        this.getPopulatedTransactionRequest = async (signer) => {
            try {
                const prePopulated = await this.populateTransactionPromise;
                return await signer.populateTransaction(prePopulated);
            }
            catch (err) {
                /* istanbul ignore next */
                throw new SFError({
                    type: "POPULATE_TRANSACTION",
                    customMessage: "There was an error populating the transaction",
                    errorObject: err,
                });
            }
        };
        /**
         * Signs the populated transaction via the provided signer (what you intend on sending to the network).
         * @param signer The signer of the transacation
         * @returns {Promise<string>} Fully serialized, signed transaction
         */
        this.getSignedTransaction = async (signer) => {
            try {
                const populatedTransaction = await this.getPopulatedTransactionRequest(signer);
                const signedTxn = await signer.signTransaction(populatedTransaction);
                return signedTxn;
            }
            catch (err) {
                throw new SFError({
                    type: "SIGN_TRANSACTION",
                    customMessage: "There was an error signing the transaction",
                    errorObject: err,
                });
            }
        };
        /**
         * Gets the transaction hash of the transaction.
         * @description Calculates this by getting the keccak256 hash of the signedTxn.
         * @param signer The signer of the transacation
         * @returns {Promise<string>} The transaction hash of the transaction
         */
        this.getTransactionHash = async (signer) => {
            const signedTxn = await this.getSignedTransaction(signer);
            return ethers.utils.keccak256(signedTxn);
        };
        this.populateTransactionPromise = txn;
        this.type = type;
    }
}
//# sourceMappingURL=Operation.js.map