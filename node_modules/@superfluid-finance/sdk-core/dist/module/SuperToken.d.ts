import { BytesLike, ethers, Overrides } from "ethers";
import ConstantFlowAgreementV1 from "./ConstantFlowAgreementV1";
import ERC20Token from "./ERC20Token";
import Governance from "./Governance";
import InstantDistributionAgreementV1 from "./InstantDistributionAgreementV1";
import Operation from "./Operation";
import { IConfig, IRealtimeBalanceOfParams, ISuperTokenBaseIDAParams, ISuperTokenCreateFlowByOperatorParams, ISuperTokenCreateFlowParams, ISuperTokenDeleteFlowParams, ISuperTokenDistributeParams, ISuperTokenFlowOperatorDataByIDParams, ISuperTokenFlowOperatorDataParams, ISuperTokenFullControlParams, ISuperTokenGetFlowInfoParams, ISuperTokenGetFlowParams, ISuperTokenGetIndexParams, ISuperTokenGetSubscriptionParams, ISuperTokenPublisherOperationParams, ISuperTokenPubSubParams, ISuperTokenUpdateFlowByOperatorParams, ISuperTokenUpdateFlowOperatorPermissionsParams, ISuperTokenUpdateFlowParams, ISuperTokenUpdateIndexValueParams, ISuperTokenUpdateSubscriptionUnitsParams, IWeb3FlowInfo, IWeb3FlowOperatorData, IWeb3GovernanceParams, IWeb3Index, IWeb3RealTimeBalanceOf, IWeb3Subscription } from "./interfaces";
import { SuperToken as ISuperToken } from "./typechain";
import { ISETH } from "./typechain/ISETH";
export interface ITokenSettings {
    readonly address: string;
    readonly config: IConfig;
    readonly chainId: number;
    readonly networkName: string;
}
export interface ITokenOptions {
    readonly address: string;
    readonly config: IConfig;
    readonly provider: ethers.providers.Provider;
    readonly chainId?: number;
    readonly networkName?: string;
}
/**
 * SuperToken Helper Class
 * @description A helper class to create `SuperToken` objects which can interact with the `SuperToken` contract as well as the CFAV1 and IDAV1 contracts of the desired `SuperToken`.
 * @see https://www.notion.so/superfluidhq/Classification-of-Super-Tokens-5beace780b5c4d09a5752a3677da3dc0 for further details on naming classification and underlying implementation.
 */
export default abstract class SuperToken extends ERC20Token {
    readonly options: ITokenOptions;
    readonly settings: ITokenSettings;
    readonly cfaV1: ConstantFlowAgreementV1;
    readonly idaV1: InstantDistributionAgreementV1;
    readonly governance: Governance;
    readonly underlyingToken?: ERC20Token;
    readonly contract: ISuperToken;
    protected constructor(options: ITokenOptions, settings: ITokenSettings);
    static create: (options: ITokenOptions) => Promise<SuperToken>;
    /** ### SuperToken Contract Read Functions ### */
    /**
     * Returns the real time balance of `address`.
     * @param account the target address
     * @param timestamp the timestamp you'd like to see the data
     * @param providerOrSigner a provider or signer for executing a web3 call
     * @returns {Promise<IWeb3RealTimeBalanceOf>} real time balance of data
     */
    realtimeBalanceOf: ({ providerOrSigner, account, timestamp, }: IRealtimeBalanceOfParams) => Promise<IWeb3RealTimeBalanceOf>;
    /** ### CFA Read Functions ### */
    /**
     * Get the details of a flow.
     * @param sender the sender of the flow
     * @param receiver the receiver of the flow
     * @param providerOrSigner a provider or signer object
     * @returns {Promise<IWeb3FlowInfo>} Web3 Flow info object
     */
    getFlow: (params: ISuperTokenGetFlowParams) => Promise<IWeb3FlowInfo>;
    /**
     * Get the flow info of an account (net flow).
     * @param account the account we're querying
     * @param providerOrSigner a provider or signer object
     * @returns {Promise<IWeb3FlowInfo>} Web3 Flow info object
     */
    getAccountFlowInfo: (params: ISuperTokenGetFlowInfoParams) => Promise<IWeb3FlowInfo>;
    /**
     * Get the net flow of an account.
     * @param account the account we're querying
     * @param providerOrSigner a provider or signer object
     * @returns {Promise<string>} Web3 Flow info object
     */
    getNetFlow: (params: ISuperTokenGetFlowInfoParams) => Promise<string>;
    /**
     * Get flow operator data.
     * @param sender the sender
     * @param flowOperator the flowOperator
     * @param providerOrSigner a provider or signer object
     * @returns {Promise<IWeb3FlowOperatorData>} Web3 Flow info object
     */
    getFlowOperatorData: (params: ISuperTokenFlowOperatorDataParams) => Promise<IWeb3FlowOperatorData>;
    /**
     * Get flow operator data using the flowOperatorId.
     * @param flowOperatorId The keccak256 hash of encoded string "flowOperator", sender and flowOperator
     * @param providerOrSigner a provider or signer object
     * @returns {Promise<IWeb3FlowOperatorData>} Web3 Flow info object
     */
    getFlowOperatorDataByID: (params: ISuperTokenFlowOperatorDataByIDParams) => Promise<IWeb3FlowOperatorData>;
    /** ### CFA Write Functions ### */
    /**
     * Create a flow of the token of this class.
     * @param receiver The receiver of the flow.
     * @param flowRate The specified flow rate.
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    createFlow: (params: ISuperTokenCreateFlowParams) => Operation;
    /**
     * Update a flow of the token of this class.
     * @param receiver The receiver of the flow.
     * @param flowRate The specified flow rate.
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    updateFlow: (params: ISuperTokenUpdateFlowParams) => Operation;
    /**
     * Delete a flow of the token of this class.
     * @param sender The sender of the flow.
     * @param receiver The receiver of the flow.
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    deleteFlow: (params: ISuperTokenDeleteFlowParams) => Operation;
    /** ### CFA ACL Write Functions (byOperator) ### */
    /**
     * Update permissions for a flow operator as a sender.
     * @param sender The sender of the flow.
     * @param flowOperator The permission grantee address
     * @param permission The permissions to set.
     * @param flowRateAllowance The flowRateAllowance granted to the flow operator.
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    updateFlowOperatorPermissions(params: ISuperTokenUpdateFlowOperatorPermissionsParams): Operation;
    /**
     * Give flow operator full control - max flow rate and create/update/delete permissions.
     * @param sender The sender of the flow.
     * @param flowOperator The permission grantee address
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     */
    authorizeFlowOperatorWithFullControl(params: ISuperTokenFullControlParams): Operation;
    /**
     * Revoke flow operator control - set flow rate to 0 with no permissions.
     * @param sender The sender of the flow.
     * @param flowOperator The permission grantee address
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     */
    revokeFlowOperatorWithFullControl(params: ISuperTokenFullControlParams): Operation;
    /**
     * Create a flow as an operator
     * @param flowRate The specified flow rate.
     * @param sender The sender of the flow.
     * @param receiver The receiver of the flow.
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    createFlowByOperator: (params: ISuperTokenCreateFlowByOperatorParams) => Operation;
    /**
     * Update a flow as an operator.
     * @param flowRate The specified flow rate.
     * @param sender The sender of the flow.
     * @param receiver The receiver of the flow.
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    updateFlowByOperator: (params: ISuperTokenUpdateFlowByOperatorParams) => Operation;
    /**
     * Delete a flow as an operator.
     * @param sender The sender of the flow.
     * @param receiver The receiver of the flow.
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    deleteFlowByOperator: (params: ISuperTokenDeleteFlowParams) => Operation;
    /** ### IDA Read Functions ### */
    /**
     * Get the details of a `Subscription`.
     * @param publisher the address of the publisher of the index
     * @param indexId the index id
     * @param subscriber the subscriber's address
     * @param providerOrSigner a provider or signer object
     * @returns {Promise<IWeb3Subscription>} Web3 Subscription object
     */
    getSubscription: (params: ISuperTokenGetSubscriptionParams) => Promise<IWeb3Subscription>;
    /**
     * Get the details of an `Index`.
     * @param publisher the address of the publisher of the index
     * @param indexId the index id
     * @param providerOrSigner a provider or signer object
     * @returns {Promise<IWeb3Index>} Web3 Index object
     */
    getIndex: (params: ISuperTokenGetIndexParams) => Promise<IWeb3Index>;
    /** ### IDA Write Functions ### */
    /**
     * Creates an IDA Index.
     * @param indexId The id of the index.
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    createIndex: (params: ISuperTokenBaseIDAParams) => Operation;
    /**
     * Distributes `amount` of token to an index
     * @param indexId The id of the index.
     * @param amount The amount of tokens to be distributed.
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    distribute: (params: ISuperTokenDistributeParams) => Operation;
    /**
     * Updates the `IndexValue` field of an index.
     * @param indexId The id of the index.
     * @param indexValue The new indexValue.
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     *
     * NOTE: It has the same effect as `distribute`, but is closer to the low level data structure of the index.
     */
    updateIndexValue: (params: ISuperTokenUpdateIndexValueParams) => Operation;
    /**
     * Updates the `units` allocated to a Subscription.
     * @param indexId The id of the index.
     * @param subscriber The subscriber address whose units you want to update.
     * @param units The amount of units you want to update to.
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    updateSubscriptionUnits: (params: ISuperTokenUpdateSubscriptionUnitsParams) => Operation;
    /**
     * Approves a Subscription, so the Subscriber won't need to claim tokens when the Publisher distributes.
     * @param indexId The id of the index.
     * @param publisher The publisher address whose subscription you want to approve.
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    approveSubscription: (params: ISuperTokenPublisherOperationParams) => Operation;
    /**
     * Revokes a Subscription, so the Subscriber will need to claim tokens when the Publisher distributes.
     * @param indexId The id of the index.
     * @param publisher The index publisher address you want to revoke for the subscriber.
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    revokeSubscription: (params: ISuperTokenPublisherOperationParams) => Operation;
    /**
     * Deletes a Subscription by setting the `units` allocated to the Subscriber to 0.
     * @param indexId The id of the index.
     * @param subscriber The subscriber address whose subscription you want to delete.
     * @param publisher The publisher address of the index you are targeting.
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    deleteSubscription: (params: ISuperTokenPubSubParams) => Operation;
    /**
     * Claims any pending tokens allocated to the Subscription (unapproved).
     * @param indexId The id of the index.
     * @param subscriber The subscriber address who you are claiming for.
     * @param publisher The publisher address of the index you are targeting.
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    claim: (params: ISuperTokenPubSubParams) => Operation;
    /** ### Governance Read Functions ### */
    getGovernanceParameters: (providerOrSigner: ethers.providers.Provider | ethers.Signer) => Promise<IWeb3GovernanceParams>;
}
/**
 * WrapperSuperToken has an underlying ERC20 token.
 */
export declare class WrapperSuperToken extends SuperToken {
    readonly underlyingToken: ERC20Token;
    constructor(options: ITokenOptions, settings: ITokenSettings & {
        underlyingTokenAddress: string;
    });
    /** ### WrapperSuperToken Contract Write Functions ### */
    /**
     * Downgrade `amount` SuperToken's.
     * @param amount The amount to be downgraded.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    downgrade: ({ amount, overrides, }: {
        amount: string;
        overrides?: (ethers.Overrides & {
            from?: string | Promise<string> | undefined;
        }) | undefined;
    }) => Operation;
    /**
     * Upgrade `amount` SuperToken's.
     * @param amount The amount to be upgraded.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    upgrade: ({ amount, overrides, }: {
        amount: string;
        overrides?: (ethers.Overrides & {
            from?: string | Promise<string> | undefined;
        }) | undefined;
    }) => Operation;
    /**
     * Upgrade `amount` of an ERC20 token to its SuperToken to `to` address.
     * @param amount The amount to be upgraded.
     * @param to The destination of the upgraded native asset super tokens.
     * @param data Bytes operatorData
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed.
     */
    upgradeTo: ({ amount, to, data, overrides, }: {
        amount: string;
        to: string;
        data?: BytesLike | undefined;
        overrides?: (ethers.Overrides & {
            from?: string | Promise<string> | undefined;
        }) | undefined;
    }) => Operation;
}
/**
 * PureSuperToken doesn't have any underlying ERC20 token.
 */
export declare class PureSuperToken extends SuperToken {
    constructor(options: ITokenOptions, settings: ITokenSettings);
}
/**
 * NativeAssetSuperToken wraps the native asset of the network.
 */
export declare class NativeAssetSuperToken extends SuperToken {
    readonly nativeTokenSymbol: string;
    constructor(options: ITokenOptions, settings: ITokenSettings, nativeTokenSymbol: string);
    get nativeAssetContract(): ISETH;
    /**
     * Upgrade `amount` of a network's native asset to its SuperToken.
     * @param amount The amount to be upgraded.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed.
     */
    upgrade: ({ amount, overrides, }: {
        amount: string;
        overrides?: (ethers.Overrides & {
            from?: string | Promise<string> | undefined;
        }) | undefined;
    }) => Operation;
    /**
     * Upgrade `amount` of a network's native asset to its SuperToken to `to` address.
     * @param amount The amount to be upgraded.
     * @param to The destination of the upgraded native asset super tokens.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed.
     */
    upgradeTo: ({ amount, to, overrides, }: {
        amount: string;
        to: string;
        overrides?: (ethers.Overrides & {
            from?: string | Promise<string> | undefined;
        }) | undefined;
    }) => Operation;
    /**
     * Downgrade `amount` of a native asset super token to the underlying native asset.
     * @param amount The amount to be upgraded.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed.
     */
    downgrade: ({ amount, overrides, }: {
        amount: string;
        overrides?: (ethers.Overrides & {
            from?: string | Promise<string> | undefined;
        }) | undefined;
    }) => Operation;
}
//# sourceMappingURL=SuperToken.d.ts.map