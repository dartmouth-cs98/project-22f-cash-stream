"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const Host_1 = __importDefault(require("./Host"));
const SFError_1 = require("./SFError");
const Superfluid_json_1 = __importDefault(require("./abi/Superfluid.json"));
const utils_1 = require("./utils");
const operationTypeStringToTypeMap = new Map([
    ["ERC20_APPROVE", 1],
    ["ERC20_TRANSFER_FROM", 2],
    ["SUPERTOKEN_UPGRADE", 101],
    ["SUPERTOKEN_DOWNGRADE", 102],
    ["SUPERFLUID_CALL_AGREEMENT", 201],
    ["CALL_APP_ACTION", 202],
]);
/**
 * BatchCall Helper Class
 * @description A helper class to create `BatchCall` objects which can be executed.
 */
class BatchCall {
    constructor(options) {
        /**
         * Gets the call agreement function arguments.
         * @param callData callData of the function
         * @returns {ethers.utils.Result} call agreement function arguments
         */
        this.getCallAgreementFunctionArgs = (callData) => (0, utils_1.getTransactionDescription)(Superfluid_json_1.default.abi, callData).args;
        /**
         * Given an `Operation` object, gets the `OperationStruct` object.
         * @param operation an `Operation` object
         * @param index the index of the `Operation` in the batchCall
         * @returns {Promise<OperationStruct>} OperationStruct object for batchCall
         */
        this.getOperationStruct = async (operation, index) => {
            const operationType = operationTypeStringToTypeMap.get(operation.type);
            const populatedTransaction = await operation.populateTransactionPromise;
            if (!operationType) {
                throw new SFError_1.SFError({
                    type: "UNSUPPORTED_OPERATION",
                    customMessage: "The operation at index " + index + " is unsupported.",
                });
            }
            /* istanbul ignore next */
            if (!populatedTransaction.to || !populatedTransaction.data) {
                throw new SFError_1.SFError({
                    type: "MISSING_TRANSACTION_PROPERTIES",
                    customMessage: "The transaction is missing the to or data property.",
                });
            }
            // Handles the Superfluid Call Agreement
            // The only operation which has a target that is not the
            // same as the to property of the transaction.
            if (operation.type === "SUPERFLUID_CALL_AGREEMENT") {
                const encoder = ethers_1.ethers.utils.defaultAbiCoder;
                const functionArgs = this.getCallAgreementFunctionArgs(populatedTransaction.data);
                const data = encoder.encode(["bytes", "bytes"], [functionArgs["callData"], functionArgs["userData"]]);
                return {
                    operationType,
                    target: functionArgs["agreementClass"],
                    data,
                };
            }
            // Handles other cases which are not call agreeement operation
            return {
                operationType,
                target: populatedTransaction.to,
                data: (0, utils_1.removeSigHashFromCallData)(populatedTransaction.data),
            };
        };
        /**
         * Executes a batch call given the operations on this class.
         * @param signer the signer of the transaction
         * @returns {Promise<ethers.ContractTransaction>} ContractTransaction object
         */
        this.exec = async (signer) => {
            try {
                const operationStructArray = await Promise.all(this.getOperationStructArrayPromises);
                return await this.host.contract
                    .connect(signer)
                    .batchCall(operationStructArray);
            }
            catch (err) {
                throw new SFError_1.SFError({
                    type: "BATCH_CALL_ERROR",
                    customMessage: "There was an error executing your batch call:",
                    errorObject: err,
                });
            }
        };
        /* istanbul ignore next */
        // TODO: user signs the transaction they'd like to execute and gives
        // this data to the trusted forwarder to sign
        /**
         * Executes a forward batch call given the operations on this class.
         * @param signer the signer of the transaction
         * @returns {Promise<ethers.ContractTransaction>} ContractTransaction object
         */
        this.execForward = async (signer) => {
            try {
                const operationStructArray = await Promise.all(this.getOperationStructArrayPromises);
                return await this.host.contract
                    .connect(signer)
                    .forwardBatchCall(operationStructArray);
            }
            catch (err) {
                throw new SFError_1.SFError({
                    type: "BATCH_CALL_ERROR",
                    customMessage: "There was an error executing your batch call:",
                    errorObject: err,
                });
            }
        };
        this.options = options;
        this.host = new Host_1.default(options.hostAddress);
    }
    /**
     * Gets an array of `OperationStruct` objects to be passed to batchCall.
     * @returns {Promise<OperationStruct>[]} array of operation struct promises
     */
    get getOperationStructArrayPromises() {
        return this.options.operations.map((x, i) => this.getOperationStruct(x, i));
    }
}
exports.default = BatchCall;
//# sourceMappingURL=BatchCall.js.map