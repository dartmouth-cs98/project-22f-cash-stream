import { JsonFragment } from "@ethersproject/abi";
import { HardhatEthersHelpers } from "@nomiclabs/hardhat-ethers/types";
import { ethers } from "ethers";
import Web3 from "web3";
import { IIndexSubscription } from "./interfaces";
/**
 * Checks if address is a valid ethereum address and normalizes so it can be used by both subgraph and web3.
 * @param address
 * @returns The normalized address.
 */
export declare const normalizeAddress: (address?: string | undefined) => string;
export declare const isPermissionsClean: (permissions: number) => boolean;
export declare const isNullOrEmpty: (str: string | null | undefined) => boolean;
/**
 * Removes the 8-character signature hash from `callData`.
 * @param callData
 * @returns function parameters
 */
export declare const removeSigHashFromCallData: (callData: string) => string;
/**
 * A wrapper function for getting the ethers TransactionDescription object given fragments (e.g. ABI), callData and the value amount sent.
 * @param fragments ABI
 * @param data callData of a function
 * @param value amount of ether sent
 * @returns ethers.TransactionDescription object
 */
export declare const getTransactionDescription: (fragments: string | readonly (string | ethers.utils.Fragment | JsonFragment)[], data: string, value?: string | undefined) => ethers.utils.TransactionDescription;
/**
 * Gets the per second flow rate given an `amountPerYear` value.
 * @param amountPerYear the amount you want to stream per year
 * @returns flow rate per second
 */
export declare const getPerSecondFlowRateByYear: (amountPerYear: string) => string;
/**
 * Gets the per second flow rate given an `amountPerMonth` value.
 * @param amountPerMonth the amount you want to stream per month
 * @returns flow rate per second
 */
export declare const getPerSecondFlowRateByMonth: (amountPerMonth: string) => string;
/**
 * Gets the per second flow rate given an `amountPerWeek` value.
 * @param amountPerWeek the amount you want to stream per Week
 * @returns flow rate per second
 */
export declare const getPerSecondFlowRateByWeek: (amountPerWeek: string) => string;
/**
 * Gets the per second flow rate given an `amountPerDay` value.
 * @param amountPerDay the amount you want to stream per day
 * @returns flow rate per second
 */
export declare const getPerSecondFlowRateByDay: (amountPerDay: string) => string;
/**
 * Gets daily, weekly, monthly and yearly flowed amounts given a per second flow rate.
 * @param perSecondFlowRate
 * @returns
 */
export declare const getFlowAmountByPerSecondFlowRate: (perSecondFlowRate: string) => {
    daily: string;
    weekly: string;
    monthly: string;
    yearly: string;
};
/**
 * The formula for calculating the flowed amount since updated using Subgraph data.
 * @param netFlowRate the net flow rate of the user
 * @param currentTimestamp the current timestamp
 * @param updatedAtTimestamp the updated at timestamp of the `AccountTokenSnapshot` entity
 * @returns the flowed amount since the updatedAt timestamp
 */
export declare const flowedAmountSinceUpdatedAt: ({ netFlowRate, currentTimestamp, updatedAtTimestamp, }: {
    netFlowRate: string;
    currentTimestamp: string;
    updatedAtTimestamp: string;
}) => number;
/**
 * The formula for calculating the total amount distributed to the subscriber (pending or received).
 * @param indexSubscriptions the index subscriptions of a single token from an account.
 * @returns the total amount received since updated at (both pending and actually distributed)
 */
export declare const subscriptionTotalAmountDistributedSinceUpdated: (indexSubscriptions: IIndexSubscription[]) => number;
/**
 * The formula for calculating the total amount received (approved subscriptions).
 * @param indexSubscriptions the index subscriptions of a single token from an account.
 * @returns the total amount received since updated at (actually distributed into wallet)
 */
export declare const subscriptionTotalAmountReceivedSinceUpdated: (indexSubscriptions: IIndexSubscription[]) => number;
/**
 * The formula for calculating the total amount that is claimable.
 * @param indexSubscriptions the index subscriptions of a single token from an account.
 * @returns the total amount that can be claimed since updated at
 */
export declare const subscriptionTotalAmountClaimableSinceUpdatedAt: (indexSubscriptions: IIndexSubscription[]) => number;
export declare const getStringCurrentTimeInSeconds: () => number;
export declare const getSanitizedTimestamp: (timestamp: ethers.BigNumberish) => Date;
/**
 * The formula for calculating the balance until updated at of a user (claimable + received tokens from index)
 * @param currentBalance the current balance until updated at from the `AccountTokenSnapshot` entity
 * @param netFlowRate the net flow rate of the user
 * @param currentTimestamp the current timestamp
 * @param updatedAtTimestamp the updated at timestamp of the `AccountTokenSnapshot` entity
 * @returns the balance since the updated at timestamp
 */
export declare const getBalance: ({ currentBalance, netFlowRate, currentTimestamp, updatedAtTimestamp, indexSubscriptions, }: {
    currentBalance: string;
    netFlowRate: string;
    currentTimestamp: string;
    updatedAtTimestamp: string;
    indexSubscriptions: IIndexSubscription[];
}) => number;
export declare const isEthersProvider: (provider: any) => provider is ethers.providers.Provider;
export declare const isInjectedWeb3: (provider: any) => provider is Web3;
export declare const isInjectedEthers: (provider: any) => provider is typeof ethers & HardhatEthersHelpers;
/**
 * Why? Because `return obj as T` and `return <T>obj` are not safe type casts.
 */
export declare const typeGuard: <T>(obj: T) => T;
export declare const getFlowOperatorId: (sender: string, flowOperator: string) => string;
//# sourceMappingURL=utils.d.ts.map