"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.takePlusOne = exports.nextLastIdPaging = exports.nextPageNumberPaging = exports.nextSkipPaging = exports.createLastIdPaging = exports.createPageNumberPaging = exports.createSkipPaging = exports.isAllPaging = exports.isLastIdPaging = exports.isPageNumberPaging = exports.isSkipPaging = exports.createPagedResult = void 0;
/**
 * Factory function to create a {@link PagedResult}.
 * @param dataPlusOne Subgraph queries are executed with one extra result to get which is over the {@link Paging} `take` amount.
 * @param paging
 */
const createPagedResult = (dataPlusOne, paging) => {
    var _a;
    const hasNextPage = dataPlusOne.length > paging.take;
    const data = dataPlusOne.slice(0, paging.take);
    const lastId = (_a = data.slice(-1)[0]) === null || _a === void 0 ? void 0 : _a.id;
    return {
        paging: { skip: paging.skip, take: paging.take },
        nextPaging: hasNextPage
            ? isSkipPaging(paging)
                ? (0, exports.nextSkipPaging)(paging)
                : isLastIdPaging(paging)
                    ? (0, exports.nextLastIdPaging)(paging, lastId)
                    : isPageNumberPaging(paging)
                        ? (0, exports.nextPageNumberPaging)(paging)
                        : undefined
            : undefined,
        data: data,
        items: data,
    };
};
exports.createPagedResult = createPagedResult;
function isSkipPaging(paging) {
    return (paging === null || paging === void 0 ? void 0 : paging.skip) !== undefined;
}
exports.isSkipPaging = isSkipPaging;
function isPageNumberPaging(paging) {
    return (paging === null || paging === void 0 ? void 0 : paging.pageNumber) !== undefined;
}
exports.isPageNumberPaging = isPageNumberPaging;
function isLastIdPaging(paging) {
    return (paging === null || paging === void 0 ? void 0 : paging.lastId) !== undefined;
}
exports.isLastIdPaging = isLastIdPaging;
function isAllPaging(paging) {
    return (paging !== undefined &&
        paging.skip === undefined &&
        paging.lastId === undefined &&
        paging.take === Infinity);
}
exports.isAllPaging = isAllPaging;
const createSkipPaging = ({ skip = 0, take = 100, } = {}) => ({
    skip: skip,
    take: take,
});
exports.createSkipPaging = createSkipPaging;
const createPageNumberPaging = ({ pageNumber = 1, take = 100, } = {}) => ({
    take: take,
    pageNumber: pageNumber,
});
exports.createPageNumberPaging = createPageNumberPaging;
const createLastIdPaging = ({ lastId = "", take = 100, } = {}) => ({
    take: take,
    lastId: lastId,
});
exports.createLastIdPaging = createLastIdPaging;
/**
 * Gets the next page given the skip/take used to initialize the `PagedResult` interface.
 * @returns the `Paging` class with the next page
 */
const nextSkipPaging = (paging) => ({
    skip: paging.skip + paging.take,
    take: paging.take,
});
exports.nextSkipPaging = nextSkipPaging;
const nextPageNumberPaging = (paging) => ({
    pageNumber: paging.pageNumber + 1,
    take: paging.take,
});
exports.nextPageNumberPaging = nextPageNumberPaging;
const nextLastIdPaging = (paging, nextLastId) => ({
    take: paging.take,
    lastId: nextLastId,
});
exports.nextLastIdPaging = nextLastIdPaging;
/**
 * Used to determine whether there is another page for pagination.
 * @returns the user's specified `take` plus one
 */
const takePlusOne = (paging) => {
    return paging.take + 1;
};
exports.takePlusOne = takePlusOne;
//# sourceMappingURL=pagination.js.map