"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const Host_1 = __importDefault(require("./Host"));
const SFError_1 = require("./SFError");
const IConstantFlowAgreementV1_json_1 = __importDefault(require("./abi/IConstantFlowAgreementV1.json"));
const utils_1 = require("./utils");
const cfaInterface = new ethers_1.ethers.utils.Interface(IConstantFlowAgreementV1_json_1.default.abi);
/**
 * Constant Flow Agreement V1 Helper Class
 * @description A helper class to interact with the CFAV1 contract.
 */
class ConstantFlowAgreementV1 {
    constructor(options) {
        /** ### CFA Read Functions ### */
        /**
         * Get the details of a flow.
         * @param superToken the superToken of the agreement
         * @param sender the sender of the flow
         * @param receiver the receiver of the flow
         * @param providerOrSigner a provider or signer object
         * @returns {Promise<IWeb3FlowInfo>} Web3 Flow info object
         */
        this.getFlow = async (params) => {
            const normalizedToken = (0, utils_1.normalizeAddress)(params.superToken);
            const normalizedSender = (0, utils_1.normalizeAddress)(params.sender);
            const normalizedReceiver = (0, utils_1.normalizeAddress)(params.receiver);
            try {
                const flowData = await this.contract
                    .connect(params.providerOrSigner)
                    .getFlow(normalizedToken, normalizedSender, normalizedReceiver);
                return this._sanitizeFlowInfo(flowData);
            }
            catch (err) {
                throw new SFError_1.SFError({
                    type: "CFAV1_READ",
                    customMessage: "There was an error getting the flow",
                    errorObject: err,
                });
            }
        };
        /**
         * Get the flow info of an account (net flow).
         * @param superToken the superToken of the agreement
         * @param account the account we're querying
         * @param providerOrSigner a provider or signer object
         * @returns {Promise<IWeb3FlowInfo>} Web3 Flow info object
         */
        this.getAccountFlowInfo = async (params) => {
            const normalizedToken = (0, utils_1.normalizeAddress)(params.superToken);
            const normalizedAccount = (0, utils_1.normalizeAddress)(params.account);
            try {
                const flowData = await this.contract
                    .connect(params.providerOrSigner)
                    .getAccountFlowInfo(normalizedToken, normalizedAccount);
                return this._sanitizeFlowInfo(flowData);
            }
            catch (err) {
                throw new SFError_1.SFError({
                    type: "CFAV1_READ",
                    customMessage: "There was an error getting the account flow information",
                    errorObject: err,
                });
            }
        };
        /**
         * Get the net flow of an account.
         * @param superToken the superToken of the agreement
         * @param account the account we're querying
         * @param providerOrSigner a provider or signer object
         * @returns {Promise<string>} Web3 Flow info object
         */
        this.getNetFlow = async (params) => {
            const normalizedToken = (0, utils_1.normalizeAddress)(params.superToken);
            const normalizedAccount = (0, utils_1.normalizeAddress)(params.account);
            try {
                return (await this.contract
                    .connect(params.providerOrSigner)
                    .getNetFlow(normalizedToken, normalizedAccount)).toString();
            }
            catch (err) {
                throw new SFError_1.SFError({
                    type: "CFAV1_READ",
                    customMessage: "There was an error getting net flow",
                    errorObject: err,
                });
            }
        };
        /**
         * Get flow operator data.
         * @param superToken the superToken of the agreement
         * @param sender the sender
         * @param flowOperator the flowOperator
         * @param providerOrSigner a provider or signer object
         * @returns {Promise<IWeb3FlowOperatorData>} Web3 Flow info object
         */
        this.getFlowOperatorData = async (params) => {
            const normalizedToken = (0, utils_1.normalizeAddress)(params.superToken);
            const normalizedSender = (0, utils_1.normalizeAddress)(params.sender);
            const normalizedFlowOperator = (0, utils_1.normalizeAddress)(params.flowOperator);
            try {
                const flowOperatorData = await this.contract
                    .connect(params.providerOrSigner)
                    .getFlowOperatorData(normalizedToken, normalizedSender, normalizedFlowOperator);
                return this._sanitizeFlowOperatorData(flowOperatorData);
            }
            catch (err) {
                throw new SFError_1.SFError({
                    type: "CFAV1_READ",
                    customMessage: "There was an error getting flow operator data",
                    errorObject: err,
                });
            }
        };
        /**
         * Get flow operator data using the flowOperatorId.
         * @param superToken the superToken of the agreement
         * @param flowOperatorId The keccak256 hash of encoded string "flowOperator", sender and flowOperator
         * @param providerOrSigner a provider or signer object
         * @returns {Promise<IWeb3FlowOperatorData>} Web3 Flow info object
         */
        this.getFlowOperatorDataByID = async (params) => {
            const normalizedToken = (0, utils_1.normalizeAddress)(params.superToken);
            try {
                const flowOperatorData = await this.contract
                    .connect(params.providerOrSigner)
                    .getFlowOperatorDataByID(normalizedToken, params.flowOperatorId);
                return this._sanitizeFlowOperatorData({
                    ...flowOperatorData,
                    flowOperatorId: params.flowOperatorId,
                });
            }
            catch (err) {
                throw new SFError_1.SFError({
                    type: "CFAV1_READ",
                    customMessage: "There was an error getting flow operator data",
                    errorObject: err,
                });
            }
        };
        /** ### CFA Write Functions ### */
        /**
         * Create a flow.
         * @param flowRate The specified flow rate.
         * @param receiver The receiver of the flow.
         * @param superToken The token to be flowed.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.createFlow = (params) => {
            const normalizedToken = (0, utils_1.normalizeAddress)(params.superToken);
            const normalizedReceiver = (0, utils_1.normalizeAddress)(params.receiver);
            const callData = cfaInterface.encodeFunctionData("createFlow", [
                normalizedToken,
                normalizedReceiver,
                params.flowRate,
                "0x",
            ]);
            return this.host.populateCallAgreementTxnAndReturnOperation(this.options.config.cfaV1Address, callData, params.userData, params.overrides);
        };
        /**
         * Update a flow.
         * @param flowRate The specified flow rate.
         * @param receiver The receiver of the flow.
         * @param superToken The token to be flowed.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.updateFlow = (params) => {
            const normalizedToken = (0, utils_1.normalizeAddress)(params.superToken);
            const normalizedReceiver = (0, utils_1.normalizeAddress)(params.receiver);
            const callData = cfaInterface.encodeFunctionData("updateFlow", [
                normalizedToken,
                normalizedReceiver,
                params.flowRate,
                "0x",
            ]);
            return this.host.populateCallAgreementTxnAndReturnOperation(this.options.config.cfaV1Address, callData, params.userData, params.overrides);
        };
        /**
         * Delete a flow.
         * @param superToken The token to be flowed.
         * @param sender The sender of the flow.
         * @param receiver The receiver of the flow.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.deleteFlow = (params) => {
            const normalizedToken = (0, utils_1.normalizeAddress)(params.superToken);
            const normalizedSender = (0, utils_1.normalizeAddress)(params.sender);
            const normalizedReceiver = (0, utils_1.normalizeAddress)(params.receiver);
            const callData = cfaInterface.encodeFunctionData("deleteFlow", [
                normalizedToken,
                normalizedSender,
                normalizedReceiver,
                "0x",
            ]);
            return this.host.populateCallAgreementTxnAndReturnOperation(this.options.config.cfaV1Address, callData, params.userData, params.overrides);
        };
        /**
         * Create a flow as an operator
         * @param flowRate The specified flow rate.
         * @param sender The sender of the flow.
         * @param receiver The receiver of the flow.
         * @param superToken The token to be flowed.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.createFlowByOperator = (params) => {
            const normalizedToken = (0, utils_1.normalizeAddress)(params.superToken);
            const normalizedReceiver = (0, utils_1.normalizeAddress)(params.receiver);
            const normalizedSender = (0, utils_1.normalizeAddress)(params.sender);
            const callData = cfaInterface.encodeFunctionData("createFlowByOperator", [
                normalizedToken,
                normalizedSender,
                normalizedReceiver,
                params.flowRate,
                "0x",
            ]);
            return this.host.populateCallAgreementTxnAndReturnOperation(this.options.config.cfaV1Address, callData, params.userData, params.overrides);
        };
        /**
         * Update a flow as an operator.
         * @param flowRate The specified flow rate.
         * @param sender The sender of the flow.
         * @param receiver The receiver of the flow.
         * @param superToken The token to be flowed.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.updateFlowByOperator = (params) => {
            const normalizedToken = (0, utils_1.normalizeAddress)(params.superToken);
            const normalizedSender = (0, utils_1.normalizeAddress)(params.sender);
            const normalizedReceiver = (0, utils_1.normalizeAddress)(params.receiver);
            const callData = cfaInterface.encodeFunctionData("updateFlowByOperator", [
                normalizedToken,
                normalizedSender,
                normalizedReceiver,
                params.flowRate,
                "0x",
            ]);
            return this.host.populateCallAgreementTxnAndReturnOperation(this.options.config.cfaV1Address, callData, params.userData, params.overrides);
        };
        /**
         * Delete a flow as an operator.
         * @param sender The sender of the flow.
         * @param receiver The receiver of the flow.
         * @param superToken The token to be flowed.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.deleteFlowByOperator = (params) => {
            const normalizedToken = (0, utils_1.normalizeAddress)(params.superToken);
            const normalizedSender = (0, utils_1.normalizeAddress)(params.sender);
            const normalizedReceiver = (0, utils_1.normalizeAddress)(params.receiver);
            const callData = cfaInterface.encodeFunctionData("deleteFlowByOperator", [normalizedToken, normalizedSender, normalizedReceiver, "0x"]);
            return this.host.populateCallAgreementTxnAndReturnOperation(this.options.config.cfaV1Address, callData, params.userData, params.overrides);
        };
        /** ### Private Functions ### */
        /**
         * Sanitizes flow info, converting BigNumber to string.
         * @param timestamp last updated timestamp of flow
         * @param flowRate the current flow rate
         * @param deposit the deposit amount
         * @param owedDeposit any owed depsit
         * @returns {IWeb3FlowInfo} sanitized web3 flow info
         */
        this._sanitizeFlowInfo = (params) => {
            return {
                timestamp: (0, utils_1.getSanitizedTimestamp)(params.timestamp),
                flowRate: params.flowRate.toString(),
                deposit: params.deposit.toString(),
                owedDeposit: params.owedDeposit.toString(),
            };
        };
        /**
         * Sanitizes flow operator data, converting BigNumber to string.
         * @param flowOperatorId The keccak256 hash of encoded string "flowOperator", sender and flowOperator
         * @param permissions the permissions
         * @param flowRateAllowance the flow rate allowance granted to the flow operator
         * @returns {IWeb3FlowOperatorData} sanitized web3 flow info
         */
        this._sanitizeFlowOperatorData = (params) => {
            return {
                flowOperatorId: params.flowOperatorId,
                permissions: params.permissions.toString(),
                flowRateAllowance: params.flowRateAllowance.toString(),
            };
        };
        this.options = options;
        this.host = new Host_1.default(options.config.hostAddress);
        this.contract = new ethers_1.ethers.Contract(this.options.config.cfaV1Address, IConstantFlowAgreementV1_json_1.default.abi);
    }
    /** ### CFA ACL Write Functions (byOperator) ### */
    /**
     * Update permissions for a flow operator as a sender.
     * @param superToken The token to be flowed.
     * @param flowOperator The permission grantee address
     * @param permission The permissions to set.
     * @param flowRateAllowance The flowRateAllowance granted to the flow operator.
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    updateFlowOperatorPermissions(params) {
        const normalizedToken = (0, utils_1.normalizeAddress)(params.superToken);
        const normalizedFlowOperator = (0, utils_1.normalizeAddress)(params.flowOperator);
        if (!(0, utils_1.isPermissionsClean)(params.permissions)) {
            throw new SFError_1.SFError({
                type: "UNCLEAN_PERMISSIONS",
                customMessage: "The desired permissions are unclean",
            });
        }
        if (Number(params.flowRateAllowance) < 0) {
            throw new SFError_1.SFError({
                type: "NEGATIVE_FLOW_ALLOWANCE",
                customMessage: "No negative flow allowance allowed",
            });
        }
        const callData = cfaInterface.encodeFunctionData("updateFlowOperatorPermissions", [
            normalizedToken,
            normalizedFlowOperator,
            params.permissions,
            params.flowRateAllowance,
            "0x",
        ]);
        return this.host.populateCallAgreementTxnAndReturnOperation(this.options.config.cfaV1Address, callData, params.userData, params.overrides);
    }
    /**
     * Give flow operator full control - max flow rate and create/update/delete permissions.
     * @param superToken The token to be flowed.
     * @param flowOperator The permission grantee address
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     */
    authorizeFlowOperatorWithFullControl(params) {
        const normalizedToken = (0, utils_1.normalizeAddress)(params.superToken);
        const normalizedFlowOperator = (0, utils_1.normalizeAddress)(params.flowOperator);
        const callData = cfaInterface.encodeFunctionData("authorizeFlowOperatorWithFullControl", [normalizedToken, normalizedFlowOperator, "0x"]);
        return this.host.populateCallAgreementTxnAndReturnOperation(this.options.config.cfaV1Address, callData, params.userData, params.overrides);
    }
    /**
     * Revoke flow operator control - set flow rate to 0 with no permissions.
     * @param superToken The token to be flowed.
     * @param flowOperator The permission grantee address
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     */
    revokeFlowOperatorWithFullControl(params) {
        const normalizedToken = (0, utils_1.normalizeAddress)(params.superToken);
        const normalizedFlowOperator = (0, utils_1.normalizeAddress)(params.flowOperator);
        const callData = cfaInterface.encodeFunctionData("revokeFlowOperatorWithFullControl", [normalizedToken, normalizedFlowOperator, "0x"]);
        return this.host.populateCallAgreementTxnAndReturnOperation(this.options.config.cfaV1Address, callData, params.userData, params.overrides);
    }
}
exports.default = ConstantFlowAgreementV1;
//# sourceMappingURL=ConstantFlowAgreementV1.js.map