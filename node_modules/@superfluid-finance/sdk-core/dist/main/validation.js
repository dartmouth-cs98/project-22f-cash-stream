"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAccountTokenSnapshotRequest = exports.validateStreamRequest = exports.validateIndexSubscriptionRequest = exports.validateIndexRequest = exports.validateEventRequest = exports.validateSuperTokenRequest = void 0;
const ajv_1 = __importDefault(require("ajv"));
const ethers_1 = require("ethers");
const SFError_1 = require("./SFError");
const ajv = new ajv_1.default();
ajv.addFormat("addressOrEmpty", {
    type: "string",
    validate: (x) => x === "" || ethers_1.ethers.utils.isAddress(x),
});
ajv.addFormat("stringNumber", {
    type: "string",
    validate: (x) => !isNaN(Number(x)),
});
// Schemas
const superTokenRequestSchema = {
    type: "object",
    additionalProperties: false,
    properties: {
        isListed: { type: "boolean", nullable: true },
    },
};
const eventRequestSchema = {
    type: "object",
    additionalProperties: false,
    properties: {
        account: { type: "string", format: "addressOrEmpty", nullable: true },
        timestamp_gt: {
            type: "number",
            nullable: true,
        },
    },
};
const indexRequestSchema = {
    type: "object",
    additionalProperties: false,
    properties: {
        indexId: { type: "string", format: "stringNumber", nullable: true },
        publisher: { type: "string", format: "addressOrEmpty", nullable: true },
        token: { type: "string", format: "addressOrEmpty", nullable: true },
    },
};
const accountTokenSnapshotRequestSchema = {
    type: "object",
    additionalProperties: false,
    properties: {
        account: {
            type: "string",
            format: "addressOrEmpty",
            nullable: true,
        },
        token: { type: "string", format: "addressOrEmpty", nullable: true },
    },
};
const indexSubscriptionRequestSchema = {
    type: "object",
    additionalProperties: false,
    properties: {
        subscriber: {
            type: "string",
            format: "stringNumber",
            nullable: true,
        },
        approved: { type: "boolean", nullable: true },
    },
};
const streamRequestSchema = {
    type: "object",
    additionalProperties: false,
    properties: {
        sender: { type: "string", format: "addressOrEmpty", nullable: true },
        receiver: { type: "string", format: "addressOrEmpty", nullable: true },
        token: { type: "string", format: "addressOrEmpty", nullable: true },
    },
};
function wrapValidationWithCustomError(validateFunction) {
    return (filter) => {
        if (!validateFunction(filter)) {
            throw new SFError_1.SFError({
                type: "INVALID_OBJECT",
                customMessage: "Invalid Filter Object",
                errorObject: validateFunction.errors,
            });
        }
    };
}
// Validate functions
exports.validateSuperTokenRequest = wrapValidationWithCustomError(ajv.compile(superTokenRequestSchema));
exports.validateEventRequest = wrapValidationWithCustomError(ajv.compile(eventRequestSchema));
exports.validateIndexRequest = wrapValidationWithCustomError(ajv.compile(indexRequestSchema));
exports.validateIndexSubscriptionRequest = wrapValidationWithCustomError(ajv.compile(indexSubscriptionRequestSchema));
exports.validateStreamRequest = wrapValidationWithCustomError(ajv.compile(streamRequestSchema));
exports.validateAccountTokenSnapshotRequest = wrapValidationWithCustomError(ajv.compile(accountTokenSnapshotRequestSchema));
//# sourceMappingURL=validation.js.map