"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeAssetSuperToken = exports.PureSuperToken = exports.WrapperSuperToken = void 0;
const ethers_1 = require("ethers");
const ConstantFlowAgreementV1_1 = __importDefault(require("./ConstantFlowAgreementV1"));
const ERC20Token_1 = __importDefault(require("./ERC20Token"));
const Governance_1 = __importDefault(require("./Governance"));
const InstantDistributionAgreementV1_1 = __importDefault(require("./InstantDistributionAgreementV1"));
const Operation_1 = __importDefault(require("./Operation"));
const SFError_1 = require("./SFError");
const ISETH_json_1 = __importDefault(require("./abi/ISETH.json"));
const SuperToken_json_1 = __importDefault(require("./abi/SuperToken.json"));
const constants_1 = require("./constants");
const frameworkHelpers_1 = require("./frameworkHelpers");
const utils_1 = require("./utils");
/**
 * SuperToken Helper Class
 * @description A helper class to create `SuperToken` objects which can interact with the `SuperToken` contract as well as the CFAV1 and IDAV1 contracts of the desired `SuperToken`.
 * @see https://www.notion.so/superfluidhq/Classification-of-Super-Tokens-5beace780b5c4d09a5752a3677da3dc0 for further details on naming classification and underlying implementation.
 */
class SuperToken extends ERC20Token_1.default {
    constructor(options, settings) {
        // initialize ERC20 token functions here
        super(settings.address);
        /** ### SuperToken Contract Read Functions ### */
        /**
         * Returns the real time balance of `address`.
         * @param account the target address
         * @param timestamp the timestamp you'd like to see the data
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @returns {Promise<IWeb3RealTimeBalanceOf>} real time balance of data
         */
        this.realtimeBalanceOf = async ({ providerOrSigner, account, timestamp = (0, utils_1.getStringCurrentTimeInSeconds)(), }) => {
            const normalizedAccount = (0, utils_1.normalizeAddress)(account);
            try {
                const realtimeBalanceOf = await this.contract
                    .connect(providerOrSigner)
                    .realtimeBalanceOf(normalizedAccount, timestamp);
                return {
                    availableBalance: realtimeBalanceOf.availableBalance.toString(),
                    deposit: realtimeBalanceOf.deposit.toString(),
                    owedDeposit: realtimeBalanceOf.owedDeposit.toString(),
                    timestamp: (0, utils_1.getSanitizedTimestamp)(timestamp),
                };
            }
            catch (err) {
                throw new SFError_1.SFError({
                    type: "SUPERTOKEN_READ",
                    customMessage: "There was an error getting realtimeBalanceOf",
                    errorObject: err,
                });
            }
        };
        /** ### CFA Read Functions ### */
        /**
         * Get the details of a flow.
         * @param sender the sender of the flow
         * @param receiver the receiver of the flow
         * @param providerOrSigner a provider or signer object
         * @returns {Promise<IWeb3FlowInfo>} Web3 Flow info object
         */
        this.getFlow = async (params) => {
            return await this.cfaV1.getFlow({
                superToken: this.settings.address,
                sender: params.sender,
                receiver: params.receiver,
                providerOrSigner: params.providerOrSigner,
            });
        };
        /**
         * Get the flow info of an account (net flow).
         * @param account the account we're querying
         * @param providerOrSigner a provider or signer object
         * @returns {Promise<IWeb3FlowInfo>} Web3 Flow info object
         */
        this.getAccountFlowInfo = async (params) => {
            return await this.cfaV1.getAccountFlowInfo({
                superToken: this.settings.address,
                account: params.account,
                providerOrSigner: params.providerOrSigner,
            });
        };
        /**
         * Get the net flow of an account.
         * @param account the account we're querying
         * @param providerOrSigner a provider or signer object
         * @returns {Promise<string>} Web3 Flow info object
         */
        this.getNetFlow = async (params) => {
            return await this.cfaV1.getNetFlow({
                superToken: this.settings.address,
                account: params.account,
                providerOrSigner: params.providerOrSigner,
            });
        };
        /**
         * Get flow operator data.
         * @param sender the sender
         * @param flowOperator the flowOperator
         * @param providerOrSigner a provider or signer object
         * @returns {Promise<IWeb3FlowOperatorData>} Web3 Flow info object
         */
        this.getFlowOperatorData = async (params) => {
            const normalizedSender = (0, utils_1.normalizeAddress)(params.sender);
            const normalizedFlowOperator = (0, utils_1.normalizeAddress)(params.flowOperator);
            return await this.cfaV1.getFlowOperatorData({
                superToken: this.settings.address,
                sender: normalizedSender,
                flowOperator: normalizedFlowOperator,
                providerOrSigner: params.providerOrSigner,
            });
        };
        /**
         * Get flow operator data using the flowOperatorId.
         * @param flowOperatorId The keccak256 hash of encoded string "flowOperator", sender and flowOperator
         * @param providerOrSigner a provider or signer object
         * @returns {Promise<IWeb3FlowOperatorData>} Web3 Flow info object
         */
        this.getFlowOperatorDataByID = async (params) => {
            return await this.cfaV1.getFlowOperatorDataByID({
                superToken: this.settings.address,
                flowOperatorId: params.flowOperatorId,
                providerOrSigner: params.providerOrSigner,
            });
        };
        /** ### CFA Write Functions ### */
        /**
         * Create a flow of the token of this class.
         * @param receiver The receiver of the flow.
         * @param flowRate The specified flow rate.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.createFlow = (params) => {
            return this.cfaV1.createFlow({
                superToken: this.settings.address,
                ...params,
            });
        };
        /**
         * Update a flow of the token of this class.
         * @param receiver The receiver of the flow.
         * @param flowRate The specified flow rate.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.updateFlow = (params) => {
            return this.cfaV1.updateFlow({
                superToken: this.settings.address,
                ...params,
            });
        };
        /**
         * Delete a flow of the token of this class.
         * @param sender The sender of the flow.
         * @param receiver The receiver of the flow.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.deleteFlow = (params) => {
            return this.cfaV1.deleteFlow({
                superToken: this.settings.address,
                ...params,
            });
        };
        /**
         * Create a flow as an operator
         * @param flowRate The specified flow rate.
         * @param sender The sender of the flow.
         * @param receiver The receiver of the flow.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.createFlowByOperator = (params) => {
            return this.cfaV1.createFlowByOperator({
                superToken: this.settings.address,
                ...params,
            });
        };
        /**
         * Update a flow as an operator.
         * @param flowRate The specified flow rate.
         * @param sender The sender of the flow.
         * @param receiver The receiver of the flow.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.updateFlowByOperator = (params) => {
            return this.cfaV1.updateFlowByOperator({
                superToken: this.settings.address,
                ...params,
            });
        };
        /**
         * Delete a flow as an operator.
         * @param sender The sender of the flow.
         * @param receiver The receiver of the flow.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.deleteFlowByOperator = (params) => {
            return this.cfaV1.deleteFlowByOperator({
                superToken: this.settings.address,
                ...params,
            });
        };
        /** ### IDA Read Functions ### */
        /**
         * Get the details of a `Subscription`.
         * @param publisher the address of the publisher of the index
         * @param indexId the index id
         * @param subscriber the subscriber's address
         * @param providerOrSigner a provider or signer object
         * @returns {Promise<IWeb3Subscription>} Web3 Subscription object
         */
        this.getSubscription = async (params) => {
            return await this.idaV1.getSubscription({
                superToken: this.settings.address,
                ...params,
            });
        };
        /**
         * Get the details of an `Index`.
         * @param publisher the address of the publisher of the index
         * @param indexId the index id
         * @param providerOrSigner a provider or signer object
         * @returns {Promise<IWeb3Index>} Web3 Index object
         */
        this.getIndex = async (params) => {
            return await this.idaV1.getIndex({
                superToken: this.settings.address,
                ...params,
            });
        };
        /** ### IDA Write Functions ### */
        /**
         * Creates an IDA Index.
         * @param indexId The id of the index.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.createIndex = (params) => {
            return this.idaV1.createIndex({
                superToken: this.settings.address,
                ...params,
            });
        };
        /**
         * Distributes `amount` of token to an index
         * @param indexId The id of the index.
         * @param amount The amount of tokens to be distributed.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.distribute = (params) => {
            return this.idaV1.distribute({
                superToken: this.settings.address,
                ...params,
            });
        };
        /**
         * Updates the `IndexValue` field of an index.
         * @param indexId The id of the index.
         * @param indexValue The new indexValue.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         *
         * NOTE: It has the same effect as `distribute`, but is closer to the low level data structure of the index.
         */
        this.updateIndexValue = (params) => {
            return this.idaV1.updateIndexValue({
                superToken: this.settings.address,
                ...params,
            });
        };
        /**
         * Updates the `units` allocated to a Subscription.
         * @param indexId The id of the index.
         * @param subscriber The subscriber address whose units you want to update.
         * @param units The amount of units you want to update to.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.updateSubscriptionUnits = (params) => {
            return this.idaV1.updateSubscriptionUnits({
                superToken: this.settings.address,
                ...params,
            });
        };
        /**
         * Approves a Subscription, so the Subscriber won't need to claim tokens when the Publisher distributes.
         * @param indexId The id of the index.
         * @param publisher The publisher address whose subscription you want to approve.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.approveSubscription = (params) => {
            return this.idaV1.approveSubscription({
                superToken: this.settings.address,
                ...params,
            });
        };
        /**
         * Revokes a Subscription, so the Subscriber will need to claim tokens when the Publisher distributes.
         * @param indexId The id of the index.
         * @param publisher The index publisher address you want to revoke for the subscriber.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.revokeSubscription = (params) => {
            return this.idaV1.revokeSubscription({
                superToken: this.settings.address,
                ...params,
            });
        };
        /**
         * Deletes a Subscription by setting the `units` allocated to the Subscriber to 0.
         * @param indexId The id of the index.
         * @param subscriber The subscriber address whose subscription you want to delete.
         * @param publisher The publisher address of the index you are targeting.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.deleteSubscription = (params) => {
            return this.idaV1.deleteSubscription({
                superToken: this.settings.address,
                ...params,
            });
        };
        /**
         * Claims any pending tokens allocated to the Subscription (unapproved).
         * @param indexId The id of the index.
         * @param subscriber The subscriber address who you are claiming for.
         * @param publisher The publisher address of the index you are targeting.
         * @param userData Extra user data provided.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.claim = (params) => {
            return this.idaV1.claim({
                superToken: this.settings.address,
                ...params,
            });
        };
        /** ### Governance Read Functions ### */
        this.getGovernanceParameters = async (providerOrSigner) => {
            return this.governance.getGovernanceParameters({
                providerOrSigner,
                token: this.settings.address,
            });
        };
        this.options = options;
        this.settings = settings;
        this.cfaV1 = new ConstantFlowAgreementV1_1.default({
            config: this.settings.config,
        });
        this.idaV1 = new InstantDistributionAgreementV1_1.default({
            config: this.settings.config,
        });
        this.governance = new Governance_1.default(this.settings.config.governanceAddress, this.settings.config.hostAddress);
        this.contract = new ethers_1.ethers.Contract(this.settings.address, SuperToken_json_1.default.abi);
    }
    /** ### CFA ACL Write Functions (byOperator) ### */
    /**
     * Update permissions for a flow operator as a sender.
     * @param sender The sender of the flow.
     * @param flowOperator The permission grantee address
     * @param permission The permissions to set.
     * @param flowRateAllowance The flowRateAllowance granted to the flow operator.
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     * @returns {Operation} An instance of Operation which can be executed or batched.
     */
    updateFlowOperatorPermissions(params) {
        return this.cfaV1.updateFlowOperatorPermissions({
            superToken: this.settings.address,
            ...params,
        });
    }
    /**
     * Give flow operator full control - max flow rate and create/update/delete permissions.
     * @param sender The sender of the flow.
     * @param flowOperator The permission grantee address
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     */
    authorizeFlowOperatorWithFullControl(params) {
        return this.cfaV1.authorizeFlowOperatorWithFullControl({
            superToken: this.settings.address,
            ...params,
        });
    }
    /**
     * Revoke flow operator control - set flow rate to 0 with no permissions.
     * @param sender The sender of the flow.
     * @param flowOperator The permission grantee address
     * @param userData Extra user data provided.
     * @param overrides ethers overrides object for more control over the transaction sent.
     */
    revokeFlowOperatorWithFullControl(params) {
        return this.cfaV1.revokeFlowOperatorWithFullControl({
            superToken: this.settings.address,
            ...params,
        });
    }
}
exports.default = SuperToken;
_a = SuperToken;
SuperToken.create = async (options) => {
    if (!options.chainId && !options.networkName) {
        throw new SFError_1.SFError({
            type: "SUPERTOKEN_INITIALIZATION",
            customMessage: "You must input chainId or networkName.",
        });
    }
    const networkName = (0, frameworkHelpers_1.getNetworkName)(options);
    const chainId = options.chainId || constants_1.networkNameToChainIdMap.get(networkName);
    try {
        const superToken = new ethers_1.ethers.Contract(options.address, SuperToken_json_1.default.abi);
        const underlyingTokenAddress = await superToken
            .connect(options.provider)
            .getUnderlyingToken();
        const settings = {
            address: options.address,
            config: options.config,
            chainId,
            networkName,
        };
        const tokenSymbol = await superToken
            .connect(options.provider)
            .symbol();
        const resolverData = constants_1.chainIdToResolverDataMap.get(chainId) || {
            subgraphAPIEndpoint: "",
            resolverAddress: "",
            networkName: "",
            nativeTokenSymbol: "",
        };
        const nativeTokenSymbol = resolverData.nativeTokenSymbol || "ETH";
        const nativeSuperTokenSymbol = nativeTokenSymbol + "x";
        if (nativeSuperTokenSymbol === tokenSymbol) {
            return new NativeAssetSuperToken(options, settings, nativeTokenSymbol);
        }
        if (underlyingTokenAddress !== ethers_1.ethers.constants.AddressZero) {
            return new WrapperSuperToken(options, {
                ...settings,
                underlyingTokenAddress,
            });
        }
        return new PureSuperToken(options, settings);
    }
    catch (err) {
        throw new SFError_1.SFError({
            type: "SUPERTOKEN_INITIALIZATION",
            customMessage: "There was an error initializing the SuperToken",
            errorObject: err,
        });
    }
};
/**
 * WrapperSuperToken has an underlying ERC20 token.
 */
class WrapperSuperToken extends SuperToken {
    constructor(options, settings) {
        super(options, settings);
        /** ### WrapperSuperToken Contract Write Functions ### */
        /**
         * Downgrade `amount` SuperToken's.
         * @param amount The amount to be downgraded.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.downgrade = ({ amount, overrides, }) => {
            const txn = this.contract.populateTransaction.downgrade(amount, overrides || {});
            return new Operation_1.default(txn, "SUPERTOKEN_DOWNGRADE");
        };
        /**
         * Upgrade `amount` SuperToken's.
         * @param amount The amount to be upgraded.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed or batched.
         */
        this.upgrade = ({ amount, overrides, }) => {
            const txn = this.contract.populateTransaction.upgrade(amount, overrides || {});
            return new Operation_1.default(txn, "SUPERTOKEN_UPGRADE");
        };
        /**
         * Upgrade `amount` of an ERC20 token to its SuperToken to `to` address.
         * @param amount The amount to be upgraded.
         * @param to The destination of the upgraded native asset super tokens.
         * @param data Bytes operatorData
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed.
         */
        this.upgradeTo = ({ amount, to, data = "0x", overrides, }) => {
            const txn = this.contract.populateTransaction.upgradeTo(to, amount, data, {
                ...overrides,
            });
            return new Operation_1.default(txn, "UNSUPPORTED");
        };
        this.underlyingToken = new ERC20Token_1.default(settings.underlyingTokenAddress);
    }
}
exports.WrapperSuperToken = WrapperSuperToken;
/**
 * PureSuperToken doesn't have any underlying ERC20 token.
 */
class PureSuperToken extends SuperToken {
    constructor(options, settings) {
        super(options, settings);
    }
}
exports.PureSuperToken = PureSuperToken;
/**
 * NativeAssetSuperToken wraps the native asset of the network.
 */
class NativeAssetSuperToken extends SuperToken {
    constructor(options, settings, nativeTokenSymbol) {
        super(options, settings);
        /**
         * Upgrade `amount` of a network's native asset to its SuperToken.
         * @param amount The amount to be upgraded.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed.
         */
        this.upgrade = ({ amount, overrides, }) => {
            const txn = this.nativeAssetContract.populateTransaction.upgradeByETH({
                ...overrides,
                value: amount,
            });
            return new Operation_1.default(txn, "UNSUPPORTED");
        };
        /**
         * Upgrade `amount` of a network's native asset to its SuperToken to `to` address.
         * @param amount The amount to be upgraded.
         * @param to The destination of the upgraded native asset super tokens.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed.
         */
        this.upgradeTo = ({ amount, to, overrides, }) => {
            const txn = this.nativeAssetContract.populateTransaction.upgradeByETHTo(to, {
                ...overrides,
                value: amount,
            });
            return new Operation_1.default(txn, "UNSUPPORTED");
        };
        /**
         * Downgrade `amount` of a native asset super token to the underlying native asset.
         * @param amount The amount to be upgraded.
         * @param overrides ethers overrides object for more control over the transaction sent.
         * @returns {Operation} An instance of Operation which can be executed.
         */
        this.downgrade = ({ amount, overrides, }) => {
            const txn = this.nativeAssetContract.populateTransaction.downgradeToETH(amount, {
                ...overrides,
            });
            return new Operation_1.default(txn, "UNSUPPORTED");
        };
        this.nativeTokenSymbol = nativeTokenSymbol;
    }
    get nativeAssetContract() {
        return new ethers_1.ethers.Contract(this.settings.address, ISETH_json_1.default.abi);
    }
}
exports.NativeAssetSuperToken = NativeAssetSuperToken;
//# sourceMappingURL=SuperToken.js.map