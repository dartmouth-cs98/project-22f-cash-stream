"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const SuperfluidGovernanceII_json_1 = __importDefault(require("./abi/SuperfluidGovernanceII.json"));
class Governance {
    constructor(govAddress, hostAddress) {
        /**
         * Returns the 3Ps config for the specified token (or default) - the liquidation period and patrician period
         * @see https://docs.superfluid.finance/superfluid/sentinels/liquidations-and-toga
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @param token specified governance parameter token
         * @returns {Object} liquidationPeriod and patricianPeriod as strings
         */
        this.getPPPConfig = async ({ providerOrSigner, token = ethers_1.ethers.constants.AddressZero, }) => {
            const { liquidationPeriod, patricianPeriod } = await this.contract
                .connect(providerOrSigner)
                .getPPPConfig(this.hostAddress, token);
            return {
                liquidationPeriod: liquidationPeriod.toString(),
                patricianPeriod: patricianPeriod.toString(),
            };
        };
        /**
         * Returns the reward address for the specified token (or default)
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @param token specified governance parameter token
         * @returns {string} the reward address
         */
        this.getRewardAddress = async ({ providerOrSigner, token = ethers_1.ethers.constants.AddressZero, }) => {
            return await this.contract
                .connect(providerOrSigner)
                .getRewardAddress(this.hostAddress, token);
        };
        /**
         * Returns the minimum deposit for the specified token (or default)
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @param token specified governance parameter token
         * @returns {string} minimum deposit
         */
        this.getMinimumDeposit = async ({ providerOrSigner, token = ethers_1.ethers.constants.AddressZero, }) => {
            const superTokenMinimumDeposit = await this.contract
                .connect(providerOrSigner)
                .getSuperTokenMinimumDeposit(this.hostAddress, token);
            return superTokenMinimumDeposit.toString();
        };
        /**
         * Returns the relevant governance parameters
         * @param providerOrSigner a provider or signer for executing a web3 call
         * @param token specified governance parameter token
         * @returns {Object} liquidationPeriod, patricianPeriod, rewardAddress and minimumDeposit
         */
        this.getGovernanceParameters = async ({ providerOrSigner, token = ethers_1.ethers.constants.AddressZero, }) => {
            const pppPromise = this.getPPPConfig({ providerOrSigner, token });
            const rewardPromose = this.getRewardAddress({
                providerOrSigner,
                token,
            });
            const minimumDepositPromise = this.getMinimumDeposit({
                providerOrSigner,
                token,
            });
            const data = await Promise.all([
                pppPromise,
                rewardPromose,
                minimumDepositPromise,
            ]);
            return {
                liquidationPeriod: data[0].liquidationPeriod,
                patricianPeriod: data[0].patricianPeriod,
                rewardAddress: data[1],
                minimumDeposit: data[2],
            };
        };
        this.contract = new ethers_1.ethers.Contract(govAddress, SuperfluidGovernanceII_json_1.default.abi);
        this.hostAddress = hostAddress;
    }
}
exports.default = Governance;
//# sourceMappingURL=Governance.js.map