import { ILightEntity } from "./interfaces";
/**
 * Paging Helper Class
 */
export declare type Paging = {
    readonly take: number;
    readonly skip?: number;
    readonly lastId?: string;
    readonly pageNumber?: number;
};
/**
 * For paginating Subgraph queries by using skip and take approach. Good for small result sets, not performant for large sets.
 * Use {@link LastIdPaging} for most performant pagination strategy.
 * NOTE: Also known as "offset based pagination".
 */
export declare type SkipPaging = {
    readonly take: number;
    readonly skip: number;
};
/**
 * For paginating Subgraph queries by using the last ID of the previous paged result to get the next page.
 * Relies on Subgraph ordering ID's in ascending order which it always does unless the results are ordered by `id` in `desc` order.
 * NOTE: Also known as "cursor based pagination".
 */
export declare type LastIdPaging = {
    readonly take: number;
    readonly lastId: string;
};
/**
 * WARNING: Works only with the new QueryHandlers.
 * Essentially the same as @see SkipPaging but with more UI pagination friendly API.
 */
export declare type PageNumberPaging = {
    /**
     * "Page size" in other words.
     */
    readonly take: number;
    /**
     * Page number starts from 1.
     */
    readonly pageNumber: number;
};
/**
 * WARNING: Works only with number literal of @see Number.POSITIVE_INFINITY.
 * WARNING: Works only with the new QueryHandlers.
 * Recursively gets all the possible Subgraph results.
 */
export declare type AllPaging = {
    readonly take: number;
};
/**
 * PagedResult Interface
 */
export interface PagedResult<T extends ILightEntity> {
    /**
     * The pagination used for current data.
     */
    readonly paging: Paging;
    /**
     * {@link Paging} for getting the next page.
     * `undefined` when there's no next page.
     */
    readonly nextPaging?: Paging;
    /**
     * @obsolete Use `items` instead.
     */
    readonly data: T[];
    readonly items: T[];
}
/**
 * Factory function to create a {@link PagedResult}.
 * @param dataPlusOne Subgraph queries are executed with one extra result to get which is over the {@link Paging} `take` amount.
 * @param paging
 */
export declare const createPagedResult: <T extends ILightEntity>(dataPlusOne: T[], paging: Paging) => PagedResult<T>;
export declare function isSkipPaging(paging?: Paging): paging is SkipPaging;
export declare function isPageNumberPaging(paging?: Paging): paging is PageNumberPaging;
export declare function isLastIdPaging(paging?: Paging): paging is LastIdPaging;
export declare function isAllPaging(paging?: Paging): paging is AllPaging;
export declare const createSkipPaging: ({ skip, take, }?: {
    skip?: number | undefined;
    take?: number | undefined;
}) => SkipPaging;
export declare const createPageNumberPaging: ({ pageNumber, take, }?: {
    pageNumber?: number | undefined;
    take?: number | undefined;
}) => PageNumberPaging;
export declare const createLastIdPaging: ({ lastId, take, }?: {
    lastId?: string | undefined;
    take?: number | undefined;
}) => LastIdPaging;
/**
 * Gets the next page given the skip/take used to initialize the `PagedResult` interface.
 * @returns the `Paging` class with the next page
 */
export declare const nextSkipPaging: (paging: SkipPaging) => SkipPaging;
export declare const nextPageNumberPaging: (paging: PageNumberPaging) => PageNumberPaging;
export declare const nextLastIdPaging: (paging: LastIdPaging, nextLastId: string) => LastIdPaging;
/**
 * Used to determine whether there is another page for pagination.
 * @returns the user's specified `take` plus one
 */
export declare const takePlusOne: (paging: Paging) => number;
//# sourceMappingURL=pagination.d.ts.map