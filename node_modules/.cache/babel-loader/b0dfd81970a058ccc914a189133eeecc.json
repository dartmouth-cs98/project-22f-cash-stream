{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _regeneratorRuntime = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _objectSpread = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", {\n  enumerable: true,\n  get: function get() {\n    return validate_1.KeywordCxt;\n  }\n});\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", {\n  enumerable: true,\n  get: function get() {\n    return codegen_1._;\n  }\n});\nObject.defineProperty(exports, \"str\", {\n  enumerable: true,\n  get: function get() {\n    return codegen_1.str;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function get() {\n    return codegen_1.stringify;\n  }\n});\nObject.defineProperty(exports, \"nil\", {\n  enumerable: true,\n  get: function get() {\n    return codegen_1.nil;\n  }\n});\nObject.defineProperty(exports, \"Name\", {\n  enumerable: true,\n  get: function get() {\n    return codegen_1.Name;\n  }\n});\nObject.defineProperty(exports, \"CodeGen\", {\n  enumerable: true,\n  get: function get() {\n    return codegen_1.CodeGen;\n  }\n});\nvar validation_error_1 = require(\"./runtime/validation_error\");\nvar ref_error_1 = require(\"./compile/ref_error\");\nvar rules_1 = require(\"./compile/rules\");\nvar compile_1 = require(\"./compile\");\nvar codegen_2 = require(\"./compile/codegen\");\nvar resolve_1 = require(\"./compile/resolve\");\nvar dataType_1 = require(\"./compile/validate/dataType\");\nvar util_1 = require(\"./compile/util\");\nvar $dataRefSchema = require(\"./refs/data.json\");\nvar uri_1 = require(\"./runtime/uri\");\nvar defaultRegExp = function defaultRegExp(str, flags) {\n  return new RegExp(str, flags);\n};\ndefaultRegExp.code = \"new RegExp\";\nvar META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nvar EXT_SCOPE_NAMES = new Set([\"validate\", \"serialize\", \"parse\", \"wrapper\", \"root\", \"schema\", \"keyword\", \"pattern\", \"formats\", \"validate$data\", \"func\", \"obj\", \"Error\"]);\nvar removedOptions = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\"\n};\nvar deprecatedOptions = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.'\n};\nvar MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n  var s = o.strict;\n  var _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n  var optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n  var regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n  var uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n  return {\n    strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n    strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n    strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n    strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n    strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n    code: o.code ? _objectSpread(_objectSpread({}, o.code), {}, {\n      optimize: optimize,\n      regExp: regExp\n    }) : {\n      optimize: optimize,\n      regExp: regExp\n    },\n    loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n    loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n    meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n    messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n    inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n    schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n    addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n    validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n    validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n    unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n    int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n    uriResolver: uriResolver\n  };\n}\nvar Ajv = /*#__PURE__*/function () {\n  function Ajv() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, Ajv);\n    this.schemas = {};\n    this.refs = {};\n    this.formats = {};\n    this._compilations = new Set();\n    this._loading = {};\n    this._cache = new Map();\n    opts = this.opts = _objectSpread(_objectSpread({}, opts), requiredOptions(opts));\n    var _this$opts$code = this.opts.code,\n      es5 = _this$opts$code.es5,\n      lines = _this$opts$code.lines;\n    this.scope = new codegen_2.ValueScope({\n      scope: {},\n      prefixes: EXT_SCOPE_NAMES,\n      es5: es5,\n      lines: lines\n    });\n    this.logger = getLogger(opts.logger);\n    var formatOpt = opts.validateFormats;\n    opts.validateFormats = false;\n    this.RULES = (0, rules_1.getRules)();\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n    this._metaOpts = getMetaSchemaOptions.call(this);\n    if (opts.formats) addInitialFormats.call(this);\n    this._addVocabularies();\n    this._addDefaultMetaSchema();\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords);\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta);\n    addInitialSchemas.call(this);\n    opts.validateFormats = formatOpt;\n  }\n  _createClass(Ajv, [{\n    key: \"_addVocabularies\",\n    value: function _addVocabularies() {\n      this.addKeyword(\"$async\");\n    }\n  }, {\n    key: \"_addDefaultMetaSchema\",\n    value: function _addDefaultMetaSchema() {\n      var _this$opts = this.opts,\n        $data = _this$opts.$data,\n        meta = _this$opts.meta,\n        schemaId = _this$opts.schemaId;\n      var _dataRefSchema = $dataRefSchema;\n      if (schemaId === \"id\") {\n        _dataRefSchema = _objectSpread({}, $dataRefSchema);\n        _dataRefSchema.id = _dataRefSchema.$id;\n        delete _dataRefSchema.$id;\n      }\n      if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n  }, {\n    key: \"defaultMeta\",\n    value: function defaultMeta() {\n      var _this$opts2 = this.opts,\n        meta = _this$opts2.meta,\n        schemaId = _this$opts2.schemaId;\n      return this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(schemaKeyRef,\n    // key, ref or schema object\n    data // to be validated\n    ) {\n      var v;\n      if (typeof schemaKeyRef == \"string\") {\n        v = this.getSchema(schemaKeyRef);\n        if (!v) throw new Error(\"no schema with key or ref \\\"\".concat(schemaKeyRef, \"\\\"\"));\n      } else {\n        v = this.compile(schemaKeyRef);\n      }\n      var valid = v(data);\n      if (!(\"$async\" in v)) this.errors = v.errors;\n      return valid;\n    }\n  }, {\n    key: \"compile\",\n    value: function compile(schema, _meta) {\n      var sch = this._addSchema(schema, _meta);\n      return sch.validate || this._compileSchemaEnv(sch);\n    }\n  }, {\n    key: \"compileAsync\",\n    value: function compileAsync(schema, meta) {\n      if (typeof this.opts.loadSchema != \"function\") {\n        throw new Error(\"options.loadSchema should be a function\");\n      }\n      var loadSchema = this.opts.loadSchema;\n      return runCompileAsync.call(this, schema, meta);\n      function runCompileAsync(_x2, _x3) {\n        return _runCompileAsync.apply(this, arguments);\n      }\n      function _runCompileAsync() {\n        _runCompileAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_schema, _meta) {\n          var sch;\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return loadMetaSchema.call(this, _schema.$schema);\n                case 2:\n                  sch = this._addSchema(_schema, _meta);\n                  return _context.abrupt(\"return\", sch.validate || _compileAsync.call(this, sch));\n                case 4:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n        return _runCompileAsync.apply(this, arguments);\n      }\n      function loadMetaSchema(_x4) {\n        return _loadMetaSchema.apply(this, arguments);\n      }\n      function _loadMetaSchema() {\n        _loadMetaSchema = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2($ref) {\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (!($ref && !this.getSchema($ref))) {\n                    _context2.next = 3;\n                    break;\n                  }\n                  _context2.next = 3;\n                  return runCompileAsync.call(this, {\n                    $ref: $ref\n                  }, true);\n                case 3:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n        return _loadMetaSchema.apply(this, arguments);\n      }\n      function _compileAsync(_x5) {\n        return _compileAsync2.apply(this, arguments);\n      }\n      function _compileAsync2() {\n        _compileAsync2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(sch) {\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.prev = 0;\n                  return _context3.abrupt(\"return\", this._compileSchemaEnv(sch));\n                case 4:\n                  _context3.prev = 4;\n                  _context3.t0 = _context3[\"catch\"](0);\n                  if (_context3.t0 instanceof ref_error_1.default) {\n                    _context3.next = 8;\n                    break;\n                  }\n                  throw _context3.t0;\n                case 8:\n                  checkLoaded.call(this, _context3.t0);\n                  _context3.next = 11;\n                  return loadMissingSchema.call(this, _context3.t0.missingSchema);\n                case 11:\n                  return _context3.abrupt(\"return\", _compileAsync.call(this, sch));\n                case 12:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this, [[0, 4]]);\n        }));\n        return _compileAsync2.apply(this, arguments);\n      }\n      function checkLoaded(_ref) {\n        var ref = _ref.missingSchema,\n          missingRef = _ref.missingRef;\n        if (this.refs[ref]) {\n          throw new Error(\"AnySchema \".concat(ref, \" is loaded but \").concat(missingRef, \" cannot be resolved\"));\n        }\n      }\n      function loadMissingSchema(_x6) {\n        return _loadMissingSchema.apply(this, arguments);\n      }\n      function _loadMissingSchema() {\n        _loadMissingSchema = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(ref) {\n          var _schema;\n          return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.next = 2;\n                  return _loadSchema.call(this, ref);\n                case 2:\n                  _schema = _context4.sent;\n                  if (this.refs[ref]) {\n                    _context4.next = 6;\n                    break;\n                  }\n                  _context4.next = 6;\n                  return loadMetaSchema.call(this, _schema.$schema);\n                case 6:\n                  if (!this.refs[ref]) this.addSchema(_schema, ref, meta);\n                case 7:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, this);\n        }));\n        return _loadMissingSchema.apply(this, arguments);\n      }\n      function _loadSchema(_x7) {\n        return _loadSchema2.apply(this, arguments);\n      }\n      function _loadSchema2() {\n        _loadSchema2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(ref) {\n          var p;\n          return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  p = this._loading[ref];\n                  if (!p) {\n                    _context5.next = 3;\n                    break;\n                  }\n                  return _context5.abrupt(\"return\", p);\n                case 3:\n                  _context5.prev = 3;\n                  _context5.next = 6;\n                  return this._loading[ref] = loadSchema(ref);\n                case 6:\n                  return _context5.abrupt(\"return\", _context5.sent);\n                case 7:\n                  _context5.prev = 7;\n                  delete this._loading[ref];\n                  return _context5.finish(7);\n                case 10:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, this, [[3,, 7, 10]]);\n        }));\n        return _loadSchema2.apply(this, arguments);\n      }\n    }\n    // Adds schema to the instance\n  }, {\n    key: \"addSchema\",\n    value: function addSchema(schema,\n    // If array is passed, `key` will be ignored\n    key,\n    // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta) {\n      var _validateSchema = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.opts.validateSchema;\n      if (Array.isArray(schema)) {\n        var _iterator = _createForOfIteratorHelper(schema),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var sch = _step.value;\n            this.addSchema(sch, undefined, _meta, _validateSchema);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        return this;\n      }\n      var id;\n      if (typeof schema === \"object\") {\n        var schemaId = this.opts.schemaId;\n        id = schema[schemaId];\n        if (id !== undefined && typeof id != \"string\") {\n          throw new Error(\"schema \".concat(schemaId, \" must be string\"));\n        }\n      }\n      key = (0, resolve_1.normalizeId)(key || id);\n      this._checkUnique(key);\n      this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n      return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n  }, {\n    key: \"addMetaSchema\",\n    value: function addMetaSchema(schema, key) {\n      var _validateSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.opts.validateSchema;\n      this.addSchema(schema, key, true, _validateSchema);\n      return this;\n    }\n    //  Validate schema against its meta-schema\n  }, {\n    key: \"validateSchema\",\n    value: function validateSchema(schema, throwOrLogError) {\n      if (typeof schema == \"boolean\") return true;\n      var $schema;\n      $schema = schema.$schema;\n      if ($schema !== undefined && typeof $schema != \"string\") {\n        throw new Error(\"$schema must be a string\");\n      }\n      $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n      if (!$schema) {\n        this.logger.warn(\"meta-schema not available\");\n        this.errors = null;\n        return true;\n      }\n      var valid = this.validate($schema, schema);\n      if (!valid && throwOrLogError) {\n        var message = \"schema is invalid: \" + this.errorsText();\n        if (this.opts.validateSchema === \"log\") this.logger.error(message);else throw new Error(message);\n      }\n      return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  }, {\n    key: \"getSchema\",\n    value: function getSchema(keyRef) {\n      var sch;\n      while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") {\n        keyRef = sch;\n      }\n      if (sch === undefined) {\n        var schemaId = this.opts.schemaId;\n        var root = new compile_1.SchemaEnv({\n          schema: {},\n          schemaId: schemaId\n        });\n        sch = compile_1.resolveSchema.call(this, root, keyRef);\n        if (!sch) return;\n        this.refs[keyRef] = sch;\n      }\n      return sch.validate || this._compileSchemaEnv(sch);\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  }, {\n    key: \"removeSchema\",\n    value: function removeSchema(schemaKeyRef) {\n      if (schemaKeyRef instanceof RegExp) {\n        this._removeAllSchemas(this.schemas, schemaKeyRef);\n        this._removeAllSchemas(this.refs, schemaKeyRef);\n        return this;\n      }\n      switch (typeof schemaKeyRef) {\n        case \"undefined\":\n          this._removeAllSchemas(this.schemas);\n          this._removeAllSchemas(this.refs);\n          this._cache.clear();\n          return this;\n        case \"string\":\n          {\n            var sch = getSchEnv.call(this, schemaKeyRef);\n            if (typeof sch == \"object\") this._cache.delete(sch.schema);\n            delete this.schemas[schemaKeyRef];\n            delete this.refs[schemaKeyRef];\n            return this;\n          }\n        case \"object\":\n          {\n            var cacheKey = schemaKeyRef;\n            this._cache.delete(cacheKey);\n            var id = schemaKeyRef[this.opts.schemaId];\n            if (id) {\n              id = (0, resolve_1.normalizeId)(id);\n              delete this.schemas[id];\n              delete this.refs[id];\n            }\n            return this;\n          }\n        default:\n          throw new Error(\"ajv.removeSchema: invalid parameter\");\n      }\n    }\n    // add \"vocabulary\" - a collection of keywords\n  }, {\n    key: \"addVocabulary\",\n    value: function addVocabulary(definitions) {\n      var _iterator2 = _createForOfIteratorHelper(definitions),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var def = _step2.value;\n          this.addKeyword(def);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return this;\n    }\n  }, {\n    key: \"addKeyword\",\n    value: function addKeyword(kwdOrDef, def // deprecated\n    ) {\n      var _this = this;\n      var keyword;\n      if (typeof kwdOrDef == \"string\") {\n        keyword = kwdOrDef;\n        if (typeof def == \"object\") {\n          this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n          def.keyword = keyword;\n        }\n      } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n        def = kwdOrDef;\n        keyword = def.keyword;\n        if (Array.isArray(keyword) && !keyword.length) {\n          throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n        }\n      } else {\n        throw new Error(\"invalid addKeywords parameters\");\n      }\n      checkKeyword.call(this, keyword, def);\n      if (!def) {\n        (0, util_1.eachItem)(keyword, function (kwd) {\n          return addRule.call(_this, kwd);\n        });\n        return this;\n      }\n      keywordMetaschema.call(this, def);\n      var definition = _objectSpread(_objectSpread({}, def), {}, {\n        type: (0, dataType_1.getJSONTypes)(def.type),\n        schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)\n      });\n      (0, util_1.eachItem)(keyword, definition.type.length === 0 ? function (k) {\n        return addRule.call(_this, k, definition);\n      } : function (k) {\n        return definition.type.forEach(function (t) {\n          return addRule.call(_this, k, definition, t);\n        });\n      });\n      return this;\n    }\n  }, {\n    key: \"getKeyword\",\n    value: function getKeyword(keyword) {\n      var rule = this.RULES.all[keyword];\n      return typeof rule == \"object\" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n  }, {\n    key: \"removeKeyword\",\n    value: function removeKeyword(keyword) {\n      // TODO return type should be Ajv\n      var RULES = this.RULES;\n      delete RULES.keywords[keyword];\n      delete RULES.all[keyword];\n      var _iterator3 = _createForOfIteratorHelper(RULES.rules),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var group = _step3.value;\n          var i = group.rules.findIndex(function (rule) {\n            return rule.keyword === keyword;\n          });\n          if (i >= 0) group.rules.splice(i, 1);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return this;\n    }\n    // Add format\n  }, {\n    key: \"addFormat\",\n    value: function addFormat(name, format) {\n      if (typeof format == \"string\") format = new RegExp(format);\n      this.formats[name] = format;\n      return this;\n    }\n  }, {\n    key: \"errorsText\",\n    value: function errorsText() {\n      var errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.errors;\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref2$separator = _ref2.separator,\n        separator = _ref2$separator === void 0 ? \", \" : _ref2$separator,\n        _ref2$dataVar = _ref2.dataVar,\n        dataVar = _ref2$dataVar === void 0 ? \"data\" : _ref2$dataVar;\n      if (!errors || errors.length === 0) return \"No errors\";\n      return errors.map(function (e) {\n        return \"\".concat(dataVar).concat(e.instancePath, \" \").concat(e.message);\n      }).reduce(function (text, msg) {\n        return text + separator + msg;\n      });\n    }\n  }, {\n    key: \"$dataMetaSchema\",\n    value: function $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n      var rules = this.RULES.all;\n      metaSchema = JSON.parse(JSON.stringify(metaSchema));\n      var _iterator4 = _createForOfIteratorHelper(keywordsJsonPointers),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var jsonPointer = _step4.value;\n          var segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n          var keywords = metaSchema;\n          var _iterator5 = _createForOfIteratorHelper(segments),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var seg = _step5.value;\n              keywords = keywords[seg];\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n          for (var key in rules) {\n            var rule = rules[key];\n            if (typeof rule != \"object\") continue;\n            var $data = rule.definition.$data;\n            var schema = keywords[key];\n            if ($data && schema) keywords[key] = schemaOrData(schema);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      return metaSchema;\n    }\n  }, {\n    key: \"_removeAllSchemas\",\n    value: function _removeAllSchemas(schemas, regex) {\n      for (var keyRef in schemas) {\n        var sch = schemas[keyRef];\n        if (!regex || regex.test(keyRef)) {\n          if (typeof sch == \"string\") {\n            delete schemas[keyRef];\n          } else if (sch && !sch.meta) {\n            this._cache.delete(sch.schema);\n            delete schemas[keyRef];\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_addSchema\",\n    value: function _addSchema(schema, meta, baseId) {\n      var validateSchema = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.opts.validateSchema;\n      var addSchema = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.opts.addUsedSchema;\n      var id;\n      var schemaId = this.opts.schemaId;\n      if (typeof schema == \"object\") {\n        id = schema[schemaId];\n      } else {\n        if (this.opts.jtd) throw new Error(\"schema must be object\");else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\");\n      }\n      var sch = this._cache.get(schema);\n      if (sch !== undefined) return sch;\n      baseId = (0, resolve_1.normalizeId)(id || baseId);\n      var localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n      sch = new compile_1.SchemaEnv({\n        schema: schema,\n        schemaId: schemaId,\n        meta: meta,\n        baseId: baseId,\n        localRefs: localRefs\n      });\n      this._cache.set(sch.schema, sch);\n      if (addSchema && !baseId.startsWith(\"#\")) {\n        // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n        if (baseId) this._checkUnique(baseId);\n        this.refs[baseId] = sch;\n      }\n      if (validateSchema) this.validateSchema(schema, true);\n      return sch;\n    }\n  }, {\n    key: \"_checkUnique\",\n    value: function _checkUnique(id) {\n      if (this.schemas[id] || this.refs[id]) {\n        throw new Error(\"schema with key or id \\\"\".concat(id, \"\\\" already exists\"));\n      }\n    }\n  }, {\n    key: \"_compileSchemaEnv\",\n    value: function _compileSchemaEnv(sch) {\n      if (sch.meta) this._compileMetaSchema(sch);else compile_1.compileSchema.call(this, sch);\n      /* istanbul ignore if */\n      if (!sch.validate) throw new Error(\"ajv implementation error\");\n      return sch.validate;\n    }\n  }, {\n    key: \"_compileMetaSchema\",\n    value: function _compileMetaSchema(sch) {\n      var currentOpts = this.opts;\n      this.opts = this._metaOpts;\n      try {\n        compile_1.compileSchema.call(this, sch);\n      } finally {\n        this.opts = currentOpts;\n      }\n    }\n  }]);\n  return Ajv;\n}();\nexports.default = Ajv;\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nfunction checkOptions(checkOpts, options, msg) {\n  var log = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"error\";\n  for (var key in checkOpts) {\n    var opt = key;\n    if (opt in options) this.logger[log](\"\".concat(msg, \": option \").concat(key, \". \").concat(checkOpts[opt]));\n  }\n}\nfunction getSchEnv(keyRef) {\n  keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n  var optsSchemas = this.opts.schemas;\n  if (!optsSchemas) return;\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);else for (var key in optsSchemas) {\n    this.addSchema(optsSchemas[key], key);\n  }\n}\nfunction addInitialFormats() {\n  for (var name in this.opts.formats) {\n    var format = this.opts.formats[name];\n    if (format) this.addFormat(name, format);\n  }\n}\nfunction addInitialKeywords(defs) {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs);\n    return;\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\");\n  for (var keyword in defs) {\n    var def = defs[keyword];\n    if (!def.keyword) def.keyword = keyword;\n    this.addKeyword(def);\n  }\n}\nfunction getMetaSchemaOptions() {\n  var metaOpts = _objectSpread({}, this.opts);\n  var _iterator6 = _createForOfIteratorHelper(META_IGNORE_OPTIONS),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var opt = _step6.value;\n      delete metaOpts[opt];\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  return metaOpts;\n}\nvar noLogs = {\n  log: function log() {},\n  warn: function warn() {},\n  error: function error() {}\n};\nfunction getLogger(logger) {\n  if (logger === false) return noLogs;\n  if (logger === undefined) return console;\n  if (logger.log && logger.warn && logger.error) return logger;\n  throw new Error(\"logger must implement log, warn and error methods\");\n}\nvar KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n  var RULES = this.RULES;\n  (0, util_1.eachItem)(keyword, function (kwd) {\n    if (RULES.keywords[kwd]) throw new Error(\"Keyword \".concat(kwd, \" is already defined\"));\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(\"Keyword \".concat(kwd, \" has invalid name\"));\n  });\n  if (!def) return;\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function');\n  }\n}\nfunction addRule(keyword, definition, dataType) {\n  var _this2 = this;\n  var _a;\n  var post = definition === null || definition === void 0 ? void 0 : definition.post;\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"');\n  var RULES = this.RULES;\n  var ruleGroup = post ? RULES.post : RULES.rules.find(function (_ref3) {\n    var t = _ref3.type;\n    return t === dataType;\n  });\n  if (!ruleGroup) {\n    ruleGroup = {\n      type: dataType,\n      rules: []\n    };\n    RULES.rules.push(ruleGroup);\n  }\n  RULES.keywords[keyword] = true;\n  if (!definition) return;\n  var rule = {\n    keyword: keyword,\n    definition: _objectSpread(_objectSpread({}, definition), {}, {\n      type: (0, dataType_1.getJSONTypes)(definition.type),\n      schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)\n    })\n  };\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);else ruleGroup.rules.push(rule);\n  RULES.all[keyword] = rule;\n  (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach(function (kwd) {\n    return _this2.addKeyword(kwd);\n  });\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n  var i = ruleGroup.rules.findIndex(function (_rule) {\n    return _rule.keyword === before;\n  });\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule);\n  } else {\n    ruleGroup.rules.push(rule);\n    this.logger.warn(\"rule \".concat(before, \" is not defined\"));\n  }\n}\nfunction keywordMetaschema(def) {\n  var metaSchema = def.metaSchema;\n  if (metaSchema === undefined) return;\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);\n  def.validateSchema = this.compile(metaSchema, true);\n}\nvar $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\"\n};\nfunction schemaOrData(schema) {\n  return {\n    anyOf: [schema, $dataRef]\n  };\n}","map":{"version":3,"sources":["../lib/core.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return codegen_1._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return codegen_1.str; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return codegen_1.stringify; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return codegen_1.nil; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return codegen_1.Name; } });\nObject.defineProperty(exports, \"CodeGen\", { enumerable: true, get: function () { return codegen_1.CodeGen; } });\nconst validation_error_1 = require(\"./runtime/validation_error\");\nconst ref_error_1 = require(\"./compile/ref_error\");\nconst rules_1 = require(\"./compile/rules\");\nconst compile_1 = require(\"./compile\");\nconst codegen_2 = require(\"./compile/codegen\");\nconst resolve_1 = require(\"./compile/resolve\");\nconst dataType_1 = require(\"./compile/validate/dataType\");\nconst util_1 = require(\"./compile/util\");\nconst $dataRefSchema = require(\"./refs/data.json\");\nconst uri_1 = require(\"./runtime/uri\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\n    \"validate\",\n    \"serialize\",\n    \"parse\",\n    \"wrapper\",\n    \"root\",\n    \"schema\",\n    \"keyword\",\n    \"pattern\",\n    \"formats\",\n    \"validate$data\",\n    \"func\",\n    \"obj\",\n    \"Error\",\n]);\nconst removedOptions = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\",\n};\nconst deprecatedOptions = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n    const s = o.strict;\n    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n    return {\n        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n        uriResolver: uriResolver,\n    };\n}\nclass Ajv {\n    constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = new Set();\n        this._loading = {};\n        this._cache = new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n        checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n            addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n            addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\")\n            this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n    }\n    _addVocabularies() {\n        this.addKeyword(\"$async\");\n    }\n    _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === \"id\") {\n            _dataRefSchema = { ...$dataRefSchema };\n            _dataRefSchema.id = _dataRefSchema.$id;\n            delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n    defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined);\n    }\n    validate(schemaKeyRef, // key, ref or schema object\n    data // to be validated\n    ) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n            v = this.getSchema(schemaKeyRef);\n            if (!v)\n                throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        }\n        else {\n            v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!(\"$async\" in v))\n            this.errors = v.errors;\n        return valid;\n    }\n    compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") {\n            throw new Error(\"options.loadSchema should be a function\");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n            await loadMetaSchema.call(this, _schema.$schema);\n            const sch = this._addSchema(_schema, _meta);\n            return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n            if ($ref && !this.getSchema($ref)) {\n                await runCompileAsync.call(this, { $ref }, true);\n            }\n        }\n        async function _compileAsync(sch) {\n            try {\n                return this._compileSchemaEnv(sch);\n            }\n            catch (e) {\n                if (!(e instanceof ref_error_1.default))\n                    throw e;\n                checkLoaded.call(this, e);\n                await loadMissingSchema.call(this, e.missingSchema);\n                return _compileAsync.call(this, sch);\n            }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n            if (this.refs[ref]) {\n                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n            }\n        }\n        async function loadMissingSchema(ref) {\n            const _schema = await _loadSchema.call(this, ref);\n            if (!this.refs[ref])\n                await loadMetaSchema.call(this, _schema.$schema);\n            if (!this.refs[ref])\n                this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n            const p = this._loading[ref];\n            if (p)\n                return p;\n            try {\n                return await (this._loading[ref] = loadSchema(ref));\n            }\n            finally {\n                delete this._loading[ref];\n            }\n        }\n    }\n    // Adds schema to the instance\n    addSchema(schema, // If array is passed, `key` will be ignored\n    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    ) {\n        if (Array.isArray(schema)) {\n            for (const sch of schema)\n                this.addSchema(sch, undefined, _meta, _validateSchema);\n            return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n            const { schemaId } = this.opts;\n            id = schema[schemaId];\n            if (id !== undefined && typeof id != \"string\") {\n                throw new Error(`schema ${schemaId} must be string`);\n            }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n    addMetaSchema(schema, key, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    ) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n    }\n    //  Validate schema against its meta-schema\n    validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\")\n            return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== undefined && typeof $schema != \"string\") {\n            throw new Error(\"$schema must be a string\");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n            this.logger.warn(\"meta-schema not available\");\n            this.errors = null;\n            return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n            const message = \"schema is invalid: \" + this.errorsText();\n            if (this.opts.validateSchema === \"log\")\n                this.logger.error(message);\n            else\n                throw new Error(message);\n        }\n        return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n    getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\")\n            keyRef = sch;\n        if (sch === undefined) {\n            const { schemaId } = this.opts;\n            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n            sch = compile_1.resolveSchema.call(this, root, keyRef);\n            if (!sch)\n                return;\n            this.refs[keyRef] = sch;\n        }\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n            this._removeAllSchemas(this.schemas, schemaKeyRef);\n            this._removeAllSchemas(this.refs, schemaKeyRef);\n            return this;\n        }\n        switch (typeof schemaKeyRef) {\n            case \"undefined\":\n                this._removeAllSchemas(this.schemas);\n                this._removeAllSchemas(this.refs);\n                this._cache.clear();\n                return this;\n            case \"string\": {\n                const sch = getSchEnv.call(this, schemaKeyRef);\n                if (typeof sch == \"object\")\n                    this._cache.delete(sch.schema);\n                delete this.schemas[schemaKeyRef];\n                delete this.refs[schemaKeyRef];\n                return this;\n            }\n            case \"object\": {\n                const cacheKey = schemaKeyRef;\n                this._cache.delete(cacheKey);\n                let id = schemaKeyRef[this.opts.schemaId];\n                if (id) {\n                    id = (0, resolve_1.normalizeId)(id);\n                    delete this.schemas[id];\n                    delete this.refs[id];\n                }\n                return this;\n            }\n            default:\n                throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n    }\n    // add \"vocabulary\" - a collection of keywords\n    addVocabulary(definitions) {\n        for (const def of definitions)\n            this.addKeyword(def);\n        return this;\n    }\n    addKeyword(kwdOrDef, def // deprecated\n    ) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n            keyword = kwdOrDef;\n            if (typeof def == \"object\") {\n                this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n                def.keyword = keyword;\n            }\n        }\n        else if (typeof kwdOrDef == \"object\" && def === undefined) {\n            def = kwdOrDef;\n            keyword = def.keyword;\n            if (Array.isArray(keyword) && !keyword.length) {\n                throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n            }\n        }\n        else {\n            throw new Error(\"invalid addKeywords parameters\");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n            return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n            ...def,\n            type: (0, dataType_1.getJSONTypes)(def.type),\n            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0\n            ? (k) => addRule.call(this, k, definition)\n            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n    }\n    getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n    removeKeyword(keyword) {\n        // TODO return type should be Ajv\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n            const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n            if (i >= 0)\n                group.rules.splice(i, 1);\n        }\n        return this;\n    }\n    // Add format\n    addFormat(name, format) {\n        if (typeof format == \"string\")\n            format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n    }\n    errorsText(errors = this.errors, // optional array of validation errors\n    { separator = \", \", dataVar = \"data\" } = {} // optional options with properties `separator` and `dataVar`\n    ) {\n        if (!errors || errors.length === 0)\n            return \"No errors\";\n        return errors\n            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n            .reduce((text, msg) => text + separator + msg);\n    }\n    $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n            const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n            let keywords = metaSchema;\n            for (const seg of segments)\n                keywords = keywords[seg];\n            for (const key in rules) {\n                const rule = rules[key];\n                if (typeof rule != \"object\")\n                    continue;\n                const { $data } = rule.definition;\n                const schema = keywords[key];\n                if ($data && schema)\n                    keywords[key] = schemaOrData(schema);\n            }\n        }\n        return metaSchema;\n    }\n    _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n            const sch = schemas[keyRef];\n            if (!regex || regex.test(keyRef)) {\n                if (typeof sch == \"string\") {\n                    delete schemas[keyRef];\n                }\n                else if (sch && !sch.meta) {\n                    this._cache.delete(sch.schema);\n                    delete schemas[keyRef];\n                }\n            }\n        }\n    }\n    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == \"object\") {\n            id = schema[schemaId];\n        }\n        else {\n            if (this.opts.jtd)\n                throw new Error(\"schema must be object\");\n            else if (typeof schema != \"boolean\")\n                throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== undefined)\n            return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n            if (baseId)\n                this._checkUnique(baseId);\n            this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n            this.validateSchema(schema, true);\n        return sch;\n    }\n    _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n            throw new Error(`schema with key or id \"${id}\" already exists`);\n        }\n    }\n    _compileSchemaEnv(sch) {\n        if (sch.meta)\n            this._compileMetaSchema(sch);\n        else\n            compile_1.compileSchema.call(this, sch);\n        /* istanbul ignore if */\n        if (!sch.validate)\n            throw new Error(\"ajv implementation error\");\n        return sch.validate;\n    }\n    _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n            compile_1.compileSchema.call(this, sch);\n        }\n        finally {\n            this.opts = currentOpts;\n        }\n    }\n}\nexports.default = Ajv;\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n    for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n    }\n}\nfunction getSchEnv(keyRef) {\n    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n    return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n    const optsSchemas = this.opts.schemas;\n    if (!optsSchemas)\n        return;\n    if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n    else\n        for (const key in optsSchemas)\n            this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n    for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n            this.addFormat(name, format);\n    }\n}\nfunction addInitialKeywords(defs) {\n    if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n    }\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n            def.keyword = keyword;\n        this.addKeyword(def);\n    }\n}\nfunction getMetaSchemaOptions() {\n    const metaOpts = { ...this.opts };\n    for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n    return metaOpts;\n}\nconst noLogs = { log() { }, warn() { }, error() { } };\nfunction getLogger(logger) {\n    if (logger === false)\n        return noLogs;\n    if (logger === undefined)\n        return console;\n    if (logger.log && logger.warn && logger.error)\n        return logger;\n    throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n    const { RULES } = this;\n    (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n            throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n            throw new Error(`Keyword ${kwd} has invalid name`);\n    });\n    if (!def)\n        return;\n    if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n        throw new Error('$data keyword must have \"code\" or \"validate\" function');\n    }\n}\nfunction addRule(keyword, definition, dataType) {\n    var _a;\n    const post = definition === null || definition === void 0 ? void 0 : definition.post;\n    if (dataType && post)\n        throw new Error('keyword with \"post\" flag cannot have \"type\"');\n    const { RULES } = this;\n    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n    if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n    }\n    RULES.keywords[keyword] = true;\n    if (!definition)\n        return;\n    const rule = {\n        keyword,\n        definition: {\n            ...definition,\n            type: (0, dataType_1.getJSONTypes)(definition.type),\n            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),\n        },\n    };\n    if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n    else\n        ruleGroup.rules.push(rule);\n    RULES.all[keyword] = rule;\n    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n    if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n    }\n    else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n    }\n}\nfunction keywordMetaschema(def) {\n    let { metaSchema } = def;\n    if (metaSchema === undefined)\n        return;\n    if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n    def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n    $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n};\nfunction schemaOrData(schema) {\n    return { anyOf: [schema, $dataRef] };\n}\n//# sourceMappingURL=core.js.map"]},"metadata":{},"sourceType":"script"}