{"ast":null,"code":"import _objectSpread from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _ from \"lodash\";\nimport { listAllResults } from \"../Query\";\nimport { createPagedResult, createSkipPaging, isAllPaging, isPageNumberPaging, takePlusOne } from \"../pagination\";\nimport { typeGuard } from \"../utils\";\nimport { normalizeSubgraphFilter } from \"./normalizeSubgraphFilter\";\n/**\n * A base class to handle common Subgraph query logic.\n */\nexport var SubgraphQueryHandler = /*#__PURE__*/function () {\n  function SubgraphQueryHandler() {\n    _classCallCheck(this, SubgraphQueryHandler);\n    /**\n     * For every primary address field key there are more fields generated which it should look for addresses.\n     * NOTE: The implementation is a bit \"magical\" but it rids of a bunch of boilerplate and creates a single point for editing.\n     */\n    this.getRelevantAddressesFromFilterByAddressFieldKeys = function (filter, addressFieldKeys) {\n      return addressFieldKeys.map(function (key) {\n        return [filter[key], filter[\"\".concat(key, \"_in\")], filter[\"\".concat(key, \"_not\")], filter[\"\".concat(key, \"_not_in\")]].filter(function (x) {\n          return typeof x !== \"undefined\";\n        }).flat().filter(function (x) {\n          return !!x;\n        });\n      }).flat();\n    };\n  }\n  _createClass(SubgraphQueryHandler, [{\n    key: \"getRelevantAddressesFromFilter\",\n    value: function getRelevantAddressesFromFilter(filter) {\n      if (!filter) {\n        return {\n          tokens: [],\n          accounts: []\n        };\n      }\n      var addressFieldKeys = this.getAddressFieldKeysFromFilter();\n      var tokenAddresses = this.getRelevantAddressesFromFilterByAddressFieldKeys(filter, addressFieldKeys.tokenKeys);\n      var accountAddresses = this.getRelevantAddressesFromFilterByAddressFieldKeys(filter, addressFieldKeys.accountKeys);\n      return {\n        tokens: _.uniq(tokenAddresses),\n        accounts: _.uniq(accountAddresses)\n      };\n    }\n  }, {\n    key: \"getRelevantAddressesFromResult\",\n    value: function getRelevantAddressesFromResult(result) {\n      if (!result) {\n        return {\n          tokens: [],\n          accounts: []\n        };\n      }\n      var intermediate = this.getRelevantAddressesFromResultCore(result);\n      return {\n        tokens: _.uniq(intermediate.tokens.flat().filter(function (x) {\n          return !!x;\n        })),\n        accounts: _.uniq(intermediate.accounts.flat().filter(function (x) {\n          return !!x;\n        }))\n      };\n    }\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(subgraphClient, query) {\n        var _a, response;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (query.id) {\n                  _context.next = 2;\n                  break;\n                }\n                return _context.abrupt(\"return\", null);\n              case 2:\n                _context.next = 4;\n                return this.querySubgraph(subgraphClient, {\n                  where: {\n                    id: query.id.toLowerCase()\n                  },\n                  skip: 0,\n                  take: 1,\n                  block: query.block\n                });\n              case 4:\n                response = _context.sent;\n                return _context.abrupt(\"return\", (_a = this.mapFromSubgraphResponse(response)[0]) !== null && _a !== void 0 ? _a : null);\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function get(_x, _x2) {\n        return _get.apply(this, arguments);\n      }\n      return get;\n    }()\n  }, {\n    key: \"list\",\n    value: function () {\n      var _list = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(subgraphClient, query) {\n        var _this = this;\n        var _a, queryFunction;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // Note: Could possibly optimize here to not create a new internal function every time.\n                queryFunction = /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(paging) {\n                    var _a, _b, _c, subgraphFilter, subgraphQueryVariables, subgraphResponse, mappedResult;\n                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            subgraphFilter = typeGuard(normalizeSubgraphFilter(_objectSpread(_objectSpread({}, (_a = query.filter) !== null && _a !== void 0 ? _a : {}), {}, {\n                              id_gt: paging.lastId\n                            })));\n                            subgraphQueryVariables = typeGuard({\n                              where: normalizeSubgraphFilter(subgraphFilter),\n                              orderBy: (_b = query.order) === null || _b === void 0 ? void 0 : _b.orderBy,\n                              orderDirection: (_c = query.order) === null || _c === void 0 ? void 0 : _c.orderDirection,\n                              first: takePlusOne(paging),\n                              skip: isPageNumberPaging(paging) ? (paging.pageNumber - 1) * paging.take : paging.skip,\n                              block: query.block\n                            });\n                            _context2.next = 4;\n                            return _this.querySubgraph(subgraphClient, subgraphQueryVariables);\n                          case 4:\n                            subgraphResponse = _context2.sent;\n                            mappedResult = _this.mapFromSubgraphResponse(subgraphResponse);\n                            return _context2.abrupt(\"return\", createPagedResult(mappedResult, paging));\n                          case 7:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2);\n                  }));\n                  return function queryFunction(_x5) {\n                    return _ref.apply(this, arguments);\n                  };\n                }();\n                if (!isAllPaging(query.pagination)) {\n                  _context3.next = 10;\n                  break;\n                }\n                _context3.t0 = createPagedResult;\n                _context3.next = 5;\n                return listAllResults(queryFunction);\n              case 5:\n                _context3.t1 = _context3.sent;\n                _context3.t2 = query.pagination;\n                return _context3.abrupt(\"return\", (0, _context3.t0)(_context3.t1, _context3.t2));\n              case 10:\n                return _context3.abrupt(\"return\", queryFunction((_a = query.pagination) !== null && _a !== void 0 ? _a : createSkipPaging()));\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      function list(_x3, _x4) {\n        return _list.apply(this, arguments);\n      }\n      return list;\n    }()\n  }, {\n    key: \"querySubgraph\",\n    value: function () {\n      var _querySubgraph = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(subgraphClient, variables) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return subgraphClient.request(this.requestDocument, variables);\n              case 2:\n                return _context4.abrupt(\"return\", _context4.sent);\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function querySubgraph(_x6, _x7) {\n        return _querySubgraph.apply(this, arguments);\n      }\n      return querySubgraph;\n    }()\n  }]);\n  return SubgraphQueryHandler;\n}();","map":{"version":3,"sources":["../../../src/subgraph/subgraphQueryHandler.ts"],"names":[],"mappings":";;;;;AACA,OAAO,CAAC,MAAM,QAAQ;AAEtB,SAAS,cAAc,QAAQ,UAAU;AAGzC,SACI,iBAAiB,EACjB,gBAAgB,EAChB,WAAW,EACX,kBAAkB,EAGlB,WAAW,QACR,eAAe;AACtB,SAAS,SAAS,QAAQ,UAAU;AAIpC,SAAS,uBAAuB,QAAQ,2BAA2B;AAyFnE;;AAEG;AACH,WAAsB,oBAAoB;EAA1C,gCAAA;IAAA;IAwDI;;;AAGG;IACK,IAAA,CAAA,gDAAgD,GAAG,UACvD,MAAe,EACf,gBAAmC;MAAA,OAEnC,gBAAgB,CACX,GAAG,CACA,UAAC,GAAG;QAAA,OACA,CACI,MAAM,CAAC,GAAG,CAAC,EACX,MAAM,WAAI,GAAG,SAAuB,EACpC,MAAM,WAAI,GAAG,UAAwB,EACrC,MAAM,WAAI,GAAG,aAA2B,CAC3C,CACI,MAAM,CAAC,UAAC,CAAC;UAAA,OAAK,OAAO,CAAC,KAAK,WAAW;QAAA,EAAC,CACvC,IAAI,EAAE,CACN,MAAM,CAAC,UAAC,CAAC;UAAA,OAAK,CAAC,CAAC,CAAC;QAAA,EAAc;MAAA,EAC3C,CACA,IAAI,EAAE;IAAA;EAsGnB;EAAC;IAAA;IAAA,OAvJG,wCAA+B,MAAgB,EAAA;MAC3C,IAAI,CAAC,MAAM,EAAE;QACT,OAAO;UACH,MAAM,EAAE,EAAE;UACV,QAAQ,EAAE;SACb;MACJ;MAED,IAAM,gBAAgB,GAAG,IAAI,CAAC,6BAA6B,EAAE;MAE7D,IAAM,cAAc,GAChB,IAAI,CAAC,gDAAgD,CACjD,MAAM,EACN,gBAAgB,CAAC,SAAS,CAC7B;MAEL,IAAM,gBAAgB,GAClB,IAAI,CAAC,gDAAgD,CACjD,MAAM,EACN,gBAAgB,CAAC,WAAW,CAC/B;MAEL,OAAO;QACH,MAAM,EAAE,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC;QAC9B,QAAQ,EAAE,CAAC,CAAC,IAAI,CAAC,gBAAgB;OACpC;IACL;EAAC;IAAA;IAAA,OA6BD,wCAA+B,MAAuB,EAAA;MAClD,IAAI,CAAC,MAAM,EAAE;QACT,OAAO;UACH,MAAM,EAAE,EAAE;UACV,QAAQ,EAAE;SACb;MACJ;MAED,IAAM,YAAY,GAAG,IAAI,CAAC,kCAAkC,CAAC,MAAM,CAAC;MACpE,OAAO;QACH,MAAM,EAAE,CAAC,CAAC,IAAI,CACV,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,MAAM,CAAC,UAAC,CAAC;UAAA,OAAmB,CAAC,CAAC,CAAC;QAAA,EAAC,CAC9D;QACD,QAAQ,EAAE,CAAC,CAAC,IAAI,CACZ,YAAY,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,MAAM,CAAC,UAAC,CAAC;UAAA,OAAmB,CAAC,CAAC,CAAC;QAAA,EAAC;OAEpE;IACL;EAAC;IAAA;IAAA;MAAA,sEAID,iBACI,cAA8B,EAC9B,KAAuB;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,IAElB,KAAK,CAAC,EAAE;kBAAA;kBAAA;gBAAA;gBAAA,iCACF,IAAI;cAAA;gBAAA;gBAAA,OAGQ,IAAI,CAAC,aAAa,CAAC,cAAc,EAAE;kBACtD,KAAK,EAAE;oBACH,EAAE,EAAE,KAAK,CAAC,EAAE,CAAC,WAAW;mBAC3B;kBACD,IAAI,EAAE,CAAC;kBACP,IAAI,EAAE,CAAC;kBACP,KAAK,EAAE,KAAK,CAAC;iBACsB,CAAC;cAAA;gBAPlC,QAAQ;gBAAA,iCASP,CAAA,EAAA,GAAA,IAAI,CAAC,uBAAuB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,IAAI;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAC3D;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA,uEAED,kBACI,cAA8B,EAC9B,KAA2C;QAAA;QAAA;QAAA;UAAA;YAAA;cAAA;gBAE3C;gBACM,aAAa;kBAAA,sEAAG,kBAAO,MAAc;oBAAA;oBAAA;sBAAA;wBAAA;0BAAA;4BACjC,cAAc,GAAG,SAAS,CAC5B,uBAAuB,iCACf,CAAA,EAAA,GAAA,KAAK,CAAC,MAAM,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAK,CAAA,CAAc;8BACnC,KAAK,EAAE,MAAM,CAAC;4BAAM,GACtB,CACL;4BAEK,sBAAsB,GAAG,SAAS,CAA0B;8BAC9D,KAAK,EAAE,uBAAuB,CAAC,cAAc,CAAC;8BAC9C,OAAO,EAAE,CAAA,EAAA,GAAA,KAAK,CAAC,KAAK,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,OAAO;8BAC7B,cAAc,EAAE,CAAA,EAAA,GAAA,KAAK,CAAC,KAAK,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,cAAc;8BAC3C,KAAK,EAAE,WAAW,CAAC,MAAM,CAAC;8BAC1B,IAAI,EAAE,kBAAkB,CAAC,MAAM,CAAC,GAC1B,CAAC,MAAM,CAAC,UAAU,GAAG,CAAC,IAAI,MAAM,CAAC,IAAI,GACrC,MAAM,CAAC,IAAI;8BACjB,KAAK,EAAE,KAAK,CAAC;6BACsB,CAAC;4BAAA;4BAAA,OAET,KAAI,CAAC,aAAa,CAC7C,cAAc,EACd,sBAAsB,CACzB;0BAAA;4BAHK,gBAAgB;4BAKhB,YAAY,GAAG,KAAI,CAAC,uBAAuB,CAAC,gBAAgB,CAAC;4BAAA,kCAE5D,iBAAiB,CAAU,YAAY,EAAE,MAAM,CAAC;0BAAA;0BAAA;4BAAA;wBAAA;sBAAA;oBAAA;kBAAA,CAC1D;kBAAA,gBA3BK,aAAa;oBAAA;kBAAA;gBAAA;gBAAA,KA6Bf,WAAW,CAAC,KAAK,CAAC,UAAU,CAAC;kBAAA;kBAAA;gBAAA;gBAAA,eACtB,iBAAiB;gBAAA;gBAAA,OACd,cAAc,CAAC,aAAa,CAAC;cAAA;gBAAA;gBAAA,eACnC,KAAK,CAAC,UAAU;gBAAA;cAAA;gBAAA,kCAGb,aAAa,CAAC,CAAA,EAAA,GAAA,KAAK,CAAC,UAAU,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAI,gBAAgB,EAAE,CAAC;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAEnE;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;IAAA;IAAA;MAAA,gFAES,kBACN,cAA8B,EAC9B,SAAkC;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OAErB,cAAc,CAAC,OAAO,CAAC,IAAI,CAAC,eAAe,EAAE,SAAS,CAAC;cAAA;gBAAA;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CACvE;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA","sourceRoot":"","sourcesContent":["import _ from \"lodash\";\nimport { listAllResults } from \"../Query\";\nimport { createPagedResult, createSkipPaging, isAllPaging, isPageNumberPaging, takePlusOne, } from \"../pagination\";\nimport { typeGuard } from \"../utils\";\nimport { normalizeSubgraphFilter } from \"./normalizeSubgraphFilter\";\n/**\n * A base class to handle common Subgraph query logic.\n */\nexport class SubgraphQueryHandler {\n    constructor() {\n        /**\n         * For every primary address field key there are more fields generated which it should look for addresses.\n         * NOTE: The implementation is a bit \"magical\" but it rids of a bunch of boilerplate and creates a single point for editing.\n         */\n        this.getRelevantAddressesFromFilterByAddressFieldKeys = (filter, addressFieldKeys) => addressFieldKeys\n            .map((key) => [\n            filter[key],\n            filter[`${key}_in`],\n            filter[`${key}_not`],\n            filter[`${key}_not_in`],\n        ]\n            .filter((x) => typeof x !== \"undefined\")\n            .flat()\n            .filter((x) => !!x))\n            .flat();\n    }\n    getRelevantAddressesFromFilter(filter) {\n        if (!filter) {\n            return {\n                tokens: [],\n                accounts: [],\n            };\n        }\n        const addressFieldKeys = this.getAddressFieldKeysFromFilter();\n        const tokenAddresses = this.getRelevantAddressesFromFilterByAddressFieldKeys(filter, addressFieldKeys.tokenKeys);\n        const accountAddresses = this.getRelevantAddressesFromFilterByAddressFieldKeys(filter, addressFieldKeys.accountKeys);\n        return {\n            tokens: _.uniq(tokenAddresses),\n            accounts: _.uniq(accountAddresses),\n        };\n    }\n    getRelevantAddressesFromResult(result) {\n        if (!result) {\n            return {\n                tokens: [],\n                accounts: [],\n            };\n        }\n        const intermediate = this.getRelevantAddressesFromResultCore(result);\n        return {\n            tokens: _.uniq(intermediate.tokens.flat().filter((x) => !!x)),\n            accounts: _.uniq(intermediate.accounts.flat().filter((x) => !!x)),\n        };\n    }\n    async get(subgraphClient, query) {\n        var _a;\n        if (!query.id) {\n            return null;\n        }\n        const response = await this.querySubgraph(subgraphClient, {\n            where: {\n                id: query.id.toLowerCase(),\n            },\n            skip: 0,\n            take: 1,\n            block: query.block,\n        });\n        return (_a = this.mapFromSubgraphResponse(response)[0]) !== null && _a !== void 0 ? _a : null;\n    }\n    async list(subgraphClient, query) {\n        var _a;\n        // Note: Could possibly optimize here to not create a new internal function every time.\n        const queryFunction = async (paging) => {\n            var _a, _b, _c;\n            const subgraphFilter = typeGuard(normalizeSubgraphFilter({\n                ...((_a = query.filter) !== null && _a !== void 0 ? _a : {}),\n                id_gt: paging.lastId,\n            }));\n            const subgraphQueryVariables = typeGuard({\n                where: normalizeSubgraphFilter(subgraphFilter),\n                orderBy: (_b = query.order) === null || _b === void 0 ? void 0 : _b.orderBy,\n                orderDirection: (_c = query.order) === null || _c === void 0 ? void 0 : _c.orderDirection,\n                first: takePlusOne(paging),\n                skip: isPageNumberPaging(paging)\n                    ? (paging.pageNumber - 1) * paging.take\n                    : paging.skip,\n                block: query.block,\n            });\n            const subgraphResponse = await this.querySubgraph(subgraphClient, subgraphQueryVariables);\n            const mappedResult = this.mapFromSubgraphResponse(subgraphResponse);\n            return createPagedResult(mappedResult, paging);\n        };\n        if (isAllPaging(query.pagination)) {\n            return createPagedResult(await listAllResults(queryFunction), query.pagination);\n        }\n        else {\n            return queryFunction((_a = query.pagination) !== null && _a !== void 0 ? _a : createSkipPaging());\n        }\n    }\n    async querySubgraph(subgraphClient, variables) {\n        return await subgraphClient.request(this.requestDocument, variables);\n    }\n}\n//# sourceMappingURL=subgraphQueryHandler.js.map"]},"metadata":{},"sourceType":"module"}