{"ast":null,"code":"import { ethers } from \"ethers\";\nimport { SFError } from \"./SFError\";\nimport { AUTHORIZE_FLOW_OPERATOR_CREATE, AUTHORIZE_FLOW_OPERATOR_DELETE, AUTHORIZE_FLOW_OPERATOR_UPDATE, BASE_18, DAY_IN_SECONDS, MONTH_IN_SECONDS, WEEK_IN_SECONDS, YEAR_IN_SECONDS } from \"./constants\";\nvar EMPTY = \"0x\";\n/**\n * Checks if address is a valid ethereum address and normalizes so it can be used by both subgraph and web3.\n * @param address\n * @returns The normalized address.\n */\nexport var normalizeAddress = function normalizeAddress(address) {\n  if (!address) return \"\";\n  if (ethers.utils.isAddress(address) === false) {\n    throw new SFError({\n      type: \"INVALID_ADDRESS\",\n      customMessage: \"The address you have entered is not a valid ethereum address\"\n    });\n  }\n  return address.toLowerCase();\n};\nexport var isPermissionsClean = function isPermissionsClean(permissions) {\n  return (permissions & ~(AUTHORIZE_FLOW_OPERATOR_CREATE | AUTHORIZE_FLOW_OPERATOR_UPDATE | AUTHORIZE_FLOW_OPERATOR_DELETE)) === 0;\n};\nexport var isNullOrEmpty = function isNullOrEmpty(str) {\n  return str == null || str === \"\";\n};\n/**\n * Removes the 8-character signature hash from `callData`.\n * @param callData\n * @returns function parameters\n */\nexport var removeSigHashFromCallData = function removeSigHashFromCallData(callData) {\n  return EMPTY.concat(callData.slice(10));\n};\n/**\n * A wrapper function for getting the ethers TransactionDescription object given fragments (e.g. ABI), callData and the value amount sent.\n * @param fragments ABI\n * @param data callData of a function\n * @param value amount of ether sent\n * @returns ethers.TransactionDescription object\n */\nexport var getTransactionDescription = function getTransactionDescription(fragments, data, value) {\n  var iface = new ethers.utils.Interface(fragments);\n  var txnDescription = iface.parseTransaction({\n    data: data,\n    value: value\n  });\n  return txnDescription;\n};\n/**\n * Gets the per second flow rate given an `amountPerYear` value.\n * @param amountPerYear the amount you want to stream per year\n * @returns flow rate per second\n */\nexport var getPerSecondFlowRateByYear = function getPerSecondFlowRateByYear(amountPerYear) {\n  return Math.round(Number(amountPerYear) / YEAR_IN_SECONDS * BASE_18).toString();\n};\n/**\n * Gets the per second flow rate given an `amountPerMonth` value.\n * @param amountPerMonth the amount you want to stream per month\n * @returns flow rate per second\n */\nexport var getPerSecondFlowRateByMonth = function getPerSecondFlowRateByMonth(amountPerMonth) {\n  return Math.round(Number(amountPerMonth) / MONTH_IN_SECONDS * BASE_18).toString();\n};\n/**\n * Gets the per second flow rate given an `amountPerWeek` value.\n * @param amountPerWeek the amount you want to stream per Week\n * @returns flow rate per second\n */\nexport var getPerSecondFlowRateByWeek = function getPerSecondFlowRateByWeek(amountPerWeek) {\n  return Math.round(Number(amountPerWeek) / WEEK_IN_SECONDS * BASE_18).toString();\n};\n/**\n * Gets the per second flow rate given an `amountPerDay` value.\n * @param amountPerDay the amount you want to stream per day\n * @returns flow rate per second\n */\nexport var getPerSecondFlowRateByDay = function getPerSecondFlowRateByDay(amountPerDay) {\n  return Math.round(Number(amountPerDay) / DAY_IN_SECONDS * BASE_18).toString();\n};\n/**\n * Gets daily, weekly, monthly and yearly flowed amounts given a per second flow rate.\n * @param perSecondFlowRate\n * @returns\n */\nexport var getFlowAmountByPerSecondFlowRate = function getFlowAmountByPerSecondFlowRate(perSecondFlowRate) {\n  var decimalFlowRate = Number(perSecondFlowRate) / BASE_18;\n  return {\n    daily: Math.round(decimalFlowRate * DAY_IN_SECONDS).toString(),\n    weekly: Math.round(decimalFlowRate * WEEK_IN_SECONDS).toString(),\n    monthly: Math.round(decimalFlowRate * MONTH_IN_SECONDS).toString(),\n    yearly: Math.round(decimalFlowRate * YEAR_IN_SECONDS).toString()\n  };\n};\n/**\n * The formula for calculating the flowed amount since updated using Subgraph data.\n * @param netFlowRate the net flow rate of the user\n * @param currentTimestamp the current timestamp\n * @param updatedAtTimestamp the updated at timestamp of the `AccountTokenSnapshot` entity\n * @returns the flowed amount since the updatedAt timestamp\n */\nexport var flowedAmountSinceUpdatedAt = function flowedAmountSinceUpdatedAt(_ref) {\n  var netFlowRate = _ref.netFlowRate,\n    currentTimestamp = _ref.currentTimestamp,\n    updatedAtTimestamp = _ref.updatedAtTimestamp;\n  return (Number(currentTimestamp) - Number(updatedAtTimestamp)) * Number(netFlowRate);\n};\n/**\n * The formula for calculating the total amount distributed to the subscriber (pending or received).\n * @param indexSubscriptions the index subscriptions of a single token from an account.\n * @returns the total amount received since updated at (both pending and actually distributed)\n */\nexport var subscriptionTotalAmountDistributedSinceUpdated = function subscriptionTotalAmountDistributedSinceUpdated(indexSubscriptions) {\n  return indexSubscriptions.reduce(function (x, y) {\n    return x + (Number(y.index.indexValue) - Number(y.indexValueUntilUpdatedAt)) * Number(y.units);\n  }, 0);\n};\n/**\n * The formula for calculating the total amount received (approved subscriptions).\n * @param indexSubscriptions the index subscriptions of a single token from an account.\n * @returns the total amount received since updated at (actually distributed into wallet)\n */\nexport var subscriptionTotalAmountReceivedSinceUpdated = function subscriptionTotalAmountReceivedSinceUpdated(indexSubscriptions) {\n  return indexSubscriptions.filter(function (x) {\n    return x.approved;\n  }).reduce(function (x, y) {\n    return x + (Number(y.index.indexValue) - Number(y.indexValueUntilUpdatedAt)) * Number(y.units);\n  }, 0);\n};\n/**\n * The formula for calculating the total amount that is claimable.\n * @param indexSubscriptions the index subscriptions of a single token from an account.\n * @returns the total amount that can be claimed since updated at\n */\nexport var subscriptionTotalAmountClaimableSinceUpdatedAt = function subscriptionTotalAmountClaimableSinceUpdatedAt(indexSubscriptions) {\n  return subscriptionTotalAmountDistributedSinceUpdated(indexSubscriptions) - subscriptionTotalAmountReceivedSinceUpdated(indexSubscriptions);\n};\nexport var getStringCurrentTimeInSeconds = function getStringCurrentTimeInSeconds() {\n  return Math.floor(new Date().getTime() / 1000);\n};\nexport var getSanitizedTimestamp = function getSanitizedTimestamp(timestamp) {\n  return new Date(Number(timestamp.toString()) * 1000);\n};\n/**\n * The formula for calculating the balance until updated at of a user (claimable + received tokens from index)\n * @param currentBalance the current balance until updated at from the `AccountTokenSnapshot` entity\n * @param netFlowRate the net flow rate of the user\n * @param currentTimestamp the current timestamp\n * @param updatedAtTimestamp the updated at timestamp of the `AccountTokenSnapshot` entity\n * @returns the balance since the updated at timestamp\n */\nexport var getBalance = function getBalance(_ref2) {\n  var currentBalance = _ref2.currentBalance,\n    netFlowRate = _ref2.netFlowRate,\n    currentTimestamp = _ref2.currentTimestamp,\n    updatedAtTimestamp = _ref2.updatedAtTimestamp,\n    indexSubscriptions = _ref2.indexSubscriptions;\n  return Number(currentBalance) + flowedAmountSinceUpdatedAt({\n    netFlowRate: netFlowRate,\n    currentTimestamp: currentTimestamp,\n    updatedAtTimestamp: updatedAtTimestamp\n  }) + subscriptionTotalAmountReceivedSinceUpdated(indexSubscriptions);\n};\n// NOTE: This is the only places we are allowed to use explicit any in the\n// sdk-core otherwise this doesn't work properly.\nexport var isEthersProvider = function isEthersProvider(provider) {\n  return !!provider.getNetwork;\n};\nexport var isInjectedWeb3 = function isInjectedWeb3(provider) {\n  return !!provider.currentProvider;\n};\nexport var isInjectedEthers = function isInjectedEthers(provider) {\n  return !!provider.provider;\n};\n/**\n * Why? Because `return obj as T` and `return <T>obj` are not safe type casts.\n */\nexport var typeGuard = function typeGuard(obj) {\n  return obj;\n};\nexport var getFlowOperatorId = function getFlowOperatorId(sender, flowOperator) {\n  var encoder = ethers.utils.defaultAbiCoder;\n  var encodedData = encoder.encode([\"string\", \"address\", \"address\"], [\"flowOperator\", sender, flowOperator]);\n  return ethers.utils.keccak256(encodedData);\n};","map":{"version":3,"sources":["../../src/utils.ts"],"names":[],"mappings":"AAEA,SAAS,MAAM,QAAQ,QAAQ;AAG/B,SAAS,OAAO,QAAQ,WAAW;AACnC,SACI,8BAA8B,EAC9B,8BAA8B,EAC9B,8BAA8B,EAC9B,OAAO,EACP,cAAc,EACd,gBAAgB,EAChB,eAAe,EACf,eAAe,QACZ,aAAa;AAGpB,IAAM,KAAK,GAAG,IAAI;AAElB;;;;AAIG;AACH,OAAO,IAAM,gBAAgB,GAAG,SAAnB,gBAAgB,CAAI,OAAgB,EAAY;EACzD,IAAI,CAAC,OAAO,EAAE,OAAO,EAAE;EACvB,IAAI,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,KAAK,KAAK,EAAE;IAC3C,MAAM,IAAI,OAAO,CAAC;MACd,IAAI,EAAE,iBAAiB;MACvB,aAAa,EACT;KACP,CAAC;EACL;EAED,OAAO,OAAO,CAAC,WAAW,EAAE;AAChC,CAAC;AAED,OAAO,IAAM,kBAAkB,GAAG,SAArB,kBAAkB,CAAI,WAAmB,EAAa;EAC/D,OACI,CAAC,WAAW,GACR,EACI,8BAA8B,GAC9B,8BAA8B,GAC9B,8BAA8B,CACjC,MACL,CAAC;AAET,CAAC;AAED,OAAO,IAAM,aAAa,GAAG,SAAhB,aAAa,CAAI,GAA8B,EAAI;EAC5D,OAAO,GAAG,IAAI,IAAI,IAAI,GAAG,KAAK,EAAE;AACpC,CAAC;AAED;;;;AAIG;AACH,OAAO,IAAM,yBAAyB,GAAG,SAA5B,yBAAyB,CAAI,QAAgB;EAAA,OACtD,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;AAAA;AAEpC;;;;;;AAMG;AACH,OAAO,IAAM,yBAAyB,GAAG,SAA5B,yBAAyB,CAClC,SAEgE,EAChE,IAAY,EACZ,KAAc,EACd;EACA,IAAM,KAAK,GAAG,IAAI,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,SAAS,CAAC;EACnD,IAAM,cAAc,GAAG,KAAK,CAAC,gBAAgB,CAAC;IAAE,IAAI,EAAJ,IAAI;IAAE,KAAK,EAAL;EAAK,CAAE,CAAC;EAC9D,OAAO,cAAc;AACzB,CAAC;AAED;;;;AAIG;AACH,OAAO,IAAM,0BAA0B,GAAG,SAA7B,0BAA0B,CAAI,aAAqB,EAAI;EAChE,OAAO,IAAI,CAAC,KAAK,CACZ,MAAM,CAAC,aAAa,CAAC,GAAG,eAAe,GAAI,OAAO,CACtD,CAAC,QAAQ,EAAE;AAChB,CAAC;AAED;;;;AAIG;AACH,OAAO,IAAM,2BAA2B,GAAG,SAA9B,2BAA2B,CAAI,cAAsB,EAAI;EAClE,OAAO,IAAI,CAAC,KAAK,CACZ,MAAM,CAAC,cAAc,CAAC,GAAG,gBAAgB,GAAI,OAAO,CACxD,CAAC,QAAQ,EAAE;AAChB,CAAC;AAED;;;;AAIG;AACH,OAAO,IAAM,0BAA0B,GAAG,SAA7B,0BAA0B,CAAI,aAAqB,EAAI;EAChE,OAAO,IAAI,CAAC,KAAK,CACZ,MAAM,CAAC,aAAa,CAAC,GAAG,eAAe,GAAI,OAAO,CACtD,CAAC,QAAQ,EAAE;AAChB,CAAC;AAED;;;;AAIG;AACH,OAAO,IAAM,yBAAyB,GAAG,SAA5B,yBAAyB,CAAI,YAAoB,EAAI;EAC9D,OAAO,IAAI,CAAC,KAAK,CACZ,MAAM,CAAC,YAAY,CAAC,GAAG,cAAc,GAAI,OAAO,CACpD,CAAC,QAAQ,EAAE;AAChB,CAAC;AAED;;;;AAIG;AACH,OAAO,IAAM,gCAAgC,GAAG,SAAnC,gCAAgC,CAAI,iBAAyB,EAAI;EAC1E,IAAM,eAAe,GAAG,MAAM,CAAC,iBAAiB,CAAC,GAAG,OAAO;EAC3D,OAAO;IACH,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,eAAe,GAAG,cAAc,CAAC,CAAC,QAAQ,EAAE;IAC9D,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,eAAe,GAAG,eAAe,CAAC,CAAC,QAAQ,EAAE;IAChE,OAAO,EAAE,IAAI,CAAC,KAAK,CAAC,eAAe,GAAG,gBAAgB,CAAC,CAAC,QAAQ,EAAE;IAClE,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,eAAe,GAAG,eAAe,CAAC,CAAC,QAAQ;GACjE;AACL,CAAC;AAED;;;;;;AAMG;AACH,OAAO,IAAM,0BAA0B,GAAG,SAA7B,0BAA0B,OAQlC;EAAA,IAPD,WAAW,QAAX,WAAW;IACX,gBAAgB,QAAhB,gBAAgB;IAChB,kBAAkB,QAAlB,kBAAkB;EAMlB,OACI,CAAC,MAAM,CAAC,gBAAgB,CAAC,GAAG,MAAM,CAAC,kBAAkB,CAAC,IACtD,MAAM,CAAC,WAAW,CAAC;AAE3B,CAAC;AAED;;;;AAIG;AACH,OAAO,IAAM,8CAA8C,GAAG,SAAjD,8CAA8C,CACvD,kBAAwC,EACxC;EACA,OAAO,kBAAkB,CAAC,MAAM,CAC5B,UAAC,CAAC,EAAE,CAAC;IAAA,OACD,CAAC,GACD,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,wBAAwB,CAAC,IAC5D,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC;EAAA,GACvB,CAAC,CACJ;AACL,CAAC;AAED;;;;AAIG;AACH,OAAO,IAAM,2CAA2C,GAAG,SAA9C,2CAA2C,CACpD,kBAAwC,EACxC;EACA,OAAO,kBAAkB,CACpB,MAAM,CAAC,UAAC,CAAC;IAAA,OAAK,CAAC,CAAC,QAAQ;EAAA,EAAC,CACzB,MAAM,CACH,UAAC,CAAC,EAAE,CAAC;IAAA,OACD,CAAC,GACD,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC,GACvB,MAAM,CAAC,CAAC,CAAC,wBAAwB,CAAC,IAClC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC;EAAA,GACvB,CAAC,CACJ;AACT,CAAC;AAED;;;;AAIG;AACH,OAAO,IAAM,8CAA8C,GAAG,SAAjD,8CAA8C,CACvD,kBAAwC,EACxC;EACA,OACI,8CAA8C,CAAC,kBAAkB,CAAC,GAClE,2CAA2C,CAAC,kBAAkB,CAAC;AAEvE,CAAC;AAED,OAAO,IAAM,6BAA6B,GAAG,SAAhC,6BAA6B;EAAA,OACtC,IAAI,CAAC,KAAK,CAAC,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC;AAAA;AAE3C,OAAO,IAAM,qBAAqB,GAAG,SAAxB,qBAAqB,CAAI,SAA8B;EAAA,OAChE,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,EAAE,CAAC,GAAG,IAAI,CAAC;AAAA;AAEjD;;;;;;;AAOG;AACH,OAAO,IAAM,UAAU,GAAG,SAAb,UAAU,QAYlB;EAAA,IAXD,cAAc,SAAd,cAAc;IACd,WAAW,SAAX,WAAW;IACX,gBAAgB,SAAhB,gBAAgB;IAChB,kBAAkB,SAAlB,kBAAkB;IAClB,kBAAkB,SAAlB,kBAAkB;EAQlB,OACI,MAAM,CAAC,cAAc,CAAC,GACtB,0BAA0B,CAAC;IACvB,WAAW,EAAX,WAAW;IACX,gBAAgB,EAAhB,gBAAgB;IAChB,kBAAkB,EAAlB;GACH,CAAC,GACF,2CAA2C,CAAC,kBAAkB,CAAC;AAEvE,CAAC;AAED;AACA;AACA,OAAO,IAAM,gBAAgB,GAAG,SAAnB,gBAAgB,CACzB,QAAa;EAAA,OAC2B,CAAC,CAAC,QAAQ,CAAC,UAAU;AAAA;AAEjE,OAAO,IAAM,cAAc,GAAG,SAAjB,cAAc,CAAI,QAAa;EAAA,OACxC,CAAC,CAAC,QAAQ,CAAC,eAAe;AAAA;AAE9B,OAAO,IAAM,gBAAgB,GAAG,SAAnB,gBAAgB,CACzB,QAAa;EAAA,OACsC,CAAC,CAAC,QAAQ,CAAC,QAAQ;AAAA;AAE1E;;AAEG;AACH,OAAO,IAAM,SAAS,GAAG,SAAZ,SAAS,CAAO,GAAM;EAAA,OAAK,GAAG;AAAA;AAE3C,OAAO,IAAM,iBAAiB,GAAG,SAApB,iBAAiB,CAAI,MAAc,EAAE,YAAoB,EAAI;EACtE,IAAM,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,eAAe;EAC5C,IAAM,WAAW,GAAG,OAAO,CAAC,MAAM,CAC9B,CAAC,QAAQ,EAAE,SAAS,EAAE,SAAS,CAAC,EAChC,CAAC,cAAc,EAAE,MAAM,EAAE,YAAY,CAAC,CACzC;EACD,OAAO,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,WAAW,CAAC;AAC9C,CAAC","sourceRoot":"","sourcesContent":["import { ethers } from \"ethers\";\nimport { SFError } from \"./SFError\";\nimport { AUTHORIZE_FLOW_OPERATOR_CREATE, AUTHORIZE_FLOW_OPERATOR_DELETE, AUTHORIZE_FLOW_OPERATOR_UPDATE, BASE_18, DAY_IN_SECONDS, MONTH_IN_SECONDS, WEEK_IN_SECONDS, YEAR_IN_SECONDS, } from \"./constants\";\nconst EMPTY = \"0x\";\n/**\n * Checks if address is a valid ethereum address and normalizes so it can be used by both subgraph and web3.\n * @param address\n * @returns The normalized address.\n */\nexport const normalizeAddress = (address) => {\n    if (!address)\n        return \"\";\n    if (ethers.utils.isAddress(address) === false) {\n        throw new SFError({\n            type: \"INVALID_ADDRESS\",\n            customMessage: \"The address you have entered is not a valid ethereum address\",\n        });\n    }\n    return address.toLowerCase();\n};\nexport const isPermissionsClean = (permissions) => {\n    return ((permissions &\n        ~(AUTHORIZE_FLOW_OPERATOR_CREATE |\n            AUTHORIZE_FLOW_OPERATOR_UPDATE |\n            AUTHORIZE_FLOW_OPERATOR_DELETE)) ===\n        0);\n};\nexport const isNullOrEmpty = (str) => {\n    return str == null || str === \"\";\n};\n/**\n * Removes the 8-character signature hash from `callData`.\n * @param callData\n * @returns function parameters\n */\nexport const removeSigHashFromCallData = (callData) => EMPTY.concat(callData.slice(10));\n/**\n * A wrapper function for getting the ethers TransactionDescription object given fragments (e.g. ABI), callData and the value amount sent.\n * @param fragments ABI\n * @param data callData of a function\n * @param value amount of ether sent\n * @returns ethers.TransactionDescription object\n */\nexport const getTransactionDescription = (fragments, data, value) => {\n    const iface = new ethers.utils.Interface(fragments);\n    const txnDescription = iface.parseTransaction({ data, value });\n    return txnDescription;\n};\n/**\n * Gets the per second flow rate given an `amountPerYear` value.\n * @param amountPerYear the amount you want to stream per year\n * @returns flow rate per second\n */\nexport const getPerSecondFlowRateByYear = (amountPerYear) => {\n    return Math.round((Number(amountPerYear) / YEAR_IN_SECONDS) * BASE_18).toString();\n};\n/**\n * Gets the per second flow rate given an `amountPerMonth` value.\n * @param amountPerMonth the amount you want to stream per month\n * @returns flow rate per second\n */\nexport const getPerSecondFlowRateByMonth = (amountPerMonth) => {\n    return Math.round((Number(amountPerMonth) / MONTH_IN_SECONDS) * BASE_18).toString();\n};\n/**\n * Gets the per second flow rate given an `amountPerWeek` value.\n * @param amountPerWeek the amount you want to stream per Week\n * @returns flow rate per second\n */\nexport const getPerSecondFlowRateByWeek = (amountPerWeek) => {\n    return Math.round((Number(amountPerWeek) / WEEK_IN_SECONDS) * BASE_18).toString();\n};\n/**\n * Gets the per second flow rate given an `amountPerDay` value.\n * @param amountPerDay the amount you want to stream per day\n * @returns flow rate per second\n */\nexport const getPerSecondFlowRateByDay = (amountPerDay) => {\n    return Math.round((Number(amountPerDay) / DAY_IN_SECONDS) * BASE_18).toString();\n};\n/**\n * Gets daily, weekly, monthly and yearly flowed amounts given a per second flow rate.\n * @param perSecondFlowRate\n * @returns\n */\nexport const getFlowAmountByPerSecondFlowRate = (perSecondFlowRate) => {\n    const decimalFlowRate = Number(perSecondFlowRate) / BASE_18;\n    return {\n        daily: Math.round(decimalFlowRate * DAY_IN_SECONDS).toString(),\n        weekly: Math.round(decimalFlowRate * WEEK_IN_SECONDS).toString(),\n        monthly: Math.round(decimalFlowRate * MONTH_IN_SECONDS).toString(),\n        yearly: Math.round(decimalFlowRate * YEAR_IN_SECONDS).toString(),\n    };\n};\n/**\n * The formula for calculating the flowed amount since updated using Subgraph data.\n * @param netFlowRate the net flow rate of the user\n * @param currentTimestamp the current timestamp\n * @param updatedAtTimestamp the updated at timestamp of the `AccountTokenSnapshot` entity\n * @returns the flowed amount since the updatedAt timestamp\n */\nexport const flowedAmountSinceUpdatedAt = ({ netFlowRate, currentTimestamp, updatedAtTimestamp, }) => {\n    return ((Number(currentTimestamp) - Number(updatedAtTimestamp)) *\n        Number(netFlowRate));\n};\n/**\n * The formula for calculating the total amount distributed to the subscriber (pending or received).\n * @param indexSubscriptions the index subscriptions of a single token from an account.\n * @returns the total amount received since updated at (both pending and actually distributed)\n */\nexport const subscriptionTotalAmountDistributedSinceUpdated = (indexSubscriptions) => {\n    return indexSubscriptions.reduce((x, y) => x +\n        (Number(y.index.indexValue) - Number(y.indexValueUntilUpdatedAt)) *\n            Number(y.units), 0);\n};\n/**\n * The formula for calculating the total amount received (approved subscriptions).\n * @param indexSubscriptions the index subscriptions of a single token from an account.\n * @returns the total amount received since updated at (actually distributed into wallet)\n */\nexport const subscriptionTotalAmountReceivedSinceUpdated = (indexSubscriptions) => {\n    return indexSubscriptions\n        .filter((x) => x.approved)\n        .reduce((x, y) => x +\n        (Number(y.index.indexValue) -\n            Number(y.indexValueUntilUpdatedAt)) *\n            Number(y.units), 0);\n};\n/**\n * The formula for calculating the total amount that is claimable.\n * @param indexSubscriptions the index subscriptions of a single token from an account.\n * @returns the total amount that can be claimed since updated at\n */\nexport const subscriptionTotalAmountClaimableSinceUpdatedAt = (indexSubscriptions) => {\n    return (subscriptionTotalAmountDistributedSinceUpdated(indexSubscriptions) -\n        subscriptionTotalAmountReceivedSinceUpdated(indexSubscriptions));\n};\nexport const getStringCurrentTimeInSeconds = () => Math.floor(new Date().getTime() / 1000);\nexport const getSanitizedTimestamp = (timestamp) => new Date(Number(timestamp.toString()) * 1000);\n/**\n * The formula for calculating the balance until updated at of a user (claimable + received tokens from index)\n * @param currentBalance the current balance until updated at from the `AccountTokenSnapshot` entity\n * @param netFlowRate the net flow rate of the user\n * @param currentTimestamp the current timestamp\n * @param updatedAtTimestamp the updated at timestamp of the `AccountTokenSnapshot` entity\n * @returns the balance since the updated at timestamp\n */\nexport const getBalance = ({ currentBalance, netFlowRate, currentTimestamp, updatedAtTimestamp, indexSubscriptions, }) => {\n    return (Number(currentBalance) +\n        flowedAmountSinceUpdatedAt({\n            netFlowRate,\n            currentTimestamp,\n            updatedAtTimestamp,\n        }) +\n        subscriptionTotalAmountReceivedSinceUpdated(indexSubscriptions));\n};\n// NOTE: This is the only places we are allowed to use explicit any in the\n// sdk-core otherwise this doesn't work properly.\nexport const isEthersProvider = (provider) => !!provider.getNetwork;\nexport const isInjectedWeb3 = (provider) => !!provider.currentProvider;\nexport const isInjectedEthers = (provider) => !!provider.provider;\n/**\n * Why? Because `return obj as T` and `return <T>obj` are not safe type casts.\n */\nexport const typeGuard = (obj) => obj;\nexport const getFlowOperatorId = (sender, flowOperator) => {\n    const encoder = ethers.utils.defaultAbiCoder;\n    const encodedData = encoder.encode([\"string\", \"address\", \"address\"], [\"flowOperator\", sender, flowOperator]);\n    return ethers.utils.keccak256(encodedData);\n};\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}