{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nvar codegen_1 = require(\"../codegen\");\nvar names_1 = require(\"../names\");\nvar code_1 = require(\"../../vocabularies/code\");\nvar errors_1 = require(\"../errors\");\nfunction macroKeywordCode(cxt, def) {\n  var gen = cxt.gen,\n    keyword = cxt.keyword,\n    schema = cxt.schema,\n    parentSchema = cxt.parentSchema,\n    it = cxt.it;\n  var macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n  var schemaRef = useKeyword(gen, keyword, macroSchema);\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);\n  var valid = gen.name(\"valid\");\n  cxt.subschema({\n    schema: macroSchema,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: \"\".concat(it.errSchemaPath, \"/\").concat(keyword),\n    topSchemaRef: schemaRef,\n    compositeRule: true\n  }, valid);\n  cxt.pass(valid, function () {\n    return cxt.error(true);\n  });\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n  var _a;\n  var gen = cxt.gen,\n    keyword = cxt.keyword,\n    schema = cxt.schema,\n    parentSchema = cxt.parentSchema,\n    $data = cxt.$data,\n    it = cxt.it;\n  checkAsyncKeyword(it, def);\n  var validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n  var validateRef = useKeyword(gen, keyword, validate);\n  var valid = gen.let(\"valid\");\n  cxt.block$data(valid, validateKeyword);\n  cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n  function validateKeyword() {\n    if (def.errors === false) {\n      assignValid();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(function () {\n        return cxt.error();\n      });\n    } else {\n      var ruleErrs = def.async ? validateAsync() : validateSync();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(function () {\n        return addErrs(cxt, ruleErrs);\n      });\n    }\n  }\n  function validateAsync() {\n    var ruleErrs = gen.let(\"ruleErrs\", null);\n    gen.try(function () {\n      return assignValid((0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"await \"]))));\n    }, function (e) {\n      return gen.assign(valid, false).if((0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \" instanceof \", \"\"])), e, it.ValidationError), function () {\n        return gen.assign(ruleErrs, (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \".errors\"])), e));\n      }, function () {\n        return gen.throw(e);\n      });\n    });\n    return ruleErrs;\n  }\n  function validateSync() {\n    var validateErrs = (0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \".errors\"])), validateRef);\n    gen.assign(validateErrs, null);\n    assignValid(codegen_1.nil);\n    return validateErrs;\n  }\n  function assignValid() {\n    var _await = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : def.async ? (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"await \"]))) : codegen_1.nil;\n    var passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n    var passSchema = !(\"compile\" in def && !$data || def.schema === false);\n    gen.assign(valid, (0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \"\", \"\"])), _await, (0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)), def.modifying);\n  }\n  function reportErrs(errors) {\n    var _a;\n    gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n  }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n  var gen = cxt.gen,\n    data = cxt.data,\n    it = cxt.it;\n  gen.if(it.parentData, function () {\n    return gen.assign(data, (0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), it.parentData, it.parentDataProperty));\n  });\n}\nfunction addErrs(cxt, errs) {\n  var gen = cxt.gen;\n  gen.if((0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"Array.isArray(\", \")\"])), errs), function () {\n    gen.assign(names_1.default.vErrors, (0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\", \" === null ? \", \" : \", \".concat(\", \")\"])), names_1.default.vErrors, errs, names_1.default.vErrors, errs)).assign(names_1.default.errors, (0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \".length\"])), names_1.default.vErrors));\n    (0, errors_1.extendErrors)(cxt);\n  }, function () {\n    return cxt.error();\n  });\n}\nfunction checkAsyncKeyword(_ref, def) {\n  var schemaEnv = _ref.schemaEnv;\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n  if (result === undefined) throw new Error(\"keyword \\\"\".concat(keyword, \"\\\" failed to compile\"));\n  return gen.scopeValue(\"keyword\", typeof result == \"function\" ? {\n    ref: result\n  } : {\n    ref: result,\n    code: (0, codegen_1.stringify)(result)\n  });\n}\nfunction validSchemaType(schema, schemaType) {\n  var allowUndefined = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // TODO add tests\n  return !schemaType.length || schemaType.some(function (st) {\n    return st === \"array\" ? Array.isArray(schema) : st === \"object\" ? schema && typeof schema == \"object\" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == \"undefined\";\n  });\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage(_ref2, def, keyword) {\n  var schema = _ref2.schema,\n    opts = _ref2.opts,\n    self = _ref2.self,\n    errSchemaPath = _ref2.errSchemaPath;\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\");\n  }\n  var deps = def.dependencies;\n  if (deps === null || deps === void 0 ? void 0 : deps.some(function (kwd) {\n    return !Object.prototype.hasOwnProperty.call(schema, kwd);\n  })) {\n    throw new Error(\"parent schema must have dependencies of \".concat(keyword, \": \").concat(deps.join(\",\")));\n  }\n  if (def.validateSchema) {\n    var valid = def.validateSchema(schema[keyword]);\n    if (!valid) {\n      var msg = \"keyword \\\"\".concat(keyword, \"\\\" value is invalid at path \\\"\").concat(errSchemaPath, \"\\\": \") + self.errorsText(def.validateSchema.errors);\n      if (opts.validateSchema === \"log\") self.logger.error(msg);else throw new Error(msg);\n    }\n  }\n}\nexports.validateKeywordUsage = validateKeywordUsage;","map":{"version":3,"sources":["../../../lib/compile/validate/keyword.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst errors_1 = require(\"../errors\");\nfunction macroKeywordCode(cxt, def) {\n    const { gen, keyword, schema, parentSchema, it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true,\n    }, valid);\n    cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n    checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = useKeyword(gen, keyword, validate);\n    const valid = gen.let(\"valid\");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => cxt.error());\n        }\n        else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !((\"compile\" in def && !$data) || def.schema === false);\n        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n    const { gen, data, it } = cxt;\n    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n    const { gen } = cxt;\n    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {\n        gen\n            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)\n            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n        (0, errors_1.extendErrors)(cxt);\n    }, () => cxt.error());\n}\nfunction checkAsyncKeyword({ schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n    if (result === undefined)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n    return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return (!schemaType.length ||\n        schemaType.some((st) => st === \"array\"\n            ? Array.isArray(schema)\n            : st === \"object\"\n                ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n                : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")));\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */\n    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n    }\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n    }\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n                self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === \"log\")\n                self.logger.error(msg);\n            else\n                throw new Error(msg);\n        }\n    }\n}\nexports.validateKeywordUsage = validateKeywordUsage;\n//# sourceMappingURL=keyword.js.map"]},"metadata":{},"sourceType":"script"}