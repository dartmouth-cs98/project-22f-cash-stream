{"ast":null,"code":"import _objectSpread from \"/Users/taykim/Desktop/cs98/project-22f-zk-vote/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/taykim/Desktop/cs98/project-22f-zk-vote/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/taykim/Desktop/cs98/project-22f-zk-vote/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createClass from \"/Users/taykim/Desktop/cs98/project-22f-zk-vote/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/taykim/Desktop/cs98/project-22f-zk-vote/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nvar _a;\nimport { ethers } from \"ethers\";\nimport BatchCall from \"./BatchCall\";\nimport ConstantFlowAgreementV1 from \"./ConstantFlowAgreementV1\";\nimport Governance from \"./Governance\";\nimport Host from \"./Host\";\nimport InstantDistributionAgreementV1 from \"./InstantDistributionAgreementV1\";\nimport Query from \"./Query\";\nimport { SFError } from \"./SFError\";\nimport SuperToken from \"./SuperToken\";\nimport IResolverABI from \"./abi/IResolver.json\";\nimport SuperfluidLoaderABI from \"./abi/SuperfluidLoader.json\";\nimport { chainIdToResolverDataMap, networkNameToChainIdMap } from \"./constants\";\nimport { getNetworkName, getSubgraphQueriesEndpoint, validateFrameworkConstructorOptions } from \"./frameworkHelpers\";\nimport { isEthersProvider, isInjectedWeb3 } from \"./utils\";\n/**\n * Superfluid Framework Class\n * @description The entrypoint for the SDK-core, `create` an instance of this for full functionality.\n */\nvar Framework = /*#__PURE__*/_createClass(function Framework(options, settings) {\n  var _this = this;\n  _classCallCheck(this, Framework);\n  /**\n   * Create a signer which can be used to sign transactions.\n   * @param options.web3Provider a Web3Provider object (e.g. client side - metamask, web3modal)\n   * @param options.provider an ethers Provider object (e.g. via Hardhat ethers)\n   * @param options.privateKey a test account private key\n   * @param options.signer a signer object (e.g. ethers.Wallet instance)\n   * @returns `ethers.Signer` object\n   */\n  this.createSigner = function (options) {\n    if (!options.privateKey && !options.provider && !options.signer && !options.web3Provider) {\n      throw new SFError({\n        type: \"CREATE_SIGNER\",\n        customMessage: \"You must pass in a private key, provider or signer.\"\n      });\n    }\n    /* istanbul ignore else  */\n    if (options.privateKey) {\n      if (!options.provider) {\n        throw new SFError({\n          type: \"CREATE_SIGNER\",\n          customMessage: \"You must pass in a provider with your private key.\"\n        });\n      }\n      return new ethers.Wallet(options.privateKey, options.provider);\n    } else if (options.signer) {\n      return options.signer;\n    }\n    // NOTE: tested by sdk-redux already\n    else if (options.web3Provider) {\n      return options.web3Provider.getSigner();\n    }\n    /* istanbul ignore next */\n    throw new SFError({\n      type: \"CREATE_SIGNER\",\n      customMessage: \"Something went wrong, this should never occur.\"\n    });\n  };\n  /**\n   * Create a `BatchCall` class from the `Framework`.\n   * @param operations the list of operations to execute\n   * @returns `BatchCall` class\n   */\n  this.batchCall = function (operations) {\n    return new BatchCall({\n      operations: operations,\n      hostAddress: _this.settings.config.hostAddress\n    });\n  };\n  /**\n   * Loads `NativeAssetSuperToken` class from the `Framework`. Will throw if token is not NativeAssetSuperToken.\n   * @param tokenAddressOrSymbol\n   * @returns `NativeAssetSuperToken` class\n   */\n  this.loadNativeAssetSuperToken = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tokenAddressOrSymbol) {\n      var superToken, isNativeAssetSuperToken;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return _this.loadSuperToken(tokenAddressOrSymbol);\n            case 2:\n              superToken = _context.sent;\n              // The NativeAssetSuperToken class should have the nativeTokenSymbol property\n              isNativeAssetSuperToken = !!superToken.nativeTokenSymbol;\n              if (isNativeAssetSuperToken) {\n                _context.next = 6;\n                break;\n              }\n              throw new SFError({\n                type: \"SUPERTOKEN_INITIALIZATION\",\n                customMessage: \"The token is not a native asset supertoken.\"\n              });\n            case 6:\n              return _context.abrupt(\"return\", superToken);\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /**\n   * Loads `PureSuperToken` class from the `Framework`. Will throw if token is not PureSuperToken.\n   * @param tokenAddressOrSymbol\n   * @returns `PureSuperToken` class\n   */\n  this.loadPureSuperToken = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tokenAddressOrSymbol) {\n      var superToken, isPureSuperToken;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return _this.loadSuperToken(tokenAddressOrSymbol);\n            case 2:\n              superToken = _context2.sent;\n              // The PureSuperToken class should not have the downgrade (and upgrade) function\n              // we can just check if downgrade doesn't exist\n              isPureSuperToken = !!superToken.downgrade === false;\n              if (isPureSuperToken) {\n                _context2.next = 6;\n                break;\n              }\n              throw new SFError({\n                type: \"SUPERTOKEN_INITIALIZATION\",\n                customMessage: \"The token is not a pure supertoken.\"\n              });\n            case 6:\n              return _context2.abrupt(\"return\", superToken);\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return function (_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /**\n   * Loads `WrapperSuperToken` class from the `Framework`. Will throw if token is not WrapperSuperToken.\n   * @param tokenAddressOrSymbol\n   * @returns `WrapperSuperToken` class\n   */\n  this.loadWrapperSuperToken = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(tokenAddressOrSymbol) {\n      var superToken, isWrapperSuperToken;\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return _this.loadSuperToken(tokenAddressOrSymbol);\n            case 2:\n              superToken = _context3.sent;\n              // The WrapperSuperToken class should have the underlyingToken property\n              isWrapperSuperToken = !!superToken.underlyingToken;\n              if (isWrapperSuperToken) {\n                _context3.next = 6;\n                break;\n              }\n              throw new SFError({\n                type: \"SUPERTOKEN_INITIALIZATION\",\n                customMessage: \"The token is not a wrapper supertoken.\"\n              });\n            case 6:\n              return _context3.abrupt(\"return\", superToken);\n            case 7:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n    return function (_x3) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  /**\n   * Loads `SuperToken` class from the `Framework`. Use this when you're unsure of the token type.\n   * @param tokenAddressOrSymbol the `SuperToken` address or symbol (if symbol, it must be on the resolver)\n   * @returns `SuperToken` class\n   */\n  this.loadSuperToken = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(tokenAddressOrSymbol) {\n      var address;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return _this._tryGetTokenAddress(tokenAddressOrSymbol);\n            case 2:\n              address = _context4.sent;\n              _context4.next = 5;\n              return SuperToken.create(_objectSpread(_objectSpread({}, _this.settings), {}, {\n                address: address\n              }));\n            case 5:\n              return _context4.abrupt(\"return\", _context4.sent);\n            case 6:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    return function (_x4) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  /**\n   * Try to get the token address given an address (returns if valid) or the token symbol via the resolver.\n   * @param tokenAddressOrSymbol\n   * @returns token address\n   */\n  this._tryGetTokenAddress = /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(tokenAddressOrSymbol) {\n      var isInputValidAddress, superTokenKey, _resolver;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              isInputValidAddress = ethers.utils.isAddress(tokenAddressOrSymbol);\n              if (!isInputValidAddress) {\n                _context5.next = 5;\n                break;\n              }\n              return _context5.abrupt(\"return\", tokenAddressOrSymbol);\n            case 5:\n              _context5.prev = 5;\n              superTokenKey = \"supertokens.\" + _this.settings.protocolReleaseVersion + \".\" + tokenAddressOrSymbol;\n              _resolver = new ethers.Contract(_this.settings.config.resolverAddress, IResolverABI.abi, _this.settings.provider);\n              _context5.next = 10;\n              return _resolver.get(superTokenKey);\n            case 10:\n              return _context5.abrupt(\"return\", _context5.sent);\n            case 13:\n              _context5.prev = 13;\n              _context5.t0 = _context5[\"catch\"](5);\n              throw new SFError({\n                type: \"SUPERTOKEN_INITIALIZATION\",\n                customMessage: \"There was an error with loading the SuperToken with symbol: \" + tokenAddressOrSymbol + \" with the resolver.\",\n                errorObject: _context5.t0\n              });\n            case 16:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5, null, [[5, 13]]);\n    }));\n    return function (_x5) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n  this.userInputOptions = options;\n  this.settings = settings;\n  this.cfaV1 = new ConstantFlowAgreementV1({\n    config: this.settings.config\n  });\n  this.governance = new Governance(this.settings.config.governanceAddress, this.settings.config.hostAddress);\n  this.host = new Host(this.settings.config.hostAddress);\n  this.idaV1 = new InstantDistributionAgreementV1({\n    config: this.settings.config\n  });\n  this.query = new Query(this.settings);\n  var resolver = new ethers.Contract(this.settings.config.resolverAddress, IResolverABI.abi);\n  this.contracts = {\n    cfaV1: this.cfaV1.contract,\n    governance: this.governance.contract,\n    host: this.host.contract,\n    idaV1: this.idaV1.contract,\n    resolver: resolver\n  };\n});\nexport { Framework as default };\n_a = Framework;\n/**\n * Creates the Framework object based on user provided `options`.\n * @param options.chainId the chainId of your desired network (e.g. 137 = matic)\n * @param options.customSubgraphQueriesEndpoint your custom subgraph endpoint\n * @param options.resolverAddress a custom resolver address (advanced use for testing)\n * @param options.protocolReleaseVersion a custom release version (advanced use for testing)\n * @param options.provider a provider object (injected web3, injected ethers, ethers provider) necessary for initializing the framework\n * @returns `Framework` class\n */\nFramework.create = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(options) {\n    var networkName, chainId, releaseVersion, customSubgraphQueriesEndpoint, provider, network, resolverData, resolverAddress, resolver, superfluidLoaderAddress, superfluidLoader, framework, governanceAddress, settings;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            validateFrameworkConstructorOptions(_objectSpread(_objectSpread({}, options), {}, {\n              protocolReleaseVersion: options.protocolReleaseVersion || \"v1\"\n            }));\n            networkName = getNetworkName(options);\n            chainId = options.chainId || networkNameToChainIdMap.get(networkName);\n            releaseVersion = options.protocolReleaseVersion || \"v1\";\n            customSubgraphQueriesEndpoint = options.customSubgraphQueriesEndpoint || getSubgraphQueriesEndpoint(options);\n            provider = isEthersProvider(options.provider) ? options.provider : isInjectedWeb3(options.provider) ?\n            // must explicitly cast web3 provider type because\n            // ethers.providers.Web3Provider doesn't like\n            // the type passed.\n            new ethers.providers.Web3Provider(options.provider.currentProvider) : options.provider.provider;\n            _context6.next = 8;\n            return provider.getNetwork();\n          case 8:\n            network = _context6.sent;\n            if (!(network.chainId !== chainId && chainId != null)) {\n              _context6.next = 11;\n              break;\n            }\n            throw new SFError({\n              type: \"NETWORK_MISMATCH\",\n              customMessage: \"Your provider network chainId is: \" + network.chainId + \" whereas your desired chainId is: \" + chainId\n            });\n          case 11:\n            _context6.prev = 11;\n            resolverData = chainIdToResolverDataMap.get(chainId) || {\n              subgraphAPIEndpoint: \"\",\n              resolverAddress: \"\",\n              networkName: \"\",\n              nativeTokenSymbol: \"\"\n            };\n            resolverAddress = options.resolverAddress ? options.resolverAddress : resolverData.resolverAddress;\n            resolver = new ethers.Contract(resolverAddress, IResolverABI.abi, provider);\n            _context6.next = 17;\n            return resolver.get(\"SuperfluidLoader-v1\");\n          case 17:\n            superfluidLoaderAddress = _context6.sent;\n            superfluidLoader = new ethers.Contract(superfluidLoaderAddress, SuperfluidLoaderABI.abi, provider);\n            _context6.next = 21;\n            return superfluidLoader.loadFramework(releaseVersion);\n          case 21:\n            framework = _context6.sent;\n            _context6.next = 24;\n            return new Host(framework.superfluid).contract.connect(provider).getGovernance();\n          case 24:\n            governanceAddress = _context6.sent;\n            settings = {\n              chainId: chainId,\n              customSubgraphQueriesEndpoint: customSubgraphQueriesEndpoint,\n              protocolReleaseVersion: options.protocolReleaseVersion || \"v1\",\n              provider: provider,\n              networkName: networkName,\n              config: {\n                resolverAddress: resolverAddress,\n                hostAddress: framework.superfluid,\n                cfaV1Address: framework.agreementCFAv1,\n                idaV1Address: framework.agreementIDAv1,\n                governanceAddress: governanceAddress\n              }\n            };\n            return _context6.abrupt(\"return\", new Framework(options, settings));\n          case 29:\n            _context6.prev = 29;\n            _context6.t0 = _context6[\"catch\"](11);\n            throw new SFError({\n              type: \"FRAMEWORK_INITIALIZATION\",\n              customMessage: \"There was an error initializing the framework\",\n              errorObject: _context6.t0\n            });\n          case 32:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6, null, [[11, 29]]);\n  }));\n  return function (_x6) {\n    return _ref6.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["../../src/Framework.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var _a;\nimport { ethers } from \"ethers\";\nimport BatchCall from \"./BatchCall\";\nimport ConstantFlowAgreementV1 from \"./ConstantFlowAgreementV1\";\nimport Governance from \"./Governance\";\nimport Host from \"./Host\";\nimport InstantDistributionAgreementV1 from \"./InstantDistributionAgreementV1\";\nimport Query from \"./Query\";\nimport { SFError } from \"./SFError\";\nimport SuperToken from \"./SuperToken\";\nimport IResolverABI from \"./abi/IResolver.json\";\nimport SuperfluidLoaderABI from \"./abi/SuperfluidLoader.json\";\nimport { chainIdToResolverDataMap, networkNameToChainIdMap } from \"./constants\";\nimport { getNetworkName, getSubgraphQueriesEndpoint, validateFrameworkConstructorOptions, } from \"./frameworkHelpers\";\nimport { isEthersProvider, isInjectedWeb3 } from \"./utils\";\n/**\n * Superfluid Framework Class\n * @description The entrypoint for the SDK-core, `create` an instance of this for full functionality.\n */\nexport default class Framework {\n    constructor(options, settings) {\n        /**\n         * Create a signer which can be used to sign transactions.\n         * @param options.web3Provider a Web3Provider object (e.g. client side - metamask, web3modal)\n         * @param options.provider an ethers Provider object (e.g. via Hardhat ethers)\n         * @param options.privateKey a test account private key\n         * @param options.signer a signer object (e.g. ethers.Wallet instance)\n         * @returns `ethers.Signer` object\n         */\n        this.createSigner = (options) => {\n            if (!options.privateKey &&\n                !options.provider &&\n                !options.signer &&\n                !options.web3Provider) {\n                throw new SFError({\n                    type: \"CREATE_SIGNER\",\n                    customMessage: \"You must pass in a private key, provider or signer.\",\n                });\n            }\n            /* istanbul ignore else  */\n            if (options.privateKey) {\n                if (!options.provider) {\n                    throw new SFError({\n                        type: \"CREATE_SIGNER\",\n                        customMessage: \"You must pass in a provider with your private key.\",\n                    });\n                }\n                return new ethers.Wallet(options.privateKey, options.provider);\n            }\n            else if (options.signer) {\n                return options.signer;\n            }\n            // NOTE: tested by sdk-redux already\n            else if (options.web3Provider) {\n                return options.web3Provider.getSigner();\n            }\n            /* istanbul ignore next */\n            throw new SFError({\n                type: \"CREATE_SIGNER\",\n                customMessage: \"Something went wrong, this should never occur.\",\n            });\n        };\n        /**\n         * Create a `BatchCall` class from the `Framework`.\n         * @param operations the list of operations to execute\n         * @returns `BatchCall` class\n         */\n        this.batchCall = (operations) => {\n            return new BatchCall({\n                operations,\n                hostAddress: this.settings.config.hostAddress,\n            });\n        };\n        /**\n         * Loads `NativeAssetSuperToken` class from the `Framework`. Will throw if token is not NativeAssetSuperToken.\n         * @param tokenAddressOrSymbol\n         * @returns `NativeAssetSuperToken` class\n         */\n        this.loadNativeAssetSuperToken = async (tokenAddressOrSymbol) => {\n            const superToken = await this.loadSuperToken(tokenAddressOrSymbol);\n            // The NativeAssetSuperToken class should have the nativeTokenSymbol property\n            const isNativeAssetSuperToken = !!superToken.nativeTokenSymbol;\n            if (!isNativeAssetSuperToken) {\n                throw new SFError({\n                    type: \"SUPERTOKEN_INITIALIZATION\",\n                    customMessage: \"The token is not a native asset supertoken.\",\n                });\n            }\n            return superToken;\n        };\n        /**\n         * Loads `PureSuperToken` class from the `Framework`. Will throw if token is not PureSuperToken.\n         * @param tokenAddressOrSymbol\n         * @returns `PureSuperToken` class\n         */\n        this.loadPureSuperToken = async (tokenAddressOrSymbol) => {\n            const superToken = await this.loadSuperToken(tokenAddressOrSymbol);\n            // The PureSuperToken class should not have the downgrade (and upgrade) function\n            // we can just check if downgrade doesn't exist\n            const isPureSuperToken = !!superToken.downgrade === false;\n            if (!isPureSuperToken) {\n                throw new SFError({\n                    type: \"SUPERTOKEN_INITIALIZATION\",\n                    customMessage: \"The token is not a pure supertoken.\",\n                });\n            }\n            return superToken;\n        };\n        /**\n         * Loads `WrapperSuperToken` class from the `Framework`. Will throw if token is not WrapperSuperToken.\n         * @param tokenAddressOrSymbol\n         * @returns `WrapperSuperToken` class\n         */\n        this.loadWrapperSuperToken = async (tokenAddressOrSymbol) => {\n            const superToken = await this.loadSuperToken(tokenAddressOrSymbol);\n            // The WrapperSuperToken class should have the underlyingToken property\n            const isWrapperSuperToken = !!superToken.underlyingToken;\n            if (!isWrapperSuperToken) {\n                throw new SFError({\n                    type: \"SUPERTOKEN_INITIALIZATION\",\n                    customMessage: \"The token is not a wrapper supertoken.\",\n                });\n            }\n            return superToken;\n        };\n        /**\n         * Loads `SuperToken` class from the `Framework`. Use this when you're unsure of the token type.\n         * @param tokenAddressOrSymbol the `SuperToken` address or symbol (if symbol, it must be on the resolver)\n         * @returns `SuperToken` class\n         */\n        this.loadSuperToken = async (tokenAddressOrSymbol) => {\n            const address = await this._tryGetTokenAddress(tokenAddressOrSymbol);\n            return await SuperToken.create({\n                ...this.settings,\n                address,\n            });\n        };\n        /**\n         * Try to get the token address given an address (returns if valid) or the token symbol via the resolver.\n         * @param tokenAddressOrSymbol\n         * @returns token address\n         */\n        this._tryGetTokenAddress = async (tokenAddressOrSymbol) => {\n            const isInputValidAddress = ethers.utils.isAddress(tokenAddressOrSymbol);\n            if (isInputValidAddress) {\n                return tokenAddressOrSymbol;\n            }\n            else {\n                try {\n                    const superTokenKey = \"supertokens.\" +\n                        this.settings.protocolReleaseVersion +\n                        \".\" +\n                        tokenAddressOrSymbol;\n                    const resolver = new ethers.Contract(this.settings.config.resolverAddress, IResolverABI.abi, this.settings.provider);\n                    return await resolver.get(superTokenKey);\n                }\n                catch (err) {\n                    throw new SFError({\n                        type: \"SUPERTOKEN_INITIALIZATION\",\n                        customMessage: \"There was an error with loading the SuperToken with symbol: \" +\n                            tokenAddressOrSymbol +\n                            \" with the resolver.\",\n                        errorObject: err,\n                    });\n                }\n            }\n        };\n        this.userInputOptions = options;\n        this.settings = settings;\n        this.cfaV1 = new ConstantFlowAgreementV1({\n            config: this.settings.config,\n        });\n        this.governance = new Governance(this.settings.config.governanceAddress, this.settings.config.hostAddress);\n        this.host = new Host(this.settings.config.hostAddress);\n        this.idaV1 = new InstantDistributionAgreementV1({\n            config: this.settings.config,\n        });\n        this.query = new Query(this.settings);\n        const resolver = new ethers.Contract(this.settings.config.resolverAddress, IResolverABI.abi);\n        this.contracts = {\n            cfaV1: this.cfaV1.contract,\n            governance: this.governance.contract,\n            host: this.host.contract,\n            idaV1: this.idaV1.contract,\n            resolver,\n        };\n    }\n}\n_a = Framework;\n/**\n * Creates the Framework object based on user provided `options`.\n * @param options.chainId the chainId of your desired network (e.g. 137 = matic)\n * @param options.customSubgraphQueriesEndpoint your custom subgraph endpoint\n * @param options.resolverAddress a custom resolver address (advanced use for testing)\n * @param options.protocolReleaseVersion a custom release version (advanced use for testing)\n * @param options.provider a provider object (injected web3, injected ethers, ethers provider) necessary for initializing the framework\n * @returns `Framework` class\n */\nFramework.create = async (options) => {\n    validateFrameworkConstructorOptions({\n        ...options,\n        protocolReleaseVersion: options.protocolReleaseVersion || \"v1\",\n    });\n    const networkName = getNetworkName(options);\n    const chainId = options.chainId || networkNameToChainIdMap.get(networkName);\n    const releaseVersion = options.protocolReleaseVersion || \"v1\";\n    const customSubgraphQueriesEndpoint = options.customSubgraphQueriesEndpoint ||\n        getSubgraphQueriesEndpoint(options);\n    const provider = isEthersProvider(options.provider)\n        ? options.provider\n        : isInjectedWeb3(options.provider)\n            ? // must explicitly cast web3 provider type because\n                // ethers.providers.Web3Provider doesn't like\n                // the type passed.\n                new ethers.providers.Web3Provider(options.provider.currentProvider)\n            : options.provider.provider;\n    const network = await provider.getNetwork();\n    if (network.chainId !== chainId && chainId != null) {\n        throw new SFError({\n            type: \"NETWORK_MISMATCH\",\n            customMessage: \"Your provider network chainId is: \" +\n                network.chainId +\n                \" whereas your desired chainId is: \" +\n                chainId,\n        });\n    }\n    try {\n        const resolverData = chainIdToResolverDataMap.get(chainId) || {\n            subgraphAPIEndpoint: \"\",\n            resolverAddress: \"\",\n            networkName: \"\",\n            nativeTokenSymbol: \"\",\n        };\n        const resolverAddress = options.resolverAddress\n            ? options.resolverAddress\n            : resolverData.resolverAddress;\n        const resolver = new ethers.Contract(resolverAddress, IResolverABI.abi, provider);\n        const superfluidLoaderAddress = await resolver.get(\"SuperfluidLoader-v1\");\n        const superfluidLoader = new ethers.Contract(superfluidLoaderAddress, SuperfluidLoaderABI.abi, provider);\n        const framework = await superfluidLoader.loadFramework(releaseVersion);\n        const governanceAddress = await new Host(framework.superfluid).contract\n            .connect(provider)\n            .getGovernance();\n        const settings = {\n            chainId,\n            customSubgraphQueriesEndpoint,\n            protocolReleaseVersion: options.protocolReleaseVersion || \"v1\",\n            provider,\n            networkName,\n            config: {\n                resolverAddress,\n                hostAddress: framework.superfluid,\n                cfaV1Address: framework.agreementCFAv1,\n                idaV1Address: framework.agreementIDAv1,\n                governanceAddress,\n            },\n        };\n        return new Framework(options, settings);\n    }\n    catch (err) {\n        throw new SFError({\n            type: \"FRAMEWORK_INITIALIZATION\",\n            customMessage: \"There was an error initializing the framework\",\n            errorObject: err,\n        });\n    }\n};\n//# sourceMappingURL=Framework.js.map"]},"metadata":{},"sourceType":"module"}