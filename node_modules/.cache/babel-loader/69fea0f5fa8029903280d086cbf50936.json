{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nvar util_1 = require(\"./util\");\nvar equal = require(\"fast-deep-equal\");\nvar traverse = require(\"json-schema-traverse\");\n// TODO refactor to use keyword definitions\nvar SIMPLE_INLINED = new Set([\"type\", \"format\", \"pattern\", \"maxLength\", \"minLength\", \"maxProperties\", \"minProperties\", \"maxItems\", \"minItems\", \"maximum\", \"minimum\", \"uniqueItems\", \"multipleOf\", \"required\", \"enum\", \"const\"]);\nfunction inlineRef(schema) {\n  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (typeof schema == \"boolean\") return true;\n  if (limit === true) return !hasRef(schema);\n  if (!limit) return false;\n  return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nvar REF_KEYWORDS = new Set([\"$ref\", \"$recursiveRef\", \"$recursiveAnchor\", \"$dynamicRef\", \"$dynamicAnchor\"]);\nfunction hasRef(schema) {\n  for (var key in schema) {\n    if (REF_KEYWORDS.has(key)) return true;\n    var sch = schema[key];\n    if (Array.isArray(sch) && sch.some(hasRef)) return true;\n    if (typeof sch == \"object\" && hasRef(sch)) return true;\n  }\n  return false;\n}\nfunction countKeys(schema) {\n  var count = 0;\n  for (var key in schema) {\n    if (key === \"$ref\") return Infinity;\n    count++;\n    if (SIMPLE_INLINED.has(key)) continue;\n    if (typeof schema[key] == \"object\") {\n      (0, util_1.eachItem)(schema[key], function (sch) {\n        return count += countKeys(sch);\n      });\n    }\n    if (count === Infinity) return Infinity;\n  }\n  return count;\n}\nfunction getFullPath(resolver) {\n  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var normalize = arguments.length > 2 ? arguments[2] : undefined;\n  if (normalize !== false) id = normalizeId(id);\n  var p = resolver.parse(id);\n  return _getFullPath(resolver, p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(resolver, p) {\n  var serialized = resolver.serialize(p);\n  return serialized.split(\"#\")[0] + \"#\";\n}\nexports._getFullPath = _getFullPath;\nvar TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(resolver, baseId, id) {\n  id = normalizeId(id);\n  return resolver.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nvar ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema, baseId) {\n  var _this = this;\n  if (typeof schema == \"boolean\") return {};\n  var _this$opts = this.opts,\n    schemaId = _this$opts.schemaId,\n    uriResolver = _this$opts.uriResolver;\n  var schId = normalizeId(schema[schemaId] || baseId);\n  var baseIds = {\n    \"\": schId\n  };\n  var pathPrefix = getFullPath(uriResolver, schId, false);\n  var localRefs = {};\n  var schemaRefs = new Set();\n  traverse(schema, {\n    allKeys: true\n  }, function (sch, jsonPtr, _, parentJsonPtr) {\n    if (parentJsonPtr === undefined) return;\n    var fullPath = pathPrefix + jsonPtr;\n    var baseId = baseIds[parentJsonPtr];\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(_this, sch[schemaId]);\n    addAnchor.call(_this, sch.$anchor);\n    addAnchor.call(_this, sch.$dynamicAnchor);\n    baseIds[jsonPtr] = baseId;\n    function addRef(ref) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      var _resolve = this.opts.uriResolver.resolve;\n      ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);\n      if (schemaRefs.has(ref)) throw ambiguos(ref);\n      schemaRefs.add(ref);\n      var schOrRef = this.refs[ref];\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef];\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref);\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref);\n          localRefs[ref] = sch;\n        } else {\n          this.refs[ref] = fullPath;\n        }\n      }\n      return ref;\n    }\n    function addAnchor(anchor) {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(\"invalid anchor \\\"\".concat(anchor, \"\\\"\"));\n        addRef.call(this, \"#\".concat(anchor));\n      }\n    }\n  });\n  return localRefs;\n  function checkAmbiguosRef(sch1, sch2, ref) {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref);\n  }\n  function ambiguos(ref) {\n    return new Error(\"reference \\\"\".concat(ref, \"\\\" resolves to more than one schema\"));\n  }\n}\nexports.getSchemaRefs = getSchemaRefs;","map":{"version":3,"sources":["../../lib/compile/resolve.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nconst util_1 = require(\"./util\");\nconst equal = require(\"fast-deep-equal\");\nconst traverse = require(\"json-schema-traverse\");\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n    \"type\",\n    \"format\",\n    \"pattern\",\n    \"maxLength\",\n    \"minLength\",\n    \"maxProperties\",\n    \"minProperties\",\n    \"maxItems\",\n    \"minItems\",\n    \"maximum\",\n    \"minimum\",\n    \"uniqueItems\",\n    \"multipleOf\",\n    \"required\",\n    \"enum\",\n    \"const\",\n]);\nfunction inlineRef(schema, limit = true) {\n    if (typeof schema == \"boolean\")\n        return true;\n    if (limit === true)\n        return !hasRef(schema);\n    if (!limit)\n        return false;\n    return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\n    \"$ref\",\n    \"$recursiveRef\",\n    \"$recursiveAnchor\",\n    \"$dynamicRef\",\n    \"$dynamicAnchor\",\n]);\nfunction hasRef(schema) {\n    for (const key in schema) {\n        if (REF_KEYWORDS.has(key))\n            return true;\n        const sch = schema[key];\n        if (Array.isArray(sch) && sch.some(hasRef))\n            return true;\n        if (typeof sch == \"object\" && hasRef(sch))\n            return true;\n    }\n    return false;\n}\nfunction countKeys(schema) {\n    let count = 0;\n    for (const key in schema) {\n        if (key === \"$ref\")\n            return Infinity;\n        count++;\n        if (SIMPLE_INLINED.has(key))\n            continue;\n        if (typeof schema[key] == \"object\") {\n            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));\n        }\n        if (count === Infinity)\n            return Infinity;\n    }\n    return count;\n}\nfunction getFullPath(resolver, id = \"\", normalize) {\n    if (normalize !== false)\n        id = normalizeId(id);\n    const p = resolver.parse(id);\n    return _getFullPath(resolver, p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(resolver, p) {\n    const serialized = resolver.serialize(p);\n    return serialized.split(\"#\")[0] + \"#\";\n}\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(resolver, baseId, id) {\n    id = normalizeId(id);\n    return resolver.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema, baseId) {\n    if (typeof schema == \"boolean\")\n        return {};\n    const { schemaId, uriResolver } = this.opts;\n    const schId = normalizeId(schema[schemaId] || baseId);\n    const baseIds = { \"\": schId };\n    const pathPrefix = getFullPath(uriResolver, schId, false);\n    const localRefs = {};\n    const schemaRefs = new Set();\n    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {\n        if (parentJsonPtr === undefined)\n            return;\n        const fullPath = pathPrefix + jsonPtr;\n        let baseId = baseIds[parentJsonPtr];\n        if (typeof sch[schemaId] == \"string\")\n            baseId = addRef.call(this, sch[schemaId]);\n        addAnchor.call(this, sch.$anchor);\n        addAnchor.call(this, sch.$dynamicAnchor);\n        baseIds[jsonPtr] = baseId;\n        function addRef(ref) {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            const _resolve = this.opts.uriResolver.resolve;\n            ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);\n            if (schemaRefs.has(ref))\n                throw ambiguos(ref);\n            schemaRefs.add(ref);\n            let schOrRef = this.refs[ref];\n            if (typeof schOrRef == \"string\")\n                schOrRef = this.refs[schOrRef];\n            if (typeof schOrRef == \"object\") {\n                checkAmbiguosRef(sch, schOrRef.schema, ref);\n            }\n            else if (ref !== normalizeId(fullPath)) {\n                if (ref[0] === \"#\") {\n                    checkAmbiguosRef(sch, localRefs[ref], ref);\n                    localRefs[ref] = sch;\n                }\n                else {\n                    this.refs[ref] = fullPath;\n                }\n            }\n            return ref;\n        }\n        function addAnchor(anchor) {\n            if (typeof anchor == \"string\") {\n                if (!ANCHOR.test(anchor))\n                    throw new Error(`invalid anchor \"${anchor}\"`);\n                addRef.call(this, `#${anchor}`);\n            }\n        }\n    });\n    return localRefs;\n    function checkAmbiguosRef(sch1, sch2, ref) {\n        if (sch2 !== undefined && !equal(sch1, sch2))\n            throw ambiguos(ref);\n    }\n    function ambiguos(ref) {\n        return new Error(`reference \"${ref}\" resolves to more than one schema`);\n    }\n}\nexports.getSchemaRefs = getSchemaRefs;\n//# sourceMappingURL=resolve.js.map"]},"metadata":{},"sourceType":"script"}