{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _templateObject, _templateObject2;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar code_1 = require(\"../code\");\nvar codegen_1 = require(\"../../compile/codegen\");\nvar util_1 = require(\"../../compile/util\");\nvar util_2 = require(\"../../compile/util\");\nvar def = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code: function code(cxt) {\n    var gen = cxt.gen,\n      schema = cxt.schema,\n      data = cxt.data,\n      parentSchema = cxt.parentSchema,\n      it = cxt.it;\n    var opts = it.opts;\n    var patterns = (0, code_1.allSchemaProperties)(schema);\n    var alwaysValidPatterns = patterns.filter(function (p) {\n      return (0, util_1.alwaysValidSchema)(it, schema[p]);\n    });\n    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {\n      return;\n    }\n    var checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n    var valid = gen.name(\"valid\");\n    if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n      it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n    }\n    var props = it.props;\n    validatePatternProperties();\n    function validatePatternProperties() {\n      var _iterator = _createForOfIteratorHelper(patterns),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pat = _step.value;\n          if (checkProperties) checkMatchingProperties(pat);\n          if (it.allErrors) {\n            validateProperties(pat);\n          } else {\n            gen.var(valid, true); // TODO var\n            validateProperties(pat);\n            gen.if(valid);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    function checkMatchingProperties(pat) {\n      for (var prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          (0, util_1.checkStrictMode)(it, \"property \".concat(prop, \" matches pattern \").concat(pat, \" (use allowMatchingProperties)\"));\n        }\n      }\n    }\n    function validateProperties(pat) {\n      gen.forIn(\"key\", data, function (key) {\n        gen.if((0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \".test(\", \")\"])), (0, code_1.usePattern)(cxt, pat), key), function () {\n          var alwaysValid = alwaysValidPatterns.includes(pat);\n          if (!alwaysValid) {\n            cxt.subschema({\n              keyword: \"patternProperties\",\n              schemaProp: pat,\n              dataProp: key,\n              dataPropType: util_2.Type.Str\n            }, valid);\n          }\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign((0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), props, key), true);\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if((0, codegen_1.not)(valid), function () {\n              return gen.break();\n            });\n          }\n        });\n      });\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/patternProperties.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst util_2 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 ||\n            (alwaysValidPatterns.length === patterns.length &&\n                (!it.opts.unevaluated || it.props === true))) {\n            return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns) {\n                if (checkProperties)\n                    checkMatchingProperties(pat);\n                if (it.allErrors) {\n                    validateProperties(pat);\n                }\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for (const prop in checkProperties) {\n                if (new RegExp(pat).test(prop)) {\n                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n                }\n            }\n        }\n        function validateProperties(pat) {\n            gen.forIn(\"key\", data, (key) => {\n                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n                    const alwaysValid = alwaysValidPatterns.includes(pat);\n                    if (!alwaysValid) {\n                        cxt.subschema({\n                            keyword: \"patternProperties\",\n                            schemaProp: pat,\n                            dataProp: key,\n                            dataPropType: util_2.Type.Str,\n                        }, valid);\n                    }\n                    if (it.opts.unevaluated && props !== true) {\n                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);\n                    }\n                    else if (!alwaysValid && !it.allErrors) {\n                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                        // or if all properties were evaluated (props === true)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                    }\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=patternProperties.js.map"]},"metadata":{},"sourceType":"script"}