{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _taggedTemplateLiteral = require(\"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar codegen_1 = require(\"../../compile/codegen\");\nvar util_1 = require(\"../../compile/util\");\nvar equal_1 = require(\"../../runtime/equal\");\nvar error = {\n  message: \"must be equal to one of the allowed values\",\n  params: function params(_ref) {\n    var schemaCode = _ref.schemaCode;\n    return (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"{allowedValues: \", \"}\"])), schemaCode);\n  }\n};\nvar def = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error: error,\n  code: function code(cxt) {\n    var gen = cxt.gen,\n      data = cxt.data,\n      $data = cxt.$data,\n      schema = cxt.schema,\n      schemaCode = cxt.schemaCode,\n      it = cxt.it;\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\");\n    var useLoop = schema.length >= it.opts.loopEnum;\n    var eql;\n    var getEql = function getEql() {\n      return eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);\n    };\n    var valid;\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\");\n      cxt.block$data(valid, loopEnum);\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n      var vSchema = gen.const(\"vSchema\", schemaCode);\n      valid = (0, codegen_1.or).apply(void 0, _toConsumableArray(schema.map(function (_x, i) {\n        return equalCode(vSchema, i);\n      })));\n    }\n    cxt.pass(valid);\n    function loopEnum() {\n      gen.assign(valid, false);\n      gen.forOf(\"v\", schemaCode, function (v) {\n        return gen.if((0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \"(\", \", \", \")\"])), getEql(), data, v), function () {\n          return gen.assign(valid, true).break();\n        });\n      });\n    }\n    function equalCode(vSchema, i) {\n      var sch = schema[i];\n      return typeof sch === \"object\" && sch !== null ? (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \"(\", \", \", \"[\", \"])\"])), getEql(), data, vSchema, i) : (0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), data, sch);\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/validation/enum.ts"],"names":[],"mappings":";;;;;;;;AAEA,IAAA,SAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;AAIA,IAAM,KAAK,GAA2B;EACpC,OAAO,EAAE,4CAA4C;EACrD,MAAM,EAAE;IAAA,IAAE,UAAU,QAAV,UAAU;IAAA,QAAM,CAAA,EAAA,SAAA,CAAA,CAAC,4FAAmB,UAAU;EAAA;CACzD;AAED,IAAM,GAAG,GAA0B;EACjC,OAAO,EAAE,MAAM;EACf,UAAU,EAAE,OAAO;EACnB,KAAK,EAAE,IAAI;EACX,KAAK,EAAL,KAAK;EACL,IAAI,gBAAC,GAAe,EAAA;IAClB,IAAO,GAAG,GAAyC,GAAG,CAA/C,GAAG;MAAE,IAAI,GAAmC,GAAG,CAA1C,IAAI;MAAE,KAAK,GAA4B,GAAG,CAApC,KAAK;MAAE,MAAM,GAAoB,GAAG,CAA7B,MAAM;MAAE,UAAU,GAAQ,GAAG,CAArB,UAAU;MAAE,EAAE,GAAI,GAAG,CAAT,EAAE;IAC/C,IAAI,CAAC,KAAK,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC;IACpF,IAAM,OAAO,GAAG,MAAM,CAAC,MAAM,IAAI,EAAE,CAAC,IAAI,CAAC,QAAQ;IACjD,IAAI,GAAqB;IACzB,IAAM,MAAM,GAAG,SAAT,MAAM;MAAA,OAAgB,GAAG,KAAA,IAAA,IAAH,GAAG,KAAA,KAAA,CAAA,GAAH,GAAG,GAAH,GAAG,GAAK,CAAA,CAAA,EAAA,MAAA,CAAA,OAAO,EAAC,GAAG,EAAE,OAAA,CAAA,OAAK,CAAC;IAAA,CAAC;IAExD,IAAI,KAAW;IACf,IAAI,OAAO,IAAI,KAAK,EAAE;MACpB,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC;MACxB,GAAG,CAAC,UAAU,CAAC,KAAK,EAAE,QAAQ,CAAC;KAChC,MAAM;MACL;MACA,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC;MACvE,IAAM,OAAO,GAAG,GAAG,CAAC,KAAK,CAAC,SAAS,EAAE,UAAU,CAAC;MAChD,KAAK,GAAG,CAAA,CAAA,EAAA,SAAA,CAAA,EAAE,mCAAI,MAAM,CAAC,GAAG,CAAC,UAAC,EAAW,EAAE,CAAS;QAAA,OAAK,SAAS,CAAC,OAAO,EAAE,CAAC,CAAC;MAAA,EAAC,EAAC;IAC7E;IACD,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC;IAEf,SAAS,QAAQ,GAAA;MACf,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC;MACxB,GAAG,CAAC,KAAK,CAAC,GAAG,EAAE,UAAkB,EAAE,UAAC,CAAC;QAAA,OACnC,GAAG,CAAC,EAAE,EAAC,CAAA,EAAA,SAAA,CAAA,CAAC,yFAAG,MAAM,EAAE,EAAI,IAAI,EAAK,CAAC,GAAK;UAAA,OAAM,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,KAAK,EAAE;QAAA,EAAC;MAAA,EAC7E;IACH;IAEA,SAAS,SAAS,CAAC,OAAa,EAAE,CAAS,EAAA;MACzC,IAAM,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC;MACrB,OAAO,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,IAAI,IAC1C,CAAA,EAAA,SAAA,CAAA,CAAC,+FAAG,MAAM,EAAE,EAAI,IAAI,EAAK,OAAO,EAAI,CAAC,KACrC,CAAA,EAAA,SAAA,CAAA,CAAC,sFAAG,IAAI,EAAQ,GAAG,CAAE;IAC3B;EACF;CACD;AAED,OAAA,CAAA,OAAA,GAAe,GAAG","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to one of the allowed values\",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n            throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        let eql;\n        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let(\"valid\");\n            cxt.block$data(valid, loopEnum);\n        }\n        else {\n            /* istanbul ignore if */\n            if (!Array.isArray(schema))\n                throw new Error(\"ajv implementation error\");\n            const vSchema = gen.const(\"vSchema\", schemaCode);\n            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf(\"v\", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return typeof sch === \"object\" && sch !== null\n                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`\n                : (0, codegen_1._) `${data} === ${sch}`;\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=enum.js.map"]},"metadata":{},"sourceType":"script"}