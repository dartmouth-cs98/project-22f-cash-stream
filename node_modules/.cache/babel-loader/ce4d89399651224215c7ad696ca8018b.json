{"ast":null,"code":"\"use strict\";\n\nimport _inherits from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\n;\nvar _constructorGuard = {};\nvar ModifiersBytes = {\n  calldata: true,\n  memory: true,\n  storage: true\n};\nvar ModifiersNest = {\n  calldata: true,\n  memory: true\n};\nfunction checkModifier(type, name) {\n  if (type === \"bytes\" || type === \"string\") {\n    if (ModifiersBytes[name]) {\n      return true;\n    }\n  } else if (type === \"address\") {\n    if (name === \"payable\") {\n      return true;\n    }\n  } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n    if (ModifiersNest[name]) {\n      return true;\n    }\n  }\n  if (ModifiersBytes[name] || name === \"payable\") {\n    logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n  }\n  return false;\n}\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param, allowIndexed) {\n  var originalParam = param;\n  function throwError(i) {\n    logger.throwArgumentError(\"unexpected character at position \".concat(i), \"param\", param);\n  }\n  param = param.replace(/\\s/g, \" \");\n  function newNode(parent) {\n    var node = {\n      type: \"\",\n      name: \"\",\n      parent: parent,\n      state: {\n        allowType: true\n      }\n    };\n    if (allowIndexed) {\n      node.indexed = false;\n    }\n    return node;\n  }\n  var parent = {\n    type: \"\",\n    name: \"\",\n    state: {\n      allowType: true\n    }\n  };\n  var node = parent;\n  for (var i = 0; i < param.length; i++) {\n    var c = param[i];\n    switch (c) {\n      case \"(\":\n        if (node.state.allowType && node.type === \"\") {\n          node.type = \"tuple\";\n        } else if (!node.state.allowParams) {\n          throwError(i);\n        }\n        node.state.allowType = false;\n        node.type = verifyType(node.type);\n        node.components = [newNode(node)];\n        node = node.components[0];\n        break;\n      case \")\":\n        delete node.state;\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n          node.indexed = true;\n          node.name = \"\";\n        }\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n        node.type = verifyType(node.type);\n        var child = node;\n        node = node.parent;\n        if (!node) {\n          throwError(i);\n        }\n        delete child.parent;\n        node.state.allowParams = false;\n        node.state.allowName = true;\n        node.state.allowArray = true;\n        break;\n      case \",\":\n        delete node.state;\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n          node.indexed = true;\n          node.name = \"\";\n        }\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n        node.type = verifyType(node.type);\n        var sibling = newNode(node.parent);\n        //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n      case \" \":\n        // If reading type, the type is done and may read a param or name\n        if (node.state.allowType) {\n          if (node.type !== \"\") {\n            node.type = verifyType(node.type);\n            delete node.state.allowType;\n            node.state.allowName = true;\n            node.state.allowParams = true;\n          }\n        }\n        // If reading name, the name is done\n        if (node.state.allowName) {\n          if (node.name !== \"\") {\n            if (node.name === \"indexed\") {\n              if (!allowIndexed) {\n                throwError(i);\n              }\n              if (node.indexed) {\n                throwError(i);\n              }\n              node.indexed = true;\n              node.name = \"\";\n            } else if (checkModifier(node.type, node.name)) {\n              node.name = \"\";\n            } else {\n              node.state.allowName = false;\n            }\n          }\n        }\n        break;\n      case \"[\":\n        if (!node.state.allowArray) {\n          throwError(i);\n        }\n        node.type += c;\n        node.state.allowArray = false;\n        node.state.allowName = false;\n        node.state.readArray = true;\n        break;\n      case \"]\":\n        if (!node.state.readArray) {\n          throwError(i);\n        }\n        node.type += c;\n        node.state.readArray = false;\n        node.state.allowArray = true;\n        node.state.allowName = true;\n        break;\n      default:\n        if (node.state.allowType) {\n          node.type += c;\n          node.state.allowParams = true;\n          node.state.allowArray = true;\n        } else if (node.state.allowName) {\n          node.name += c;\n          delete node.state.allowArray;\n        } else if (node.state.readArray) {\n          node.type += c;\n        } else {\n          throwError(i);\n        }\n    }\n  }\n  if (node.parent) {\n    logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n  }\n  delete parent.state;\n  if (node.name === \"indexed\") {\n    if (!allowIndexed) {\n      throwError(originalParam.length - 7);\n    }\n    if (node.indexed) {\n      throwError(originalParam.length - 7);\n    }\n    node.indexed = true;\n    node.name = \"\";\n  } else if (checkModifier(node.type, node.name)) {\n    node.name = \"\";\n  }\n  parent.type = verifyType(parent.type);\n  return parent;\n}\nfunction populate(object, params) {\n  for (var key in params) {\n    defineReadOnly(object, key, params[key]);\n  }\n}\nexport var FormatTypes = Object.freeze({\n  // Bare formatting, as is needed for computing a sighash of an event or function\n  sighash: \"sighash\",\n  // Human-Readable with Minimal spacing and without names (compact human-readable)\n  minimal: \"minimal\",\n  // Human-Readable with nice spacing, including all names\n  full: \"full\",\n  // JSON-format a la Solidity\n  json: \"json\"\n});\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexport var ParamType = /*#__PURE__*/function () {\n  function ParamType(constructorGuard, params) {\n    _classCallCheck(this, ParamType);\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new ParamType()\"\n      });\n    }\n    populate(this, params);\n    var match = this.type.match(paramTypeArray);\n    if (match) {\n      populate(this, {\n        arrayLength: parseInt(match[2] || \"-1\"),\n        arrayChildren: ParamType.fromObject({\n          type: match[1],\n          components: this.components\n        }),\n        baseType: \"array\"\n      });\n    } else {\n      populate(this, {\n        arrayLength: null,\n        arrayChildren: null,\n        baseType: this.components != null ? \"tuple\" : this.type\n      });\n    }\n    this._isParamType = true;\n    Object.freeze(this);\n  }\n  // Format the parameter fragment\n  //   - sighash: \"(uint256,address)\"\n  //   - minimal: \"tuple(uint256,address) indexed\"\n  //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n  _createClass(ParamType, [{\n    key: \"format\",\n    value: function format(_format) {\n      if (!_format) {\n        _format = FormatTypes.sighash;\n      }\n      if (!FormatTypes[_format]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format);\n      }\n      if (_format === FormatTypes.json) {\n        var _result = {\n          type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n          name: this.name || undefined\n        };\n        if (typeof this.indexed === \"boolean\") {\n          _result.indexed = this.indexed;\n        }\n        if (this.components) {\n          _result.components = this.components.map(function (comp) {\n            return JSON.parse(comp.format(_format));\n          });\n        }\n        return JSON.stringify(_result);\n      }\n      var result = \"\";\n      // Array\n      if (this.baseType === \"array\") {\n        result += this.arrayChildren.format(_format);\n        result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n      } else {\n        if (this.baseType === \"tuple\") {\n          if (_format !== FormatTypes.sighash) {\n            result += this.type;\n          }\n          result += \"(\" + this.components.map(function (comp) {\n            return comp.format(_format);\n          }).join(_format === FormatTypes.full ? \", \" : \",\") + \")\";\n        } else {\n          result += this.type;\n        }\n      }\n      if (_format !== FormatTypes.sighash) {\n        if (this.indexed === true) {\n          result += \" indexed\";\n        }\n        if (_format === FormatTypes.full && this.name) {\n          result += \" \" + this.name;\n        }\n      }\n      return result;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value, allowIndexed) {\n      if (typeof value === \"string\") {\n        return ParamType.fromString(value, allowIndexed);\n      }\n      return ParamType.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (ParamType.isParamType(value)) {\n        return value;\n      }\n      return new ParamType(_constructorGuard, {\n        name: value.name || null,\n        type: verifyType(value.type),\n        indexed: value.indexed == null ? null : !!value.indexed,\n        components: value.components ? value.components.map(ParamType.fromObject) : null\n      });\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value, allowIndexed) {\n      function ParamTypify(node) {\n        return ParamType.fromObject({\n          name: node.name,\n          type: node.type,\n          indexed: node.indexed,\n          components: node.components\n        });\n      }\n      return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n  }, {\n    key: \"isParamType\",\n    value: function isParamType(value) {\n      return !!(value != null && value._isParamType);\n    }\n  }]);\n  return ParamType;\n}();\n;\nfunction parseParams(value, allowIndex) {\n  return splitNesting(value).map(function (param) {\n    return ParamType.fromString(param, allowIndex);\n  });\n}\nexport var Fragment = /*#__PURE__*/function () {\n  function Fragment(constructorGuard, params) {\n    _classCallCheck(this, Fragment);\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new Fragment()\"\n      });\n    }\n    populate(this, params);\n    this._isFragment = true;\n    Object.freeze(this);\n  }\n  _createClass(Fragment, null, [{\n    key: \"from\",\n    value: function from(value) {\n      if (Fragment.isFragment(value)) {\n        return value;\n      }\n      if (typeof value === \"string\") {\n        return Fragment.fromString(value);\n      }\n      return Fragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (Fragment.isFragment(value)) {\n        return value;\n      }\n      switch (value.type) {\n        case \"function\":\n          return FunctionFragment.fromObject(value);\n        case \"event\":\n          return EventFragment.fromObject(value);\n        case \"constructor\":\n          return ConstructorFragment.fromObject(value);\n        case \"error\":\n          return ErrorFragment.fromObject(value);\n        case \"fallback\":\n        case \"receive\":\n          // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n          return null;\n      }\n      return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n      value = value.replace(/\\s/g, \" \");\n      value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n      value = value.trim();\n      if (value.split(\" \")[0] === \"event\") {\n        return EventFragment.fromString(value.substring(5).trim());\n      } else if (value.split(\" \")[0] === \"function\") {\n        return FunctionFragment.fromString(value.substring(8).trim());\n      } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n        return ConstructorFragment.fromString(value.trim());\n      } else if (value.split(\" \")[0] === \"error\") {\n        return ErrorFragment.fromString(value.substring(5).trim());\n      }\n      return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n  }, {\n    key: \"isFragment\",\n    value: function isFragment(value) {\n      return !!(value && value._isFragment);\n    }\n  }]);\n  return Fragment;\n}();\nexport var EventFragment = /*#__PURE__*/function (_Fragment) {\n  _inherits(EventFragment, _Fragment);\n  var _super = _createSuper(EventFragment);\n  function EventFragment() {\n    _classCallCheck(this, EventFragment);\n    return _super.apply(this, arguments);\n  }\n  _createClass(EventFragment, [{\n    key: \"format\",\n    value: function format(_format2) {\n      if (!_format2) {\n        _format2 = FormatTypes.sighash;\n      }\n      if (!FormatTypes[_format2]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format2);\n      }\n      if (_format2 === FormatTypes.json) {\n        return JSON.stringify({\n          type: \"event\",\n          anonymous: this.anonymous,\n          name: this.name,\n          inputs: this.inputs.map(function (input) {\n            return JSON.parse(input.format(_format2));\n          })\n        });\n      }\n      var result = \"\";\n      if (_format2 !== FormatTypes.sighash) {\n        result += \"event \";\n      }\n      result += this.name + \"(\" + this.inputs.map(function (input) {\n        return input.format(_format2);\n      }).join(_format2 === FormatTypes.full ? \", \" : \",\") + \") \";\n      if (_format2 !== FormatTypes.sighash) {\n        if (this.anonymous) {\n          result += \"anonymous \";\n        }\n      }\n      return result.trim();\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (typeof value === \"string\") {\n        return EventFragment.fromString(value);\n      }\n      return EventFragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (EventFragment.isEventFragment(value)) {\n        return value;\n      }\n      if (value.type !== \"event\") {\n        logger.throwArgumentError(\"invalid event object\", \"value\", value);\n      }\n      var params = {\n        name: verifyIdentifier(value.name),\n        anonymous: value.anonymous,\n        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n        type: \"event\"\n      };\n      return new EventFragment(_constructorGuard, params);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      var match = value.match(regexParen);\n      if (!match) {\n        logger.throwArgumentError(\"invalid event string\", \"value\", value);\n      }\n      var anonymous = false;\n      match[3].split(\" \").forEach(function (modifier) {\n        switch (modifier.trim()) {\n          case \"anonymous\":\n            anonymous = true;\n            break;\n          case \"\":\n            break;\n          default:\n            logger.warn(\"unknown modifier: \" + modifier);\n        }\n      });\n      return EventFragment.fromObject({\n        name: match[1].trim(),\n        anonymous: anonymous,\n        inputs: parseParams(match[2], true),\n        type: \"event\"\n      });\n    }\n  }, {\n    key: \"isEventFragment\",\n    value: function isEventFragment(value) {\n      return value && value._isFragment && value.type === \"event\";\n    }\n  }]);\n  return EventFragment;\n}(Fragment);\nfunction parseGas(value, params) {\n  params.gas = null;\n  var comps = value.split(\"@\");\n  if (comps.length !== 1) {\n    if (comps.length > 2) {\n      logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n    }\n    if (!comps[1].match(/^[0-9]+$/)) {\n      logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n    }\n    params.gas = BigNumber.from(comps[1]);\n    return comps[0];\n  }\n  return value;\n}\nfunction parseModifiers(value, params) {\n  params.constant = false;\n  params.payable = false;\n  params.stateMutability = \"nonpayable\";\n  value.split(\" \").forEach(function (modifier) {\n    switch (modifier.trim()) {\n      case \"constant\":\n        params.constant = true;\n        break;\n      case \"payable\":\n        params.payable = true;\n        params.stateMutability = \"payable\";\n        break;\n      case \"nonpayable\":\n        params.payable = false;\n        params.stateMutability = \"nonpayable\";\n        break;\n      case \"pure\":\n        params.constant = true;\n        params.stateMutability = \"pure\";\n        break;\n      case \"view\":\n        params.constant = true;\n        params.stateMutability = \"view\";\n        break;\n      case \"external\":\n      case \"public\":\n      case \"\":\n        break;\n      default:\n        console.log(\"unknown modifier: \" + modifier);\n    }\n  });\n}\nfunction verifyState(value) {\n  var result = {\n    constant: false,\n    payable: true,\n    stateMutability: \"payable\"\n  };\n  if (value.stateMutability != null) {\n    result.stateMutability = value.stateMutability;\n    // Set (and check things are consistent) the constant property\n    result.constant = result.stateMutability === \"view\" || result.stateMutability === \"pure\";\n    if (value.constant != null) {\n      if (!!value.constant !== result.constant) {\n        logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n      }\n    }\n    // Set (and check things are consistent) the payable property\n    result.payable = result.stateMutability === \"payable\";\n    if (value.payable != null) {\n      if (!!value.payable !== result.payable) {\n        logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n      }\n    }\n  } else if (value.payable != null) {\n    result.payable = !!value.payable;\n    // If payable we can assume non-constant; otherwise we can't assume\n    if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n      logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n    result.constant = !!value.constant;\n    if (result.constant) {\n      result.stateMutability = \"view\";\n    } else {\n      result.stateMutability = result.payable ? \"payable\" : \"nonpayable\";\n    }\n    if (result.payable && result.constant) {\n      logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n    }\n  } else if (value.constant != null) {\n    result.constant = !!value.constant;\n    result.payable = !result.constant;\n    result.stateMutability = result.constant ? \"view\" : \"payable\";\n  } else if (value.type !== \"constructor\") {\n    logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n  }\n  return result;\n}\nexport var ConstructorFragment = /*#__PURE__*/function (_Fragment2) {\n  _inherits(ConstructorFragment, _Fragment2);\n  var _super2 = _createSuper(ConstructorFragment);\n  function ConstructorFragment() {\n    _classCallCheck(this, ConstructorFragment);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(ConstructorFragment, [{\n    key: \"format\",\n    value: function format(_format3) {\n      if (!_format3) {\n        _format3 = FormatTypes.sighash;\n      }\n      if (!FormatTypes[_format3]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format3);\n      }\n      if (_format3 === FormatTypes.json) {\n        return JSON.stringify({\n          type: \"constructor\",\n          stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n          payable: this.payable,\n          gas: this.gas ? this.gas.toNumber() : undefined,\n          inputs: this.inputs.map(function (input) {\n            return JSON.parse(input.format(_format3));\n          })\n        });\n      }\n      if (_format3 === FormatTypes.sighash) {\n        logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n          operation: \"format(sighash)\"\n        });\n      }\n      var result = \"constructor(\" + this.inputs.map(function (input) {\n        return input.format(_format3);\n      }).join(_format3 === FormatTypes.full ? \", \" : \",\") + \") \";\n      if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n        result += this.stateMutability + \" \";\n      }\n      return result.trim();\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (typeof value === \"string\") {\n        return ConstructorFragment.fromString(value);\n      }\n      return ConstructorFragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (ConstructorFragment.isConstructorFragment(value)) {\n        return value;\n      }\n      if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n      }\n      var state = verifyState(value);\n      if (state.constant) {\n        logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n      }\n      var params = {\n        name: null,\n        type: value.type,\n        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n        payable: state.payable,\n        stateMutability: state.stateMutability,\n        gas: value.gas ? BigNumber.from(value.gas) : null\n      };\n      return new ConstructorFragment(_constructorGuard, params);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      var params = {\n        type: \"constructor\"\n      };\n      value = parseGas(value, params);\n      var parens = value.match(regexParen);\n      if (!parens || parens[1].trim() !== \"constructor\") {\n        logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n      }\n      params.inputs = parseParams(parens[2].trim(), false);\n      parseModifiers(parens[3].trim(), params);\n      return ConstructorFragment.fromObject(params);\n    }\n  }, {\n    key: \"isConstructorFragment\",\n    value: function isConstructorFragment(value) {\n      return value && value._isFragment && value.type === \"constructor\";\n    }\n  }]);\n  return ConstructorFragment;\n}(Fragment);\nexport var FunctionFragment = /*#__PURE__*/function (_ConstructorFragment) {\n  _inherits(FunctionFragment, _ConstructorFragment);\n  var _super3 = _createSuper(FunctionFragment);\n  function FunctionFragment() {\n    _classCallCheck(this, FunctionFragment);\n    return _super3.apply(this, arguments);\n  }\n  _createClass(FunctionFragment, [{\n    key: \"format\",\n    value: function format(_format4) {\n      if (!_format4) {\n        _format4 = FormatTypes.sighash;\n      }\n      if (!FormatTypes[_format4]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format4);\n      }\n      if (_format4 === FormatTypes.json) {\n        return JSON.stringify({\n          type: \"function\",\n          name: this.name,\n          constant: this.constant,\n          stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n          payable: this.payable,\n          gas: this.gas ? this.gas.toNumber() : undefined,\n          inputs: this.inputs.map(function (input) {\n            return JSON.parse(input.format(_format4));\n          }),\n          outputs: this.outputs.map(function (output) {\n            return JSON.parse(output.format(_format4));\n          })\n        });\n      }\n      var result = \"\";\n      if (_format4 !== FormatTypes.sighash) {\n        result += \"function \";\n      }\n      result += this.name + \"(\" + this.inputs.map(function (input) {\n        return input.format(_format4);\n      }).join(_format4 === FormatTypes.full ? \", \" : \",\") + \") \";\n      if (_format4 !== FormatTypes.sighash) {\n        if (this.stateMutability) {\n          if (this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n          }\n        } else if (this.constant) {\n          result += \"view \";\n        }\n        if (this.outputs && this.outputs.length) {\n          result += \"returns (\" + this.outputs.map(function (output) {\n            return output.format(_format4);\n          }).join(\", \") + \") \";\n        }\n        if (this.gas != null) {\n          result += \"@\" + this.gas.toString() + \" \";\n        }\n      }\n      return result.trim();\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (typeof value === \"string\") {\n        return FunctionFragment.fromString(value);\n      }\n      return FunctionFragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (FunctionFragment.isFunctionFragment(value)) {\n        return value;\n      }\n      if (value.type !== \"function\") {\n        logger.throwArgumentError(\"invalid function object\", \"value\", value);\n      }\n      var state = verifyState(value);\n      var params = {\n        type: value.type,\n        name: verifyIdentifier(value.name),\n        constant: state.constant,\n        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n        outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],\n        payable: state.payable,\n        stateMutability: state.stateMutability,\n        gas: value.gas ? BigNumber.from(value.gas) : null\n      };\n      return new FunctionFragment(_constructorGuard, params);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      var params = {\n        type: \"function\"\n      };\n      value = parseGas(value, params);\n      var comps = value.split(\" returns \");\n      if (comps.length > 2) {\n        logger.throwArgumentError(\"invalid function string\", \"value\", value);\n      }\n      var parens = comps[0].match(regexParen);\n      if (!parens) {\n        logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n      }\n      params.name = parens[1].trim();\n      if (params.name) {\n        verifyIdentifier(params.name);\n      }\n      params.inputs = parseParams(parens[2], false);\n      parseModifiers(parens[3].trim(), params);\n      // We have outputs\n      if (comps.length > 1) {\n        var returns = comps[1].match(regexParen);\n        if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n          logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n        }\n        params.outputs = parseParams(returns[2], false);\n      } else {\n        params.outputs = [];\n      }\n      return FunctionFragment.fromObject(params);\n    }\n  }, {\n    key: \"isFunctionFragment\",\n    value: function isFunctionFragment(value) {\n      return value && value._isFragment && value.type === \"function\";\n    }\n  }]);\n  return FunctionFragment;\n}(ConstructorFragment);\n//export class StructFragment extends Fragment {\n//}\nfunction checkForbidden(fragment) {\n  var sig = fragment.format();\n  if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n    logger.throwArgumentError(\"cannot specify user defined \".concat(sig, \" error\"), \"fragment\", fragment);\n  }\n  return fragment;\n}\nexport var ErrorFragment = /*#__PURE__*/function (_Fragment3) {\n  _inherits(ErrorFragment, _Fragment3);\n  var _super4 = _createSuper(ErrorFragment);\n  function ErrorFragment() {\n    _classCallCheck(this, ErrorFragment);\n    return _super4.apply(this, arguments);\n  }\n  _createClass(ErrorFragment, [{\n    key: \"format\",\n    value: function format(_format5) {\n      if (!_format5) {\n        _format5 = FormatTypes.sighash;\n      }\n      if (!FormatTypes[_format5]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format5);\n      }\n      if (_format5 === FormatTypes.json) {\n        return JSON.stringify({\n          type: \"error\",\n          name: this.name,\n          inputs: this.inputs.map(function (input) {\n            return JSON.parse(input.format(_format5));\n          })\n        });\n      }\n      var result = \"\";\n      if (_format5 !== FormatTypes.sighash) {\n        result += \"error \";\n      }\n      result += this.name + \"(\" + this.inputs.map(function (input) {\n        return input.format(_format5);\n      }).join(_format5 === FormatTypes.full ? \", \" : \",\") + \") \";\n      return result.trim();\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (typeof value === \"string\") {\n        return ErrorFragment.fromString(value);\n      }\n      return ErrorFragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (ErrorFragment.isErrorFragment(value)) {\n        return value;\n      }\n      if (value.type !== \"error\") {\n        logger.throwArgumentError(\"invalid error object\", \"value\", value);\n      }\n      var params = {\n        type: value.type,\n        name: verifyIdentifier(value.name),\n        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []\n      };\n      return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      var params = {\n        type: \"error\"\n      };\n      var parens = value.match(regexParen);\n      if (!parens) {\n        logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n      }\n      params.name = parens[1].trim();\n      if (params.name) {\n        verifyIdentifier(params.name);\n      }\n      params.inputs = parseParams(parens[2], false);\n      return checkForbidden(ErrorFragment.fromObject(params));\n    }\n  }, {\n    key: \"isErrorFragment\",\n    value: function isErrorFragment(value) {\n      return value && value._isFragment && value.type === \"error\";\n    }\n  }]);\n  return ErrorFragment;\n}(Fragment);\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = \"uint256\" + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = \"int256\" + type.substring(3);\n  }\n  // @TODO: more verification\n  return type;\n}\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nvar regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value) {\n  if (!value || !value.match(regexIdentifier)) {\n    logger.throwArgumentError(\"invalid identifier \\\"\".concat(value, \"\\\"\"), \"value\", value);\n  }\n  return value;\n}\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nfunction splitNesting(value) {\n  value = value.trim();\n  var result = [];\n  var accum = \"\";\n  var depth = 0;\n  for (var offset = 0; offset < value.length; offset++) {\n    var c = value[offset];\n    if (c === \",\" && depth === 0) {\n      result.push(accum);\n      accum = \"\";\n    } else {\n      accum += c;\n      if (c === \"(\") {\n        depth++;\n      } else if (c === \")\") {\n        depth--;\n        if (depth === -1) {\n          logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n        }\n      }\n    }\n  }\n  if (accum) {\n    result.push(accum);\n  }\n  return result;\n}","map":{"version":3,"sources":["../src.ts/fragments.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\nconst _constructorGuard = {};\nlet ModifiersBytes = { calldata: true, memory: true, storage: true };\nlet ModifiersNest = { calldata: true, memory: true };\nfunction checkModifier(type, name) {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) {\n            return true;\n        }\n    }\n    else if (type === \"address\") {\n        if (name === \"payable\") {\n            return true;\n        }\n    }\n    else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) {\n            return true;\n        }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param, allowIndexed) {\n    let originalParam = param;\n    function throwError(i) {\n        logger.throwArgumentError(`unexpected character at position ${i}`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n    function newNode(parent) {\n        let node = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) {\n            node.indexed = false;\n        }\n        return node;\n    }\n    let parent = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                }\n                else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [newNode(node)];\n                node = node.components[0];\n                break;\n            case \")\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let child = node;\n                node = node.parent;\n                if (!node) {\n                    throwError(i);\n                }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n            case \",\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let sibling = newNode(node.parent);\n                //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n            // Hit a space...\n            case \" \":\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) {\n                                throwError(i);\n                            }\n                            if (node.indexed) {\n                                throwError(i);\n                            }\n                            node.indexed = true;\n                            node.name = \"\";\n                        }\n                        else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        }\n                        else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n                break;\n            case \"[\":\n                if (!node.state.allowArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n            case \"]\":\n                if (!node.state.readArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                }\n                else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                }\n                else if (node.state.readArray) {\n                    node.type += c;\n                }\n                else {\n                    throwError(i);\n                }\n        }\n    }\n    if (node.parent) {\n        logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n    }\n    delete parent.state;\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) {\n            throwError(originalParam.length - 7);\n        }\n        if (node.indexed) {\n            throwError(originalParam.length - 7);\n        }\n        node.indexed = true;\n        node.name = \"\";\n    }\n    else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n    parent.type = verifyType(parent.type);\n    return parent;\n}\nfunction populate(object, params) {\n    for (let key in params) {\n        defineReadOnly(object, key, params[key]);\n    }\n}\nexport const FormatTypes = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n    // JSON-format a la Solidity\n    json: \"json\"\n});\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexport class ParamType {\n    constructor(constructorGuard, params) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new ParamType()\"\n            });\n        }\n        populate(this, params);\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        }\n        else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\" : this.type)\n            });\n        }\n        this._isParamType = true;\n        Object.freeze(this);\n    }\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            let result = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof (this.indexed) === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n        }\n        else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \")\";\n            }\n            else {\n                result += this.type;\n            }\n        }\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    static from(value, allowIndexed) {\n        if (typeof (value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ParamType.isParamType(value)) {\n            return value;\n        }\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null : !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject) : null)\n        });\n    }\n    static fromString(value, allowIndexed) {\n        function ParamTypify(node) {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n    static isParamType(value) {\n        return !!(value != null && value._isParamType);\n    }\n}\n;\nfunction parseParams(value, allowIndex) {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\nexport class Fragment {\n    constructor(constructorGuard, params) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n        this._isFragment = true;\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n        return Fragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n    static fromString(value) {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n        if (value.split(\" \")[0] === \"event\") {\n            return EventFragment.fromString(value.substring(5).trim());\n        }\n        else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        }\n        else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        }\n        else if (value.split(\" \")[0] === \"error\") {\n            return ErrorFragment.fromString(value.substring(5).trim());\n        }\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n    static isFragment(value) {\n        return !!(value && value._isFragment);\n    }\n}\nexport class EventFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (EventFragment.isEventFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n        const params = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n        return new EventFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch (modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n    static isEventFragment(value) {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\nfunction parseGas(value, params) {\n    params.gas = null;\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n    return value;\n}\nfunction parseModifiers(value, params) {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\nfunction verifyState(value) {\n    let result = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n    }\n    else if (value.payable != null) {\n        result.payable = !!value.payable;\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n        result.constant = !!value.constant;\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        }\n        else {\n            result.stateMutability = (result.payable ? \"payable\" : \"nonpayable\");\n        }\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n    }\n    else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\" : \"payable\");\n    }\n    else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n    return result;\n}\nexport class ConstructorFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n        let result = \"constructor(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ConstructorFragment.isConstructorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n        const params = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas) : null)\n        };\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let params = { type: \"constructor\" };\n        value = parseGas(value, params);\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n        params.inputs = parseParams(parens[2].trim(), false);\n        parseModifiers(parens[3].trim(), params);\n        return ConstructorFragment.fromObject(params);\n    }\n    static isConstructorFragment(value) {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\nexport class FunctionFragment extends ConstructorFragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            }\n            else if (this.constant) {\n                result += \"view \";\n            }\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map((output) => output.format(format)).join(\", \") + \") \";\n            }\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (FunctionFragment.isFunctionFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n        let state = verifyState(value);\n        const params = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas) : null)\n        };\n        return new FunctionFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let params = { type: \"function\" };\n        value = parseGas(value, params);\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n        params.name = parens[1].trim();\n        if (params.name) {\n            verifyIdentifier(params.name);\n        }\n        params.inputs = parseParams(parens[2], false);\n        parseModifiers(parens[3].trim(), params);\n        // We have outputs\n        if (comps.length > 1) {\n            let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        }\n        else {\n            params.outputs = [];\n        }\n        return FunctionFragment.fromObject(params);\n    }\n    static isFunctionFragment(value) {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n//export class StructFragment extends Fragment {\n//}\nfunction checkForbidden(fragment) {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${sig} error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\nexport class ErrorFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ErrorFragment.isErrorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n        const params = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])\n        };\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n    static fromString(value) {\n        let params = { type: \"error\" };\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n        params.name = parens[1].trim();\n        if (params.name) {\n            verifyIdentifier(params.name);\n        }\n        params.inputs = parseParams(parens[2], false);\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n    static isErrorFragment(value) {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\nfunction verifyType(type) {\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    }\n    else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n    // @TODO: more verification\n    return type;\n}\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value) {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${value}\"`, \"value\", value);\n    }\n    return value;\n}\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nfunction splitNesting(value) {\n    value = value.trim();\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        }\n        else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            }\n            else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) {\n        result.push(accum);\n    }\n    return result;\n}\n//# sourceMappingURL=fragments.js.map"]},"metadata":{},"sourceType":"module"}