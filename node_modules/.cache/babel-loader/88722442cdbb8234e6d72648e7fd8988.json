{"ast":null,"code":"import _regeneratorRuntime from \"/Users/taykim/Desktop/cs98/project-22f-zk-vote/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/taykim/Desktop/cs98/project-22f-zk-vote/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createClass from \"/Users/taykim/Desktop/cs98/project-22f-zk-vote/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/taykim/Desktop/cs98/project-22f-zk-vote/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { ethers } from \"ethers\";\nimport Operation from \"./Operation\";\nimport { SFError } from \"./SFError\";\nimport ERC20WithTokenInfoABI from \"./abi/ERC20WithTokenInfo.json\";\nimport { normalizeAddress } from \"./utils\";\nvar ERC20Token = /*#__PURE__*/_createClass(function ERC20Token(address) {\n  var _this = this;\n  _classCallCheck(this, ERC20Token);\n  /** ### ERC20 Token Contract Read Functions ### */\n  /**\n   * Returns the allowance the `owner` has granted the `spender`.\n   * @param owner the owner who has allotted the allowance\n   * @param spender the spender who has received the allowance\n   * @param providerOrSigner a provider or signer for executing a web3 call\n   * @returns {Promise<string>} the allowance amount\n   */\n  this.allowance = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {\n      var owner, spender, providerOrSigner, normalizedOwner, normalizedSpender, allowance;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              owner = _ref.owner, spender = _ref.spender, providerOrSigner = _ref.providerOrSigner;\n              normalizedOwner = normalizeAddress(owner);\n              normalizedSpender = normalizeAddress(spender);\n              _context.prev = 3;\n              _context.next = 6;\n              return _this.contract.connect(providerOrSigner).allowance(normalizedOwner, normalizedSpender);\n            case 6:\n              allowance = _context.sent;\n              return _context.abrupt(\"return\", allowance.toString());\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context[\"catch\"](3);\n              throw new SFError({\n                type: \"SUPERTOKEN_READ\",\n                customMessage: \"There was an error getting allowance\",\n                errorObject: _context.t0\n              });\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[3, 10]]);\n    }));\n    return function (_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /**\n   * Returns the ERC20 balanceOf the `account`, this can't be negative and will just display 0.\n   * @param account the account you would like to query\n   * @param providerOrSigner a provider or signer for executing a web3 call\n   * @returns {Promise<string>} the token balance of `account`\n   */\n  this.balanceOf = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref3) {\n      var account, providerOrSigner, normalizedAccount, balanceOf;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              account = _ref3.account, providerOrSigner = _ref3.providerOrSigner;\n              _context2.prev = 1;\n              normalizedAccount = normalizeAddress(account);\n              _context2.next = 5;\n              return _this.contract.connect(providerOrSigner).balanceOf(normalizedAccount);\n            case 5:\n              balanceOf = _context2.sent;\n              return _context2.abrupt(\"return\", balanceOf.toString());\n            case 9:\n              _context2.prev = 9;\n              _context2.t0 = _context2[\"catch\"](1);\n              throw new SFError({\n                type: \"SUPERTOKEN_READ\",\n                customMessage: \"There was an error getting balanceOf\",\n                errorObject: _context2.t0\n              });\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[1, 9]]);\n    }));\n    return function (_x2) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  /**\n   * Returns the token name\n   * @param providerOrSigner a provider or signer for executing a web3 call\n   * @returns {string} the token name\n   */\n  this.name = /*#__PURE__*/function () {\n    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref5) {\n      var providerOrSigner, name;\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              providerOrSigner = _ref5.providerOrSigner;\n              _context3.prev = 1;\n              _context3.next = 4;\n              return _this.contract.connect(providerOrSigner).name();\n            case 4:\n              name = _context3.sent;\n              return _context3.abrupt(\"return\", name);\n            case 8:\n              _context3.prev = 8;\n              _context3.t0 = _context3[\"catch\"](1);\n              throw new SFError({\n                type: \"SUPERTOKEN_READ\",\n                customMessage: \"There was an error getting name\",\n                errorObject: _context3.t0\n              });\n            case 11:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, null, [[1, 8]]);\n    }));\n    return function (_x3) {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n  /**\n   * Returns the token symbol\n   * @param providerOrSigner a provider or signer for executing a web3 call\n   * @returns {string} the token symbol\n   */\n  this.symbol = /*#__PURE__*/function () {\n    var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref7) {\n      var providerOrSigner, symbol;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              providerOrSigner = _ref7.providerOrSigner;\n              _context4.prev = 1;\n              _context4.next = 4;\n              return _this.contract.connect(providerOrSigner).symbol();\n            case 4:\n              symbol = _context4.sent;\n              return _context4.abrupt(\"return\", symbol);\n            case 8:\n              _context4.prev = 8;\n              _context4.t0 = _context4[\"catch\"](1);\n              throw new SFError({\n                type: \"SUPERTOKEN_READ\",\n                customMessage: \"There was an error getting symbol\",\n                errorObject: _context4.t0\n              });\n            case 11:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4, null, [[1, 8]]);\n    }));\n    return function (_x4) {\n      return _ref8.apply(this, arguments);\n    };\n  }();\n  /**\n   * Returns the total supply of the token.\n   * @param providerOrSigner a provider or signer for executing a web3 call\n   * @returns {Promise<string>} the total supply of the token\n   */\n  this.totalSupply = /*#__PURE__*/function () {\n    var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(_ref9) {\n      var providerOrSigner, totalSupply;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              providerOrSigner = _ref9.providerOrSigner;\n              _context5.prev = 1;\n              _context5.next = 4;\n              return _this.contract.connect(providerOrSigner).totalSupply();\n            case 4:\n              totalSupply = _context5.sent;\n              return _context5.abrupt(\"return\", totalSupply.toString());\n            case 8:\n              _context5.prev = 8;\n              _context5.t0 = _context5[\"catch\"](1);\n              throw new SFError({\n                type: \"SUPERTOKEN_READ\",\n                customMessage: \"There was an error getting totalSupply\",\n                errorObject: _context5.t0\n              });\n            case 11:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5, null, [[1, 8]]);\n    }));\n    return function (_x5) {\n      return _ref10.apply(this, arguments);\n    };\n  }();\n  /** ### ERC20 Token Contract Write Functions ### */\n  /**\n   * Approve `receiver` to spend `amount` tokens.\n   * @param receiver The receiver approved.\n   * @param amount The amount approved.\n   * @param overrides ethers overrides object for more control over the transaction sent.\n   * @returns {Operation} An instance of Operation which can be executed or batched.\n   */\n  this.approve = function (params) {\n    var normalizedReceiver = normalizeAddress(params.receiver);\n    var txn = _this.contract.populateTransaction.approve(normalizedReceiver, params.amount, params.overrides || {});\n    return new Operation(txn, \"ERC20_APPROVE\");\n  };\n  /**\n   * Transfer `receiver` `amount` tokens.\n   * @param receiver The receiver of the transfer.\n   * @param amount The amount to be transferred.\n   * @param overrides ethers overrides object for more control over the transaction sent.\n   * @returns {Operation} An instance of Operation which can be executed or batched.\n   */\n  this.transfer = function (params) {\n    var normalizedReceiver = normalizeAddress(params.receiver);\n    var txn = _this.contract.populateTransaction.transfer(normalizedReceiver, params.amount, params.overrides || {});\n    return new Operation(txn, \"UNSUPPORTED\");\n  };\n  /**\n   * Transfer from `sender` to `receiver` `amount` tokens.\n   * @param sender The sender of the transfer.\n   * @param receiver The receiver of the transfer.\n   * @param amount The amount to be transferred.\n   * @param overrides ethers overrides object for more control over the transaction sent.\n   * @returns {Operation} An instance of Operation which can be executed or batched.\n   */\n  this.transferFrom = function (params) {\n    var normalizedSender = normalizeAddress(params.sender);\n    var normalizedReceiver = normalizeAddress(params.receiver);\n    var txn = _this.contract.populateTransaction.transferFrom(normalizedSender, normalizedReceiver, params.amount, params.overrides || {});\n    return new Operation(txn, \"ERC20_TRANSFER_FROM\");\n  };\n  this.address = address;\n  this.contract = new ethers.Contract(this.address, ERC20WithTokenInfoABI.abi);\n});\nexport { ERC20Token as default };","map":{"version":3,"sources":["../../src/ERC20Token.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ethers } from \"ethers\";\nimport Operation from \"./Operation\";\nimport { SFError } from \"./SFError\";\nimport ERC20WithTokenInfoABI from \"./abi/ERC20WithTokenInfo.json\";\nimport { normalizeAddress } from \"./utils\";\nexport default class ERC20Token {\n    constructor(address) {\n        /** ### ERC20 Token Contract Read Functions ### */\n        /**\n         * Returns the allowance the `owner` has granted the `spender`.\n         * @param owner the owner who has allotted the allowance\n         * @param spender the spender who has received the allowance\n         * @param providerOrSigner a provider or signer for executing a web3 call\n         * @returns {Promise<string>} the allowance amount\n         */\n        this.allowance = async ({ owner, spender, providerOrSigner, }) => {\n            const normalizedOwner = normalizeAddress(owner);\n            const normalizedSpender = normalizeAddress(spender);\n            try {\n                const allowance = await this.contract\n                    .connect(providerOrSigner)\n                    .allowance(normalizedOwner, normalizedSpender);\n                return allowance.toString();\n            }\n            catch (err) {\n                throw new SFError({\n                    type: \"SUPERTOKEN_READ\",\n                    customMessage: \"There was an error getting allowance\",\n                    errorObject: err,\n                });\n            }\n        };\n        /**\n         * Returns the ERC20 balanceOf the `account`, this can't be negative and will just display 0.\n         * @param account the account you would like to query\n         * @param providerOrSigner a provider or signer for executing a web3 call\n         * @returns {Promise<string>} the token balance of `account`\n         */\n        this.balanceOf = async ({ account, providerOrSigner, }) => {\n            try {\n                const normalizedAccount = normalizeAddress(account);\n                const balanceOf = await this.contract\n                    .connect(providerOrSigner)\n                    .balanceOf(normalizedAccount);\n                return balanceOf.toString();\n            }\n            catch (err) {\n                throw new SFError({\n                    type: \"SUPERTOKEN_READ\",\n                    customMessage: \"There was an error getting balanceOf\",\n                    errorObject: err,\n                });\n            }\n        };\n        /**\n         * Returns the token name\n         * @param providerOrSigner a provider or signer for executing a web3 call\n         * @returns {string} the token name\n         */\n        this.name = async ({ providerOrSigner, }) => {\n            try {\n                const name = await this.contract.connect(providerOrSigner).name();\n                return name;\n            }\n            catch (err) {\n                throw new SFError({\n                    type: \"SUPERTOKEN_READ\",\n                    customMessage: \"There was an error getting name\",\n                    errorObject: err,\n                });\n            }\n        };\n        /**\n         * Returns the token symbol\n         * @param providerOrSigner a provider or signer for executing a web3 call\n         * @returns {string} the token symbol\n         */\n        this.symbol = async ({ providerOrSigner, }) => {\n            try {\n                const symbol = await this.contract\n                    .connect(providerOrSigner)\n                    .symbol();\n                return symbol;\n            }\n            catch (err) {\n                throw new SFError({\n                    type: \"SUPERTOKEN_READ\",\n                    customMessage: \"There was an error getting symbol\",\n                    errorObject: err,\n                });\n            }\n        };\n        /**\n         * Returns the total supply of the token.\n         * @param providerOrSigner a provider or signer for executing a web3 call\n         * @returns {Promise<string>} the total supply of the token\n         */\n        this.totalSupply = async ({ providerOrSigner, }) => {\n            try {\n                const totalSupply = await this.contract\n                    .connect(providerOrSigner)\n                    .totalSupply();\n                return totalSupply.toString();\n            }\n            catch (err) {\n                throw new SFError({\n                    type: \"SUPERTOKEN_READ\",\n                    customMessage: \"There was an error getting totalSupply\",\n                    errorObject: err,\n                });\n            }\n        };\n        /** ### ERC20 Token Contract Write Functions ### */\n        /**\n         * Approve `receiver` to spend `amount` tokens.\n         * @param receiver The receiver approved.\n         * @param amount The amount approved.\n         * @param overrides ethers overrides object for more control over the transaction sent.\n         * @returns {Operation} An instance of Operation which can be executed or batched.\n         */\n        this.approve = (params) => {\n            const normalizedReceiver = normalizeAddress(params.receiver);\n            const txn = this.contract.populateTransaction.approve(normalizedReceiver, params.amount, params.overrides || {});\n            return new Operation(txn, \"ERC20_APPROVE\");\n        };\n        /**\n         * Transfer `receiver` `amount` tokens.\n         * @param receiver The receiver of the transfer.\n         * @param amount The amount to be transferred.\n         * @param overrides ethers overrides object for more control over the transaction sent.\n         * @returns {Operation} An instance of Operation which can be executed or batched.\n         */\n        this.transfer = (params) => {\n            const normalizedReceiver = normalizeAddress(params.receiver);\n            const txn = this.contract.populateTransaction.transfer(normalizedReceiver, params.amount, params.overrides || {});\n            return new Operation(txn, \"UNSUPPORTED\");\n        };\n        /**\n         * Transfer from `sender` to `receiver` `amount` tokens.\n         * @param sender The sender of the transfer.\n         * @param receiver The receiver of the transfer.\n         * @param amount The amount to be transferred.\n         * @param overrides ethers overrides object for more control over the transaction sent.\n         * @returns {Operation} An instance of Operation which can be executed or batched.\n         */\n        this.transferFrom = (params) => {\n            const normalizedSender = normalizeAddress(params.sender);\n            const normalizedReceiver = normalizeAddress(params.receiver);\n            const txn = this.contract.populateTransaction.transferFrom(normalizedSender, normalizedReceiver, params.amount, params.overrides || {});\n            return new Operation(txn, \"ERC20_TRANSFER_FROM\");\n        };\n        this.address = address;\n        this.contract = new ethers.Contract(this.address, ERC20WithTokenInfoABI.abi);\n    }\n}\n//# sourceMappingURL=ERC20Token.js.map"]},"metadata":{},"sourceType":"module"}