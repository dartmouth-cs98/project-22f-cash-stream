{"ast":null,"code":"\"use strict\";\n\nimport _regeneratorRuntime from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport aes from \"aes-js\";\nimport scrypt from \"scrypt-js\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\nimport { defaultPath, entropyToMnemonic, HDNode, mnemonicToEntropy } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 as _pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { Description } from \"@ethersproject/properties\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { getPassword, looseArrayify, searchPath, uuidV4, zpad } from \"./utils\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\n// Exported Types\nfunction hasMnemonic(value) {\n  return value != null && value.mnemonic && value.mnemonic.phrase;\n}\nexport var KeystoreAccount = /*#__PURE__*/function (_Description) {\n  _inherits(KeystoreAccount, _Description);\n  var _super = _createSuper(KeystoreAccount);\n  function KeystoreAccount() {\n    _classCallCheck(this, KeystoreAccount);\n    return _super.apply(this, arguments);\n  }\n  _createClass(KeystoreAccount, [{\n    key: \"isKeystoreAccount\",\n    value: function isKeystoreAccount(value) {\n      return !!(value && value._isKeystoreAccount);\n    }\n  }]);\n  return KeystoreAccount;\n}(Description);\nfunction _decrypt(data, key, ciphertext) {\n  var cipher = searchPath(data, \"crypto/cipher\");\n  if (cipher === \"aes-128-ctr\") {\n    var iv = looseArrayify(searchPath(data, \"crypto/cipherparams/iv\"));\n    var counter = new aes.Counter(iv);\n    var aesCtr = new aes.ModeOfOperation.ctr(key, counter);\n    return arrayify(aesCtr.decrypt(ciphertext));\n  }\n  return null;\n}\nfunction _getAccount(data, key) {\n  var ciphertext = looseArrayify(searchPath(data, \"crypto/ciphertext\"));\n  var computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);\n  if (computedMAC !== searchPath(data, \"crypto/mac\").toLowerCase()) {\n    throw new Error(\"invalid password\");\n  }\n  var privateKey = _decrypt(data, key.slice(0, 16), ciphertext);\n  if (!privateKey) {\n    logger.throwError(\"unsupported cipher\", Logger.errors.UNSUPPORTED_OPERATION, {\n      operation: \"decrypt\"\n    });\n  }\n  var mnemonicKey = key.slice(32, 64);\n  var address = computeAddress(privateKey);\n  if (data.address) {\n    var check = data.address.toLowerCase();\n    if (check.substring(0, 2) !== \"0x\") {\n      check = \"0x\" + check;\n    }\n    if (getAddress(check) !== address) {\n      throw new Error(\"address mismatch\");\n    }\n  }\n  var account = {\n    _isKeystoreAccount: true,\n    address: address,\n    privateKey: hexlify(privateKey)\n  };\n  // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n  if (searchPath(data, \"x-ethers/version\") === \"0.1\") {\n    var mnemonicCiphertext = looseArrayify(searchPath(data, \"x-ethers/mnemonicCiphertext\"));\n    var mnemonicIv = looseArrayify(searchPath(data, \"x-ethers/mnemonicCounter\"));\n    var mnemonicCounter = new aes.Counter(mnemonicIv);\n    var mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n    var path = searchPath(data, \"x-ethers/path\") || defaultPath;\n    var locale = searchPath(data, \"x-ethers/locale\") || \"en\";\n    var entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\n    try {\n      var mnemonic = entropyToMnemonic(entropy, locale);\n      var node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);\n      if (node.privateKey != account.privateKey) {\n        throw new Error(\"mnemonic mismatch\");\n      }\n      account.mnemonic = node.mnemonic;\n    } catch (error) {\n      // If we don't have the locale wordlist installed to\n      // read this mnemonic, just bail and don't set the\n      // mnemonic\n      if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== \"wordlist\") {\n        throw error;\n      }\n    }\n  }\n  return new KeystoreAccount(account);\n}\nfunction pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {\n  return arrayify(_pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));\n}\nfunction pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {\n  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));\n}\nfunction _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {\n  var passwordBytes = getPassword(password);\n  var kdf = searchPath(data, \"crypto/kdf\");\n  if (kdf && typeof kdf === \"string\") {\n    var throwError = function throwError(name, value) {\n      return logger.throwArgumentError(\"invalid key-derivation function parameters\", name, value);\n    };\n    if (kdf.toLowerCase() === \"scrypt\") {\n      var salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n      var N = parseInt(searchPath(data, \"crypto/kdfparams/n\"));\n      var r = parseInt(searchPath(data, \"crypto/kdfparams/r\"));\n      var p = parseInt(searchPath(data, \"crypto/kdfparams/p\"));\n      // Check for all required parameters\n      if (!N || !r || !p) {\n        throwError(\"kdf\", kdf);\n      }\n      // Make sure N is a power of 2\n      if ((N & N - 1) !== 0) {\n        throwError(\"N\", N);\n      }\n      var dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n      if (dkLen !== 32) {\n        throwError(\"dklen\", dkLen);\n      }\n      return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);\n    } else if (kdf.toLowerCase() === \"pbkdf2\") {\n      var _salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n      var prfFunc = null;\n      var prf = searchPath(data, \"crypto/kdfparams/prf\");\n      if (prf === \"hmac-sha256\") {\n        prfFunc = \"sha256\";\n      } else if (prf === \"hmac-sha512\") {\n        prfFunc = \"sha512\";\n      } else {\n        throwError(\"prf\", prf);\n      }\n      var count = parseInt(searchPath(data, \"crypto/kdfparams/c\"));\n      var _dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n      if (_dkLen !== 32) {\n        throwError(\"dklen\", _dkLen);\n      }\n      return pbkdf2Func(passwordBytes, _salt, count, _dkLen, prfFunc);\n    }\n  }\n  return logger.throwArgumentError(\"unsupported key-derivation function\", \"kdf\", kdf);\n}\nexport function decryptSync(json, password) {\n  var data = JSON.parse(json);\n  var key = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);\n  return _getAccount(data, key);\n}\nexport function decrypt(json, password, progressCallback) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var data, key;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            data = JSON.parse(json);\n            _context.next = 3;\n            return _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);\n          case 3:\n            key = _context.sent;\n            return _context.abrupt(\"return\", _getAccount(data, key));\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\nexport function encrypt(account, password, options, progressCallback) {\n  try {\n    // Check the address matches the private key\n    if (getAddress(account.address) !== computeAddress(account.privateKey)) {\n      throw new Error(\"address/privateKey mismatch\");\n    }\n    // Check the mnemonic (if any) matches the private key\n    if (hasMnemonic(account)) {\n      var mnemonic = account.mnemonic;\n      var node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);\n      if (node.privateKey != account.privateKey) {\n        throw new Error(\"mnemonic mismatch\");\n      }\n    }\n  } catch (e) {\n    return Promise.reject(e);\n  }\n  // The options are optional, so adjust the call as needed\n  if (typeof options === \"function\" && !progressCallback) {\n    progressCallback = options;\n    options = {};\n  }\n  if (!options) {\n    options = {};\n  }\n  var privateKey = arrayify(account.privateKey);\n  var passwordBytes = getPassword(password);\n  var entropy = null;\n  var path = null;\n  var locale = null;\n  if (hasMnemonic(account)) {\n    var srcMnemonic = account.mnemonic;\n    entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || \"en\"));\n    path = srcMnemonic.path || defaultPath;\n    locale = srcMnemonic.locale || \"en\";\n  }\n  var client = options.client;\n  if (!client) {\n    client = \"ethers.js\";\n  }\n  // Check/generate the salt\n  var salt = null;\n  if (options.salt) {\n    salt = arrayify(options.salt);\n  } else {\n    salt = randomBytes(32);\n    ;\n  }\n  // Override initialization vector\n  var iv = null;\n  if (options.iv) {\n    iv = arrayify(options.iv);\n    if (iv.length !== 16) {\n      throw new Error(\"invalid iv\");\n    }\n  } else {\n    iv = randomBytes(16);\n  }\n  // Override the uuid\n  var uuidRandom = null;\n  if (options.uuid) {\n    uuidRandom = arrayify(options.uuid);\n    if (uuidRandom.length !== 16) {\n      throw new Error(\"invalid uuid\");\n    }\n  } else {\n    uuidRandom = randomBytes(16);\n  }\n  // Override the scrypt password-based key derivation function parameters\n  var N = 1 << 17,\n    r = 8,\n    p = 1;\n  if (options.scrypt) {\n    if (options.scrypt.N) {\n      N = options.scrypt.N;\n    }\n    if (options.scrypt.r) {\n      r = options.scrypt.r;\n    }\n    if (options.scrypt.p) {\n      p = options.scrypt.p;\n    }\n  }\n  // We take 64 bytes:\n  //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n  //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n  return scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then(function (key) {\n    key = arrayify(key);\n    // This will be used to encrypt the wallet (as per Web3 secret storage)\n    var derivedKey = key.slice(0, 16);\n    var macPrefix = key.slice(16, 32);\n    // This will be used to encrypt the mnemonic phrase (if any)\n    var mnemonicKey = key.slice(32, 64);\n    // Encrypt the private key\n    var counter = new aes.Counter(iv);\n    var aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);\n    var ciphertext = arrayify(aesCtr.encrypt(privateKey));\n    // Compute the message authentication code, used to check the password\n    var mac = keccak256(concat([macPrefix, ciphertext]));\n    // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n    var data = {\n      address: account.address.substring(2).toLowerCase(),\n      id: uuidV4(uuidRandom),\n      version: 3,\n      Crypto: {\n        cipher: \"aes-128-ctr\",\n        cipherparams: {\n          iv: hexlify(iv).substring(2)\n        },\n        ciphertext: hexlify(ciphertext).substring(2),\n        kdf: \"scrypt\",\n        kdfparams: {\n          salt: hexlify(salt).substring(2),\n          n: N,\n          dklen: 32,\n          p: p,\n          r: r\n        },\n        mac: mac.substring(2)\n      }\n    };\n    // If we have a mnemonic, encrypt it into the JSON wallet\n    if (entropy) {\n      var mnemonicIv = randomBytes(16);\n      var mnemonicCounter = new aes.Counter(mnemonicIv);\n      var mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n      var mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));\n      var now = new Date();\n      var timestamp = now.getUTCFullYear() + \"-\" + zpad(now.getUTCMonth() + 1, 2) + \"-\" + zpad(now.getUTCDate(), 2) + \"T\" + zpad(now.getUTCHours(), 2) + \"-\" + zpad(now.getUTCMinutes(), 2) + \"-\" + zpad(now.getUTCSeconds(), 2) + \".0Z\";\n      data[\"x-ethers\"] = {\n        client: client,\n        gethFilename: \"UTC--\" + timestamp + \"--\" + data.address,\n        mnemonicCounter: hexlify(mnemonicIv).substring(2),\n        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\n        path: path,\n        locale: locale,\n        version: \"0.1\"\n      };\n    }\n    return JSON.stringify(data);\n  });\n}","map":{"version":3,"sources":["../src.ts/keystore.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport aes from \"aes-js\";\nimport scrypt from \"scrypt-js\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { arrayify, concat, hexlify } from \"@ethersproject/bytes\";\nimport { defaultPath, entropyToMnemonic, HDNode, mnemonicToEntropy } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { pbkdf2 as _pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { Description } from \"@ethersproject/properties\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { getPassword, looseArrayify, searchPath, uuidV4, zpad } from \"./utils\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n// Exported Types\nfunction hasMnemonic(value) {\n    return (value != null && value.mnemonic && value.mnemonic.phrase);\n}\nexport class KeystoreAccount extends Description {\n    isKeystoreAccount(value) {\n        return !!(value && value._isKeystoreAccount);\n    }\n}\nfunction _decrypt(data, key, ciphertext) {\n    const cipher = searchPath(data, \"crypto/cipher\");\n    if (cipher === \"aes-128-ctr\") {\n        const iv = looseArrayify(searchPath(data, \"crypto/cipherparams/iv\"));\n        const counter = new aes.Counter(iv);\n        const aesCtr = new aes.ModeOfOperation.ctr(key, counter);\n        return arrayify(aesCtr.decrypt(ciphertext));\n    }\n    return null;\n}\nfunction _getAccount(data, key) {\n    const ciphertext = looseArrayify(searchPath(data, \"crypto/ciphertext\"));\n    const computedMAC = hexlify(keccak256(concat([key.slice(16, 32), ciphertext]))).substring(2);\n    if (computedMAC !== searchPath(data, \"crypto/mac\").toLowerCase()) {\n        throw new Error(\"invalid password\");\n    }\n    const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);\n    if (!privateKey) {\n        logger.throwError(\"unsupported cipher\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"decrypt\"\n        });\n    }\n    const mnemonicKey = key.slice(32, 64);\n    const address = computeAddress(privateKey);\n    if (data.address) {\n        let check = data.address.toLowerCase();\n        if (check.substring(0, 2) !== \"0x\") {\n            check = \"0x\" + check;\n        }\n        if (getAddress(check) !== address) {\n            throw new Error(\"address mismatch\");\n        }\n    }\n    const account = {\n        _isKeystoreAccount: true,\n        address: address,\n        privateKey: hexlify(privateKey)\n    };\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n    if (searchPath(data, \"x-ethers/version\") === \"0.1\") {\n        const mnemonicCiphertext = looseArrayify(searchPath(data, \"x-ethers/mnemonicCiphertext\"));\n        const mnemonicIv = looseArrayify(searchPath(data, \"x-ethers/mnemonicCounter\"));\n        const mnemonicCounter = new aes.Counter(mnemonicIv);\n        const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n        const path = searchPath(data, \"x-ethers/path\") || defaultPath;\n        const locale = searchPath(data, \"x-ethers/locale\") || \"en\";\n        const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\n        try {\n            const mnemonic = entropyToMnemonic(entropy, locale);\n            const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);\n            if (node.privateKey != account.privateKey) {\n                throw new Error(\"mnemonic mismatch\");\n            }\n            account.mnemonic = node.mnemonic;\n        }\n        catch (error) {\n            // If we don't have the locale wordlist installed to\n            // read this mnemonic, just bail and don't set the\n            // mnemonic\n            if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== \"wordlist\") {\n                throw error;\n            }\n        }\n    }\n    return new KeystoreAccount(account);\n}\nfunction pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {\n    return arrayify(_pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));\n}\nfunction pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {\n    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));\n}\nfunction _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {\n    const passwordBytes = getPassword(password);\n    const kdf = searchPath(data, \"crypto/kdf\");\n    if (kdf && typeof (kdf) === \"string\") {\n        const throwError = function (name, value) {\n            return logger.throwArgumentError(\"invalid key-derivation function parameters\", name, value);\n        };\n        if (kdf.toLowerCase() === \"scrypt\") {\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n            const N = parseInt(searchPath(data, \"crypto/kdfparams/n\"));\n            const r = parseInt(searchPath(data, \"crypto/kdfparams/r\"));\n            const p = parseInt(searchPath(data, \"crypto/kdfparams/p\"));\n            // Check for all required parameters\n            if (!N || !r || !p) {\n                throwError(\"kdf\", kdf);\n            }\n            // Make sure N is a power of 2\n            if ((N & (N - 1)) !== 0) {\n                throwError(\"N\", N);\n            }\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n            if (dkLen !== 32) {\n                throwError(\"dklen\", dkLen);\n            }\n            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);\n        }\n        else if (kdf.toLowerCase() === \"pbkdf2\") {\n            const salt = looseArrayify(searchPath(data, \"crypto/kdfparams/salt\"));\n            let prfFunc = null;\n            const prf = searchPath(data, \"crypto/kdfparams/prf\");\n            if (prf === \"hmac-sha256\") {\n                prfFunc = \"sha256\";\n            }\n            else if (prf === \"hmac-sha512\") {\n                prfFunc = \"sha512\";\n            }\n            else {\n                throwError(\"prf\", prf);\n            }\n            const count = parseInt(searchPath(data, \"crypto/kdfparams/c\"));\n            const dkLen = parseInt(searchPath(data, \"crypto/kdfparams/dklen\"));\n            if (dkLen !== 32) {\n                throwError(\"dklen\", dkLen);\n            }\n            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);\n        }\n    }\n    return logger.throwArgumentError(\"unsupported key-derivation function\", \"kdf\", kdf);\n}\nexport function decryptSync(json, password) {\n    const data = JSON.parse(json);\n    const key = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);\n    return _getAccount(data, key);\n}\nexport function decrypt(json, password, progressCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const data = JSON.parse(json);\n        const key = yield _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);\n        return _getAccount(data, key);\n    });\n}\nexport function encrypt(account, password, options, progressCallback) {\n    try {\n        // Check the address matches the private key\n        if (getAddress(account.address) !== computeAddress(account.privateKey)) {\n            throw new Error(\"address/privateKey mismatch\");\n        }\n        // Check the mnemonic (if any) matches the private key\n        if (hasMnemonic(account)) {\n            const mnemonic = account.mnemonic;\n            const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);\n            if (node.privateKey != account.privateKey) {\n                throw new Error(\"mnemonic mismatch\");\n            }\n        }\n    }\n    catch (e) {\n        return Promise.reject(e);\n    }\n    // The options are optional, so adjust the call as needed\n    if (typeof (options) === \"function\" && !progressCallback) {\n        progressCallback = options;\n        options = {};\n    }\n    if (!options) {\n        options = {};\n    }\n    const privateKey = arrayify(account.privateKey);\n    const passwordBytes = getPassword(password);\n    let entropy = null;\n    let path = null;\n    let locale = null;\n    if (hasMnemonic(account)) {\n        const srcMnemonic = account.mnemonic;\n        entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || \"en\"));\n        path = srcMnemonic.path || defaultPath;\n        locale = srcMnemonic.locale || \"en\";\n    }\n    let client = options.client;\n    if (!client) {\n        client = \"ethers.js\";\n    }\n    // Check/generate the salt\n    let salt = null;\n    if (options.salt) {\n        salt = arrayify(options.salt);\n    }\n    else {\n        salt = randomBytes(32);\n        ;\n    }\n    // Override initialization vector\n    let iv = null;\n    if (options.iv) {\n        iv = arrayify(options.iv);\n        if (iv.length !== 16) {\n            throw new Error(\"invalid iv\");\n        }\n    }\n    else {\n        iv = randomBytes(16);\n    }\n    // Override the uuid\n    let uuidRandom = null;\n    if (options.uuid) {\n        uuidRandom = arrayify(options.uuid);\n        if (uuidRandom.length !== 16) {\n            throw new Error(\"invalid uuid\");\n        }\n    }\n    else {\n        uuidRandom = randomBytes(16);\n    }\n    // Override the scrypt password-based key derivation function parameters\n    let N = (1 << 17), r = 8, p = 1;\n    if (options.scrypt) {\n        if (options.scrypt.N) {\n            N = options.scrypt.N;\n        }\n        if (options.scrypt.r) {\n            r = options.scrypt.r;\n        }\n        if (options.scrypt.p) {\n            p = options.scrypt.p;\n        }\n    }\n    // We take 64 bytes:\n    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n    return scrypt.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then((key) => {\n        key = arrayify(key);\n        // This will be used to encrypt the wallet (as per Web3 secret storage)\n        const derivedKey = key.slice(0, 16);\n        const macPrefix = key.slice(16, 32);\n        // This will be used to encrypt the mnemonic phrase (if any)\n        const mnemonicKey = key.slice(32, 64);\n        // Encrypt the private key\n        const counter = new aes.Counter(iv);\n        const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);\n        const ciphertext = arrayify(aesCtr.encrypt(privateKey));\n        // Compute the message authentication code, used to check the password\n        const mac = keccak256(concat([macPrefix, ciphertext]));\n        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n        const data = {\n            address: account.address.substring(2).toLowerCase(),\n            id: uuidV4(uuidRandom),\n            version: 3,\n            Crypto: {\n                cipher: \"aes-128-ctr\",\n                cipherparams: {\n                    iv: hexlify(iv).substring(2),\n                },\n                ciphertext: hexlify(ciphertext).substring(2),\n                kdf: \"scrypt\",\n                kdfparams: {\n                    salt: hexlify(salt).substring(2),\n                    n: N,\n                    dklen: 32,\n                    p: p,\n                    r: r\n                },\n                mac: mac.substring(2)\n            }\n        };\n        // If we have a mnemonic, encrypt it into the JSON wallet\n        if (entropy) {\n            const mnemonicIv = randomBytes(16);\n            const mnemonicCounter = new aes.Counter(mnemonicIv);\n            const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n            const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));\n            const now = new Date();\n            const timestamp = (now.getUTCFullYear() + \"-\" +\n                zpad(now.getUTCMonth() + 1, 2) + \"-\" +\n                zpad(now.getUTCDate(), 2) + \"T\" +\n                zpad(now.getUTCHours(), 2) + \"-\" +\n                zpad(now.getUTCMinutes(), 2) + \"-\" +\n                zpad(now.getUTCSeconds(), 2) + \".0Z\");\n            data[\"x-ethers\"] = {\n                client: client,\n                gethFilename: (\"UTC--\" + timestamp + \"--\" + data.address),\n                mnemonicCounter: hexlify(mnemonicIv).substring(2),\n                mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\n                path: path,\n                locale: locale,\n                version: \"0.1\"\n            };\n        }\n        return JSON.stringify(data);\n    });\n}\n//# sourceMappingURL=keystore.js.map"]},"metadata":{},"sourceType":"module"}