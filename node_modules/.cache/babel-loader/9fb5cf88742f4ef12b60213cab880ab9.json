{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nvar errors_1 = require(\"../errors\");\nvar codegen_1 = require(\"../codegen\");\nvar names_1 = require(\"../names\");\nvar boolError = {\n  message: \"boolean schema is false\"\n};\nfunction topBoolOrEmptySchema(it) {\n  var gen = it.gen,\n    schema = it.schema,\n    validateName = it.validateName;\n  if (schema === false) {\n    falseSchemaError(it, false);\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(names_1.default.data);\n  } else {\n    gen.assign((0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \".errors\"])), validateName), null);\n    gen.return(true);\n  }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n  var gen = it.gen,\n    schema = it.schema;\n  if (schema === false) {\n    gen.var(valid, false); // TODO var\n    falseSchemaError(it);\n  } else {\n    gen.var(valid, true); // TODO var\n  }\n}\n\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n  var gen = it.gen,\n    data = it.data;\n  // TODO maybe some other interface should be used for non-keyword validation errors...\n  var cxt = {\n    gen: gen,\n    keyword: \"false schema\",\n    data: data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it: it\n  };\n  (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}","map":{"version":3,"sources":["../../../lib/compile/validate/boolSchema.ts"],"names":[],"mappings":";;;;;;;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,YAAA,CAAA;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;AAEA,IAAM,SAAS,GAA2B;EACxC,OAAO,EAAE;CACV;AAED,SAAgB,oBAAoB,CAAC,EAAa,EAAA;EAChD,IAAO,GAAG,GAA0B,EAAE,CAA/B,GAAG;IAAE,MAAM,GAAkB,EAAE,CAA1B,MAAM;IAAE,YAAY,GAAI,EAAE,CAAlB,YAAY;EAChC,IAAI,MAAM,KAAK,KAAK,EAAE;IACpB,gBAAgB,CAAC,EAAE,EAAE,KAAK,CAAC;GAC5B,MAAM,IAAI,OAAO,MAAM,IAAI,QAAQ,IAAI,MAAM,CAAC,MAAM,KAAK,IAAI,EAAE;IAC9D,GAAG,CAAC,MAAM,CAAC,OAAA,CAAA,OAAC,CAAC,IAAI,CAAC;GACnB,MAAM;IACL,GAAG,CAAC,MAAM,EAAC,CAAA,EAAA,SAAA,CAAA,CAAC,kFAAG,YAAY,GAAW,IAAI,CAAC;IAC3C,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC;EACjB;AACH;AAVA,OAAA,CAAA,oBAAA,GAAA,oBAAA;AAYA,SAAgB,iBAAiB,CAAC,EAAa,EAAE,KAAW,EAAA;EAC1D,IAAO,GAAG,GAAY,EAAE,CAAjB,GAAG;IAAE,MAAM,GAAI,EAAE,CAAZ,MAAM;EAClB,IAAI,MAAM,KAAK,KAAK,EAAE;IACpB,GAAG,CAAC,GAAG,CAAC,KAAK,EAAE,KAAK,CAAC,CAAA,CAAC;IACtB,gBAAgB,CAAC,EAAE,CAAC;GACrB,MAAM;IACL,GAAG,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA,CAAC;EACtB;AACH;;AARA,OAAA,CAAA,iBAAA,GAAA,iBAAA;AAUA,SAAS,gBAAgB,CAAC,EAAa,EAAE,iBAA2B,EAAA;EAClE,IAAO,GAAG,GAAU,EAAE,CAAf,GAAG;IAAE,IAAI,GAAI,EAAE,CAAV,IAAI;EAChB;EACA,IAAM,GAAG,GAAoB;IAC3B,GAAG,EAAH,GAAG;IACH,OAAO,EAAE,cAAc;IACvB,IAAI,EAAJ,IAAI;IACJ,MAAM,EAAE,KAAK;IACb,UAAU,EAAE,KAAK;IACjB,WAAW,EAAE,KAAK;IAClB,MAAM,EAAE,CAAA,CAAE;IACV,EAAE,EAAF;GACD;EACD,CAAA,CAAA,EAAA,QAAA,CAAA,WAAW,EAAC,GAAG,EAAE,SAAS,EAAE,SAAS,EAAE,iBAAiB,CAAC;AAC3D","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst boolError = {\n    message: \"boolean schema is false\",\n};\nfunction topBoolOrEmptySchema(it) {\n    const { gen, schema, validateName } = it;\n    if (schema === false) {\n        falseSchemaError(it, false);\n    }\n    else if (typeof schema == \"object\" && schema.$async === true) {\n        gen.return(names_1.default.data);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, null);\n        gen.return(true);\n    }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n    const { gen, schema } = it;\n    if (schema === false) {\n        gen.var(valid, false); // TODO var\n        falseSchemaError(it);\n    }\n    else {\n        gen.var(valid, true); // TODO var\n    }\n}\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n    const { gen, data } = it;\n    // TODO maybe some other interface should be used for non-keyword validation errors...\n    const cxt = {\n        gen,\n        keyword: \"false schema\",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it,\n    };\n    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}\n//# sourceMappingURL=boolSchema.js.map"]},"metadata":{},"sourceType":"script"}