{"ast":null,"code":"\"use strict\";\n\nimport _createClass from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _regeneratorRuntime from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nexport function defineReadOnly(object, name, value) {\n  Object.defineProperty(object, name, {\n    enumerable: true,\n    value: value,\n    writable: false\n  });\n}\n// Crawl up the constructor chain to find a static method\nexport function getStatic(ctor, key) {\n  for (var i = 0; i < 32; i++) {\n    if (ctor[key]) {\n      return ctor[key];\n    }\n    if (!ctor.prototype || typeof ctor.prototype !== \"object\") {\n      break;\n    }\n    ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n  }\n  return null;\n}\nexport function resolveProperties(object) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var promises, results;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            promises = Object.keys(object).map(function (key) {\n              var value = object[key];\n              return Promise.resolve(value).then(function (v) {\n                return {\n                  key: key,\n                  value: v\n                };\n              });\n            });\n            _context.next = 3;\n            return Promise.all(promises);\n          case 3:\n            results = _context.sent;\n            return _context.abrupt(\"return\", results.reduce(function (accum, result) {\n              accum[result.key] = result.value;\n              return accum;\n            }, {}));\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\nexport function checkProperties(object, properties) {\n  if (!object || typeof object !== \"object\") {\n    logger.throwArgumentError(\"invalid object\", \"object\", object);\n  }\n  Object.keys(object).forEach(function (key) {\n    if (!properties[key]) {\n      logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n    }\n  });\n}\nexport function shallowCopy(object) {\n  var result = {};\n  for (var key in object) {\n    result[key] = object[key];\n  }\n  return result;\n}\nvar opaque = {\n  bigint: true,\n  boolean: true,\n  \"function\": true,\n  number: true,\n  string: true\n};\nfunction _isFrozen(object) {\n  // Opaque objects are not mutable, so safe to copy by assignment\n  if (object === undefined || object === null || opaque[typeof object]) {\n    return true;\n  }\n  if (Array.isArray(object) || typeof object === \"object\") {\n    if (!Object.isFrozen(object)) {\n      return false;\n    }\n    var keys = Object.keys(object);\n    for (var i = 0; i < keys.length; i++) {\n      var value = null;\n      try {\n        value = object[keys[i]];\n      } catch (error) {\n        // If accessing a value triggers an error, it is a getter\n        // designed to do so (e.g. Result) and is therefore \"frozen\"\n        continue;\n      }\n      if (!_isFrozen(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return logger.throwArgumentError(\"Cannot deepCopy \".concat(typeof object), \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n  if (_isFrozen(object)) {\n    return object;\n  }\n  // Arrays are mutable, so we need to create a copy\n  if (Array.isArray(object)) {\n    return Object.freeze(object.map(function (item) {\n      return deepCopy(item);\n    }));\n  }\n  if (typeof object === \"object\") {\n    var result = {};\n    for (var key in object) {\n      var value = object[key];\n      if (value === undefined) {\n        continue;\n      }\n      defineReadOnly(result, key, deepCopy(value));\n    }\n    return result;\n  }\n  return logger.throwArgumentError(\"Cannot deepCopy \".concat(typeof object), \"object\", object);\n}\nexport function deepCopy(object) {\n  return _deepCopy(object);\n}\nexport var Description = /*#__PURE__*/_createClass(function Description(info) {\n  _classCallCheck(this, Description);\n  for (var key in info) {\n    this[key] = deepCopy(info[key]);\n  }\n});","map":{"version":3,"sources":["../src.ts/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport function defineReadOnly(object, name, value) {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n// Crawl up the constructor chain to find a static method\nexport function getStatic(ctor, key) {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) {\n            return ctor[key];\n        }\n        if (!ctor.prototype || typeof (ctor.prototype) !== \"object\") {\n            break;\n        }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\nexport function resolveProperties(object) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const promises = Object.keys(object).map((key) => {\n            const value = object[key];\n            return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n        });\n        const results = yield Promise.all(promises);\n        return results.reduce((accum, result) => {\n            accum[(result.key)] = result.value;\n            return accum;\n        }, {});\n    });\n}\nexport function checkProperties(object, properties) {\n    if (!object || typeof (object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\nexport function shallowCopy(object) {\n    const result = {};\n    for (const key in object) {\n        result[key] = object[key];\n    }\n    return result;\n}\nconst opaque = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\nfunction _isFrozen(object) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof (object)]) {\n        return true;\n    }\n    if (Array.isArray(object) || typeof (object) === \"object\") {\n        if (!Object.isFrozen(object)) {\n            return false;\n        }\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value = null;\n            try {\n                value = object[keys[i]];\n            }\n            catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n            if (!_isFrozen(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n    if (_isFrozen(object)) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n    if (typeof (object) === \"object\") {\n        const result = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n        return result;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\nexport function deepCopy(object) {\n    return _deepCopy(object);\n}\nexport class Description {\n    constructor(info) {\n        for (const key in info) {\n            this[key] = deepCopy(info[key]);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}