{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _taggedTemplateLiteral = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar codegen_1 = require(\"../../compile/codegen\");\nvar types_1 = require(\"../discriminator/types\");\nvar compile_1 = require(\"../../compile\");\nvar util_1 = require(\"../../compile/util\");\nvar error = {\n  message: function message(_ref) {\n    var _ref$params = _ref.params,\n      discrError = _ref$params.discrError,\n      tagName = _ref$params.tagName;\n    return discrError === types_1.DiscrError.Tag ? \"tag \\\"\".concat(tagName, \"\\\" must be string\") : \"value of tag \\\"\".concat(tagName, \"\\\" must be in oneOf\");\n  },\n  params: function params(_ref2) {\n    var _ref2$params = _ref2.params,\n      discrError = _ref2$params.discrError,\n      tag = _ref2$params.tag,\n      tagName = _ref2$params.tagName;\n    return (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"{error: \", \", tag: \", \", tagValue: \", \"}\"])), discrError, tagName, tag);\n  }\n};\nvar def = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error: error,\n  code: function code(cxt) {\n    var gen = cxt.gen,\n      data = cxt.data,\n      schema = cxt.schema,\n      parentSchema = cxt.parentSchema,\n      it = cxt.it;\n    var oneOf = parentSchema.oneOf;\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\");\n    }\n    var tagName = schema.propertyName;\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\");\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\");\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\");\n    var valid = gen.let(\"valid\", false);\n    var tag = gen.const(\"tag\", (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \"\", \"\"])), data, (0, codegen_1.getProperty)(tagName)));\n    gen.if((0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"typeof \", \" == \\\"string\\\"\"])), tag), function () {\n      return validateMapping();\n    }, function () {\n      return cxt.error(false, {\n        discrError: types_1.DiscrError.Tag,\n        tag: tag,\n        tagName: tagName\n      });\n    });\n    cxt.ok(valid);\n    function validateMapping() {\n      var mapping = getMapping();\n      gen.if(false);\n      for (var tagValue in mapping) {\n        gen.elseIf((0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), tag, tagValue));\n        gen.assign(valid, applyTagSchema(mapping[tagValue]));\n      }\n      gen.else();\n      cxt.error(false, {\n        discrError: types_1.DiscrError.Mapping,\n        tag: tag,\n        tagName: tagName\n      });\n      gen.endIf();\n    }\n    function applyTagSchema(schemaProp) {\n      var _valid = gen.name(\"valid\");\n      var schCxt = cxt.subschema({\n        keyword: \"oneOf\",\n        schemaProp: schemaProp\n      }, _valid);\n      cxt.mergeEvaluated(schCxt, codegen_1.Name);\n      return _valid;\n    }\n    function getMapping() {\n      var _a;\n      var oneOfMapping = {};\n      var topRequired = hasRequired(parentSchema);\n      var tagRequired = true;\n      for (var i = 0; i < oneOf.length; i++) {\n        var sch = oneOf[i];\n        if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n          sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);\n          if (sch instanceof compile_1.SchemaEnv) sch = sch.schema;\n        }\n        var propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n        if (typeof propSch != \"object\") {\n          throw new Error(\"discriminator: oneOf subschemas (or referenced schemas) must have \\\"properties/\".concat(tagName, \"\\\"\"));\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch));\n        addMappings(propSch, i);\n      }\n      if (!tagRequired) throw new Error(\"discriminator: \\\"\".concat(tagName, \"\\\" must be required\"));\n      return oneOfMapping;\n      function hasRequired(_ref3) {\n        var required = _ref3.required;\n        return Array.isArray(required) && required.includes(tagName);\n      }\n      function addMappings(sch, i) {\n        if (sch.const) {\n          addMapping(sch.const, i);\n        } else if (sch.enum) {\n          var _iterator = _createForOfIteratorHelper(sch.enum),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var tagValue = _step.value;\n              addMapping(tagValue, i);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } else {\n          throw new Error(\"discriminator: \\\"properties/\".concat(tagName, \"\\\" must have \\\"const\\\" or \\\"enum\\\"\"));\n        }\n      }\n      function addMapping(tagValue, i) {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(\"discriminator: \\\"\".concat(tagName, \"\\\" values must be unique strings\"));\n        }\n        oneOfMapping[tagValue] = i;\n      }\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/discriminator/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst types_1 = require(\"../discriminator/types\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag\n        ? `tag \"${tagName}\" must be string`\n        : `value of tag \"${tagName}\" must be in oneOf`,\n    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n};\nconst def = {\n    keyword: \"discriminator\",\n    type: \"object\",\n    schemaType: \"object\",\n    error,\n    code(cxt) {\n        const { gen, data, schema, parentSchema, it } = cxt;\n        const { oneOf } = parentSchema;\n        if (!it.opts.discriminator) {\n            throw new Error(\"discriminator: requires discriminator option\");\n        }\n        const tagName = schema.propertyName;\n        if (typeof tagName != \"string\")\n            throw new Error(\"discriminator: requires propertyName\");\n        if (schema.mapping)\n            throw new Error(\"discriminator: mapping is not supported\");\n        if (!oneOf)\n            throw new Error(\"discriminator: requires oneOf keyword\");\n        const valid = gen.let(\"valid\", false);\n        const tag = gen.const(\"tag\", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);\n        gen.if((0, codegen_1._) `typeof ${tag} == \"string\"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));\n        cxt.ok(valid);\n        function validateMapping() {\n            const mapping = getMapping();\n            gen.if(false);\n            for (const tagValue in mapping) {\n                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);\n                gen.assign(valid, applyTagSchema(mapping[tagValue]));\n            }\n            gen.else();\n            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });\n            gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n            const _valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({ keyword: \"oneOf\", schemaProp }, _valid);\n            cxt.mergeEvaluated(schCxt, codegen_1.Name);\n            return _valid;\n        }\n        function getMapping() {\n            var _a;\n            const oneOfMapping = {};\n            const topRequired = hasRequired(parentSchema);\n            let tagRequired = true;\n            for (let i = 0; i < oneOf.length; i++) {\n                let sch = oneOf[i];\n                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);\n                    if (sch instanceof compile_1.SchemaEnv)\n                        sch = sch.schema;\n                }\n                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n                if (typeof propSch != \"object\") {\n                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`);\n                }\n                tagRequired = tagRequired && (topRequired || hasRequired(sch));\n                addMappings(propSch, i);\n            }\n            if (!tagRequired)\n                throw new Error(`discriminator: \"${tagName}\" must be required`);\n            return oneOfMapping;\n            function hasRequired({ required }) {\n                return Array.isArray(required) && required.includes(tagName);\n            }\n            function addMappings(sch, i) {\n                if (sch.const) {\n                    addMapping(sch.const, i);\n                }\n                else if (sch.enum) {\n                    for (const tagValue of sch.enum) {\n                        addMapping(tagValue, i);\n                    }\n                }\n                else {\n                    throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`);\n                }\n            }\n            function addMapping(tagValue, i) {\n                if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n                    throw new Error(`discriminator: \"${tagName}\" values must be unique strings`);\n                }\n                oneOfMapping[tagValue] = i;\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}