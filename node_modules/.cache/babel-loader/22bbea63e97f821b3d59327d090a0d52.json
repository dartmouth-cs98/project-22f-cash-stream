{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.callRef = exports.getValidate = void 0;\nvar ref_error_1 = require(\"../../compile/ref_error\");\nvar code_1 = require(\"../code\");\nvar codegen_1 = require(\"../../compile/codegen\");\nvar names_1 = require(\"../../compile/names\");\nvar compile_1 = require(\"../../compile\");\nvar util_1 = require(\"../../compile/util\");\nvar def = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code: function code(cxt) {\n    var gen = cxt.gen,\n      $ref = cxt.schema,\n      it = cxt.it;\n    var baseId = it.baseId,\n      env = it.schemaEnv,\n      validateName = it.validateName,\n      opts = it.opts,\n      self = it.self;\n    var root = env.root;\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef();\n    var schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n    if (schOrEnv === undefined) throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n    if (schOrEnv instanceof compile_1.SchemaEnv) return callValidate(schOrEnv);\n    return inlineRefSchema(schOrEnv);\n    function callRootRef() {\n      if (env === root) return callRef(cxt, validateName, env, env.$async);\n      var rootName = gen.scopeValue(\"root\", {\n        ref: root\n      });\n      return callRef(cxt, (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \".validate\"])), rootName), root, root.$async);\n    }\n    function callValidate(sch) {\n      var v = getValidate(cxt, sch);\n      callRef(cxt, v, sch, sch.$async);\n    }\n    function inlineRefSchema(sch) {\n      var schName = gen.scopeValue(\"schema\", opts.code.source === true ? {\n        ref: sch,\n        code: (0, codegen_1.stringify)(sch)\n      } : {\n        ref: sch\n      });\n      var valid = gen.name(\"valid\");\n      var schCxt = cxt.subschema({\n        schema: sch,\n        dataTypes: [],\n        schemaPath: codegen_1.nil,\n        topSchemaRef: schName,\n        errSchemaPath: $ref\n      }, valid);\n      cxt.mergeEvaluated(schCxt);\n      cxt.ok(valid);\n    }\n  }\n};\nfunction getValidate(cxt, sch) {\n  var gen = cxt.gen;\n  return sch.validate ? gen.scopeValue(\"validate\", {\n    ref: sch.validate\n  }) : (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \".validate\"])), gen.scopeValue(\"wrapper\", {\n    ref: sch\n  }));\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n  var gen = cxt.gen,\n    it = cxt.it;\n  var allErrors = it.allErrors,\n    env = it.schemaEnv,\n    opts = it.opts;\n  var passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n  if ($async) callAsyncRef();else callSyncRef();\n  function callAsyncRef() {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\");\n    var valid = gen.let(\"valid\");\n    gen.try(function () {\n      gen.code((0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"await \", \"\"])), (0, code_1.callValidateCode)(cxt, v, passCxt)));\n      addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n      if (!allErrors) gen.assign(valid, true);\n    }, function (e) {\n      gen.if((0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"!(\", \" instanceof \", \")\"])), e, it.ValidationError), function () {\n        return gen.throw(e);\n      });\n      addErrorsFrom(e);\n      if (!allErrors) gen.assign(valid, false);\n    });\n    cxt.ok(valid);\n  }\n  function callSyncRef() {\n    cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), function () {\n      return addEvaluatedFrom(v);\n    }, function () {\n      return addErrorsFrom(v);\n    });\n  }\n  function addErrorsFrom(source) {\n    var errs = (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \".errors\"])), source);\n    gen.assign(names_1.default.vErrors, (0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \" === null ? \", \" : \", \".concat(\", \")\"])), names_1.default.vErrors, errs, names_1.default.vErrors, errs)); // TODO tagged\n    gen.assign(names_1.default.errors, (0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \".length\"])), names_1.default.vErrors));\n  }\n  function addEvaluatedFrom(source) {\n    var _a;\n    if (!it.opts.unevaluated) return;\n    var schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n        }\n      } else {\n        var props = gen.var(\"props\", (0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \".evaluated.props\"])), source));\n        it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n        }\n      } else {\n        var items = gen.var(\"items\", (0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\", \".evaluated.items\"])), source));\n        it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n      }\n    }\n  }\n}\nexports.callRef = callRef;\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/core/ref.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self } = it;\n        const { root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId)\n            return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n        if (schOrEnv === undefined)\n            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n            return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n            if (env === root)\n                return callRef(cxt, validateName, env, env.$async);\n            const rootName = gen.scopeValue(\"root\", { ref: root });\n            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n            const v = getValidate(cxt, sch);\n            callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n            const schName = gen.scopeValue(\"schema\", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });\n            const valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({\n                schema: sch,\n                dataTypes: [],\n                schemaPath: codegen_1.nil,\n                topSchemaRef: schName,\n                errSchemaPath: $ref,\n            }, valid);\n            cxt.mergeEvaluated(schCxt);\n            cxt.ok(valid);\n        }\n    },\n};\nfunction getValidate(cxt, sch) {\n    const { gen } = cxt;\n    return sch.validate\n        ? gen.scopeValue(\"validate\", { ref: sch.validate })\n        : (0, codegen_1._) `${gen.scopeValue(\"wrapper\", { ref: sch })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n    const { gen, it } = cxt;\n    const { allErrors, schemaEnv: env, opts } = it;\n    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n    if ($async)\n        callAsyncRef();\n    else\n        callSyncRef();\n    function callAsyncRef() {\n        if (!env.$async)\n            throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(() => {\n            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n            if (!allErrors)\n                gen.assign(valid, true);\n        }, (e) => {\n            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n            addErrorsFrom(e);\n            if (!allErrors)\n                gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n    }\n    function callSyncRef() {\n        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n    }\n    function addErrorsFrom(source) {\n        const errs = (0, codegen_1._) `${source}.errors`;\n        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n    }\n    function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n            return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        // TODO refactor\n        if (it.props !== true) {\n            if (schEvaluated && !schEvaluated.dynamicProps) {\n                if (schEvaluated.props !== undefined) {\n                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n                }\n            }\n            else {\n                const props = gen.var(\"props\", (0, codegen_1._) `${source}.evaluated.props`);\n                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n            }\n        }\n        if (it.items !== true) {\n            if (schEvaluated && !schEvaluated.dynamicItems) {\n                if (schEvaluated.items !== undefined) {\n                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n                }\n            }\n            else {\n                const items = gen.var(\"items\", (0, codegen_1._) `${source}.evaluated.items`);\n                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n            }\n        }\n    }\n}\nexports.callRef = callRef;\nexports.default = def;\n//# sourceMappingURL=ref.js.map"]},"metadata":{},"sourceType":"script"}