{"ast":null,"code":"\"use strict\";\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\nimport { arrayify, hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nfunction arrayifyInteger(value) {\n  var result = [];\n  while (value) {\n    result.unshift(value & 0xff);\n    value >>= 8;\n  }\n  return result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n  var result = 0;\n  for (var i = 0; i < length; i++) {\n    result = result * 256 + data[offset + i];\n  }\n  return result;\n}\nfunction _encode(object) {\n  if (Array.isArray(object)) {\n    var payload = [];\n    object.forEach(function (child) {\n      payload = payload.concat(_encode(child));\n    });\n    if (payload.length <= 55) {\n      payload.unshift(0xc0 + payload.length);\n      return payload;\n    }\n    var _length = arrayifyInteger(payload.length);\n    _length.unshift(0xf7 + _length.length);\n    return _length.concat(payload);\n  }\n  if (!isBytesLike(object)) {\n    logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n  }\n  var data = Array.prototype.slice.call(arrayify(object));\n  if (data.length === 1 && data[0] <= 0x7f) {\n    return data;\n  } else if (data.length <= 55) {\n    data.unshift(0x80 + data.length);\n    return data;\n  }\n  var length = arrayifyInteger(data.length);\n  length.unshift(0xb7 + length.length);\n  return length.concat(data);\n}\nexport function encode(object) {\n  return hexlify(_encode(object));\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n  var result = [];\n  while (childOffset < offset + 1 + length) {\n    var decoded = _decode(data, childOffset);\n    result.push(decoded.result);\n    childOffset += decoded.consumed;\n    if (childOffset > offset + 1 + length) {\n      logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n  }\n  return {\n    consumed: 1 + length,\n    result: result\n  };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n  if (data.length === 0) {\n    logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n  }\n  // Array with extra length prefix\n  if (data[offset] >= 0xf8) {\n    var lengthLength = data[offset] - 0xf7;\n    if (offset + 1 + lengthLength > data.length) {\n      logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n    var length = unarrayifyInteger(data, offset + 1, lengthLength);\n    if (offset + 1 + lengthLength + length > data.length) {\n      logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n  } else if (data[offset] >= 0xc0) {\n    var _length2 = data[offset] - 0xc0;\n    if (offset + 1 + _length2 > data.length) {\n      logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n    return _decodeChildren(data, offset, offset + 1, _length2);\n  } else if (data[offset] >= 0xb8) {\n    var _lengthLength = data[offset] - 0xb7;\n    if (offset + 1 + _lengthLength > data.length) {\n      logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n    var _length3 = unarrayifyInteger(data, offset + 1, _lengthLength);\n    if (offset + 1 + _lengthLength + _length3 > data.length) {\n      logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n    var result = hexlify(data.slice(offset + 1 + _lengthLength, offset + 1 + _lengthLength + _length3));\n    return {\n      consumed: 1 + _lengthLength + _length3,\n      result: result\n    };\n  } else if (data[offset] >= 0x80) {\n    var _length4 = data[offset] - 0x80;\n    if (offset + 1 + _length4 > data.length) {\n      logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n    var _result = hexlify(data.slice(offset + 1, offset + 1 + _length4));\n    return {\n      consumed: 1 + _length4,\n      result: _result\n    };\n  }\n  return {\n    consumed: 1,\n    result: hexlify(data[offset])\n  };\n}\nexport function decode(data) {\n  var bytes = arrayify(data);\n  var decoded = _decode(bytes, 0);\n  if (decoded.consumed !== bytes.length) {\n    logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n  }\n  return decoded.result;\n}","map":{"version":3,"sources":["../src.ts/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n//See: https://github.com/ethereum/wiki/wiki/RLP\nimport { arrayify, hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction arrayifyInteger(value) {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function (child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    if (!isBytesLike(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n    const data = Array.prototype.slice.call(arrayify(object));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    }\n    else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nexport function encode(object) {\n    return hexlify(_encode(object));\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n    }\n    return { consumed: (1 + length), result: result };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    }\n    else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1, length);\n    }\n    else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result };\n    }\n    else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result };\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\nexport function decode(data) {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}