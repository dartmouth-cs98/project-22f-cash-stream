{"ast":null,"code":"import _regeneratorRuntime from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nimport { id } from \"./id\";\nvar padding = new Uint8Array(32);\npadding.fill(0);\nvar NegativeOne = BigNumber.from(-1);\nvar Zero = BigNumber.from(0);\nvar One = BigNumber.from(1);\nvar MaxUint256 = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction hexPadRight(value) {\n  var bytes = arrayify(value);\n  var padOffset = bytes.length % 32;\n  if (padOffset) {\n    return hexConcat([bytes, padding.slice(padOffset)]);\n  }\n  return hexlify(bytes);\n}\nvar hexTrue = hexZeroPad(One.toHexString(), 32);\nvar hexFalse = hexZeroPad(Zero.toHexString(), 32);\nvar domainFieldTypes = {\n  name: \"string\",\n  version: \"string\",\n  chainId: \"uint256\",\n  verifyingContract: \"address\",\n  salt: \"bytes32\"\n};\nvar domainFieldNames = [\"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"];\nfunction checkString(key) {\n  return function (value) {\n    if (typeof value !== \"string\") {\n      logger.throwArgumentError(\"invalid domain value for \".concat(JSON.stringify(key)), \"domain.\".concat(key), value);\n    }\n    return value;\n  };\n}\nvar domainChecks = {\n  name: checkString(\"name\"),\n  version: checkString(\"version\"),\n  chainId: function chainId(value) {\n    try {\n      return BigNumber.from(value).toString();\n    } catch (error) {}\n    return logger.throwArgumentError(\"invalid domain value for \\\"chainId\\\"\", \"domain.chainId\", value);\n  },\n  verifyingContract: function verifyingContract(value) {\n    try {\n      return getAddress(value).toLowerCase();\n    } catch (error) {}\n    return logger.throwArgumentError(\"invalid domain value \\\"verifyingContract\\\"\", \"domain.verifyingContract\", value);\n  },\n  salt: function salt(value) {\n    try {\n      var bytes = arrayify(value);\n      if (bytes.length !== 32) {\n        throw new Error(\"bad length\");\n      }\n      return hexlify(bytes);\n    } catch (error) {}\n    return logger.throwArgumentError(\"invalid domain value \\\"salt\\\"\", \"domain.salt\", value);\n  }\n};\nfunction getBaseEncoder(type) {\n  // intXX and uintXX\n  {\n    var match = type.match(/^(u?)int(\\d*)$/);\n    if (match) {\n      var signed = match[1] === \"\";\n      var width = parseInt(match[2] || \"256\");\n      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {\n        logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n      }\n      var boundsUpper = MaxUint256.mask(signed ? width - 1 : width);\n      var boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\n      return function (value) {\n        var v = BigNumber.from(value);\n        if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n          logger.throwArgumentError(\"value out-of-bounds for \".concat(type), \"value\", value);\n        }\n        return hexZeroPad(v.toTwos(256).toHexString(), 32);\n      };\n    }\n  }\n  // bytesXX\n  {\n    var _match = type.match(/^bytes(\\d+)$/);\n    if (_match) {\n      var _width = parseInt(_match[1]);\n      if (_width === 0 || _width > 32 || _match[1] !== String(_width)) {\n        logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n      }\n      return function (value) {\n        var bytes = arrayify(value);\n        if (bytes.length !== _width) {\n          logger.throwArgumentError(\"invalid length for \".concat(type), \"value\", value);\n        }\n        return hexPadRight(value);\n      };\n    }\n  }\n  switch (type) {\n    case \"address\":\n      return function (value) {\n        return hexZeroPad(getAddress(value), 32);\n      };\n    case \"bool\":\n      return function (value) {\n        return !value ? hexFalse : hexTrue;\n      };\n    case \"bytes\":\n      return function (value) {\n        return keccak256(value);\n      };\n    case \"string\":\n      return function (value) {\n        return id(value);\n      };\n  }\n  return null;\n}\nfunction encodeType(name, fields) {\n  return \"\".concat(name, \"(\").concat(fields.map(function (_ref) {\n    var name = _ref.name,\n      type = _ref.type;\n    return type + \" \" + name;\n  }).join(\",\"), \")\");\n}\nexport var TypedDataEncoder = /*#__PURE__*/function () {\n  function TypedDataEncoder(types) {\n    _classCallCheck(this, TypedDataEncoder);\n    defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n    defineReadOnly(this, \"_encoderCache\", {});\n    defineReadOnly(this, \"_types\", {});\n    // Link struct types to their direct child structs\n    var links = {};\n    // Link structs to structs which contain them as a child\n    var parents = {};\n    // Link all subtypes within a given struct\n    var subtypes = {};\n    Object.keys(types).forEach(function (type) {\n      links[type] = {};\n      parents[type] = [];\n      subtypes[type] = {};\n    });\n    var _loop = function _loop(name) {\n      var uniqueNames = {};\n      types[name].forEach(function (field) {\n        // Check each field has a unique name\n        if (uniqueNames[field.name]) {\n          logger.throwArgumentError(\"duplicate variable name \".concat(JSON.stringify(field.name), \" in \").concat(JSON.stringify(name)), \"types\", types);\n        }\n        uniqueNames[field.name] = true;\n        // Get the base type (drop any array specifiers)\n        var baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n        if (baseType === name) {\n          logger.throwArgumentError(\"circular type reference to \".concat(JSON.stringify(baseType)), \"types\", types);\n        }\n        // Is this a base encoding type?\n        var encoder = getBaseEncoder(baseType);\n        if (encoder) {\n          return;\n        }\n        if (!parents[baseType]) {\n          logger.throwArgumentError(\"unknown type \".concat(JSON.stringify(baseType)), \"types\", types);\n        }\n        // Add linkage\n        parents[baseType].push(name);\n        links[name][baseType] = true;\n      });\n    };\n    for (var name in types) {\n      _loop(name);\n    }\n    // Deduce the primary type\n    var primaryTypes = Object.keys(parents).filter(function (n) {\n      return parents[n].length === 0;\n    });\n    if (primaryTypes.length === 0) {\n      logger.throwArgumentError(\"missing primary type\", \"types\", types);\n    } else if (primaryTypes.length > 1) {\n      logger.throwArgumentError(\"ambiguous primary types or unused types: \".concat(primaryTypes.map(function (t) {\n        return JSON.stringify(t);\n      }).join(\", \")), \"types\", types);\n    }\n    defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n    // Check for circular type references\n    function checkCircular(type, found) {\n      if (found[type]) {\n        logger.throwArgumentError(\"circular type reference to \".concat(JSON.stringify(type)), \"types\", types);\n      }\n      found[type] = true;\n      Object.keys(links[type]).forEach(function (child) {\n        if (!parents[child]) {\n          return;\n        }\n        // Recursively check children\n        checkCircular(child, found);\n        // Mark all ancestors as having this decendant\n        Object.keys(found).forEach(function (subtype) {\n          subtypes[subtype][child] = true;\n        });\n      });\n      delete found[type];\n    }\n    checkCircular(this.primaryType, {});\n    // Compute each fully describe type\n    for (var _name in subtypes) {\n      var st = Object.keys(subtypes[_name]);\n      st.sort();\n      this._types[_name] = encodeType(_name, types[_name]) + st.map(function (t) {\n        return encodeType(t, types[t]);\n      }).join(\"\");\n    }\n  }\n  _createClass(TypedDataEncoder, [{\n    key: \"getEncoder\",\n    value: function getEncoder(type) {\n      var encoder = this._encoderCache[type];\n      if (!encoder) {\n        encoder = this._encoderCache[type] = this._getEncoder(type);\n      }\n      return encoder;\n    }\n  }, {\n    key: \"_getEncoder\",\n    value: function _getEncoder(type) {\n      var _this = this;\n      // Basic encoder type (address, bool, uint256, etc)\n      {\n        var encoder = getBaseEncoder(type);\n        if (encoder) {\n          return encoder;\n        }\n      }\n      // Array\n      var match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n      if (match) {\n        var subtype = match[1];\n        var subEncoder = this.getEncoder(subtype);\n        var length = parseInt(match[3]);\n        return function (value) {\n          if (length >= 0 && value.length !== length) {\n            logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n          }\n          var result = value.map(subEncoder);\n          if (_this._types[subtype]) {\n            result = result.map(keccak256);\n          }\n          return keccak256(hexConcat(result));\n        };\n      }\n      // Struct\n      var fields = this.types[type];\n      if (fields) {\n        var encodedType = id(this._types[type]);\n        return function (value) {\n          var values = fields.map(function (_ref2) {\n            var name = _ref2.name,\n              type = _ref2.type;\n            var result = _this.getEncoder(type)(value[name]);\n            if (_this._types[type]) {\n              return keccak256(result);\n            }\n            return result;\n          });\n          values.unshift(encodedType);\n          return hexConcat(values);\n        };\n      }\n      return logger.throwArgumentError(\"unknown type: \".concat(type), \"type\", type);\n    }\n  }, {\n    key: \"encodeType\",\n    value: function encodeType(name) {\n      var result = this._types[name];\n      if (!result) {\n        logger.throwArgumentError(\"unknown type: \".concat(JSON.stringify(name)), \"name\", name);\n      }\n      return result;\n    }\n  }, {\n    key: \"encodeData\",\n    value: function encodeData(type, value) {\n      return this.getEncoder(type)(value);\n    }\n  }, {\n    key: \"hashStruct\",\n    value: function hashStruct(name, value) {\n      return keccak256(this.encodeData(name, value));\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      return this.encodeData(this.primaryType, value);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash(value) {\n      return this.hashStruct(this.primaryType, value);\n    }\n  }, {\n    key: \"_visit\",\n    value: function _visit(type, value, callback) {\n      var _this2 = this;\n      // Basic encoder type (address, bool, uint256, etc)\n      {\n        var encoder = getBaseEncoder(type);\n        if (encoder) {\n          return callback(type, value);\n        }\n      }\n      // Array\n      var match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n      if (match) {\n        var subtype = match[1];\n        var length = parseInt(match[3]);\n        if (length >= 0 && value.length !== length) {\n          logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n        }\n        return value.map(function (v) {\n          return _this2._visit(subtype, v, callback);\n        });\n      }\n      // Struct\n      var fields = this.types[type];\n      if (fields) {\n        return fields.reduce(function (accum, _ref3) {\n          var name = _ref3.name,\n            type = _ref3.type;\n          accum[name] = _this2._visit(type, value[name], callback);\n          return accum;\n        }, {});\n      }\n      return logger.throwArgumentError(\"unknown type: \".concat(type), \"type\", type);\n    }\n  }, {\n    key: \"visit\",\n    value: function visit(value, callback) {\n      return this._visit(this.primaryType, value, callback);\n    }\n  }], [{\n    key: \"from\",\n    value: function from(types) {\n      return new TypedDataEncoder(types);\n    }\n  }, {\n    key: \"getPrimaryType\",\n    value: function getPrimaryType(types) {\n      return TypedDataEncoder.from(types).primaryType;\n    }\n  }, {\n    key: \"hashStruct\",\n    value: function hashStruct(name, types, value) {\n      return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n  }, {\n    key: \"hashDomain\",\n    value: function hashDomain(domain) {\n      var domainFields = [];\n      for (var name in domain) {\n        var type = domainFieldTypes[name];\n        if (!type) {\n          logger.throwArgumentError(\"invalid typed-data domain key: \".concat(JSON.stringify(name)), \"domain\", domain);\n        }\n        domainFields.push({\n          name: name,\n          type: type\n        });\n      }\n      domainFields.sort(function (a, b) {\n        return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n      });\n      return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n        EIP712Domain: domainFields\n      }, domain);\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(domain, types, value) {\n      return hexConcat([\"0x1901\", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash(domain, types, value) {\n      return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n  }, {\n    key: \"resolveNames\",\n    value: function resolveNames(domain, types, value, resolveName) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var ensCache, encoder, name;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // Make a copy to isolate it from the object passed in\n                domain = shallowCopy(domain);\n                // Look up all ENS names\n                ensCache = {}; // Do we need to look up the domain's verifyingContract?\n                if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n                  ensCache[domain.verifyingContract] = \"0x\";\n                }\n                // We are going to use the encoder to visit all the base values\n                encoder = TypedDataEncoder.from(types); // Get a list of all the addresses\n                encoder.visit(value, function (type, value) {\n                  if (type === \"address\" && !isHexString(value, 20)) {\n                    ensCache[value] = \"0x\";\n                  }\n                  return value;\n                });\n                // Lookup each name\n                _context.t0 = _regeneratorRuntime().keys(ensCache);\n              case 6:\n                if ((_context.t1 = _context.t0()).done) {\n                  _context.next = 13;\n                  break;\n                }\n                name = _context.t1.value;\n                _context.next = 10;\n                return resolveName(name);\n              case 10:\n                ensCache[name] = _context.sent;\n                _context.next = 6;\n                break;\n              case 13:\n                // Replace the domain verifyingContract if needed\n                if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n                  domain.verifyingContract = ensCache[domain.verifyingContract];\n                }\n                // Replace all ENS names with their address\n                value = encoder.visit(value, function (type, value) {\n                  if (type === \"address\" && ensCache[value]) {\n                    return ensCache[value];\n                  }\n                  return value;\n                });\n                return _context.abrupt(\"return\", {\n                  domain: domain,\n                  value: value\n                });\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n    }\n  }, {\n    key: \"getPayload\",\n    value: function getPayload(domain, types, value) {\n      // Validate the domain fields\n      TypedDataEncoder.hashDomain(domain);\n      // Derive the EIP712Domain Struct reference type\n      var domainValues = {};\n      var domainTypes = [];\n      domainFieldNames.forEach(function (name) {\n        var value = domain[name];\n        if (value == null) {\n          return;\n        }\n        domainValues[name] = domainChecks[name](value);\n        domainTypes.push({\n          name: name,\n          type: domainFieldTypes[name]\n        });\n      });\n      var encoder = TypedDataEncoder.from(types);\n      var typesWithDomain = shallowCopy(types);\n      if (typesWithDomain.EIP712Domain) {\n        logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n      } else {\n        typesWithDomain.EIP712Domain = domainTypes;\n      }\n      // Validate the data structures and types\n      encoder.encode(value);\n      return {\n        types: typesWithDomain,\n        domain: domainValues,\n        primaryType: encoder.primaryType,\n        message: encoder.visit(value, function (type, value) {\n          // bytes\n          if (type.match(/^bytes(\\d*)/)) {\n            return hexlify(arrayify(value));\n          }\n          // uint or int\n          if (type.match(/^u?int/)) {\n            return BigNumber.from(value).toString();\n          }\n          switch (type) {\n            case \"address\":\n              return value.toLowerCase();\n            case \"bool\":\n              return !!value;\n            case \"string\":\n              if (typeof value !== \"string\") {\n                logger.throwArgumentError(\"invalid string\", \"value\", value);\n              }\n              return value;\n          }\n          return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n        })\n      };\n    }\n  }]);\n  return TypedDataEncoder;\n}();","map":{"version":3,"sources":["../src.ts/typed-data.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { id } from \"./id\";\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst NegativeOne = BigNumber.from(-1);\nconst Zero = BigNumber.from(0);\nconst One = BigNumber.from(1);\nconst MaxUint256 = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction hexPadRight(value) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return hexConcat([bytes, padding.slice(padOffset)]);\n    }\n    return hexlify(bytes);\n}\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\nfunction checkString(key) {\n    return function (value) {\n        if (typeof (value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        }\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function (value) {\n        try {\n            return BigNumber.from(value).toString();\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function (value) {\n        try {\n            return getAddress(value).toLowerCase();\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function (value) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) {\n                throw new Error(\"bad length\");\n            }\n            return hexlify(bytes);\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1) : width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\n            return function (value) {\n                const v = BigNumber.from(value);\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${type}`, \"value\", value);\n                }\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n            return function (value) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${type}`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch (type) {\n        case \"address\": return function (value) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function (value) {\n            return ((!value) ? hexFalse : hexTrue);\n        };\n        case \"bytes\": return function (value) {\n            return keccak256(value);\n        };\n        case \"string\": return function (value) {\n            return id(value);\n        };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type }) => (type + \" \" + name)).join(\",\")})`;\n}\nexport class TypedDataEncoder {\n    constructor(types) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n        defineReadOnly(this, \"_encoderCache\", {});\n        defineReadOnly(this, \"_types\", {});\n        // Link struct types to their direct child structs\n        const links = {};\n        // Link structs to structs which contain them as a child\n        const parents = {};\n        // Link all subtypes within a given struct\n        const subtypes = {};\n        Object.keys(types).forEach((type) => {\n            links[type] = {};\n            parents[type] = [];\n            subtypes[type] = {};\n        });\n        for (const name in types) {\n            const uniqueNames = {};\n            types[name].forEach((field) => {\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    return;\n                }\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        }\n        else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(\", \")}`, \"types\", types);\n        }\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n        // Check for circular type references\n        function checkCircular(type, found) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n            }\n            found[type] = true;\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) {\n                    return;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n            delete found[type];\n        }\n        checkCircular(this.primaryType, {});\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n    getEncoder(type) {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n    _getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n                return keccak256(hexConcat(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) {\n                        return keccak256(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            };\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    encodeType(name) {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        }\n        return result;\n    }\n    encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    hashStruct(name, value) {\n        return keccak256(this.encodeData(name, value));\n    }\n    encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v) => this._visit(subtype, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    static hashDomain(domain) {\n        const domainFields = [];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n    static encode(domain, types, value) {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    static hash(domain, types, value) {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    static resolveNames(domain, types, value, resolveName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Make a copy to isolate it from the object passed in\n            domain = shallowCopy(domain);\n            // Look up all ENS names\n            const ensCache = {};\n            // Do we need to look up the domain's verifyingContract?\n            if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n                ensCache[domain.verifyingContract] = \"0x\";\n            }\n            // We are going to use the encoder to visit all the base values\n            const encoder = TypedDataEncoder.from(types);\n            // Get a list of all the addresses\n            encoder.visit(value, (type, value) => {\n                if (type === \"address\" && !isHexString(value, 20)) {\n                    ensCache[value] = \"0x\";\n                }\n                return value;\n            });\n            // Lookup each name\n            for (const name in ensCache) {\n                ensCache[name] = yield resolveName(name);\n            }\n            // Replace the domain verifyingContract if needed\n            if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n                domain.verifyingContract = ensCache[domain.verifyingContract];\n            }\n            // Replace all ENS names with their address\n            value = encoder.visit(value, (type, value) => {\n                if (type === \"address\" && ensCache[value]) {\n                    return ensCache[value];\n                }\n                return value;\n            });\n            return { domain, value };\n        });\n    }\n    static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name) => {\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        }\n        else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value) => {\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof (value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n//# sourceMappingURL=typed-data.js.map"]},"metadata":{},"sourceType":"module"}