{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/taykim/Desktop/cs98/project-22f-zk-vote/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _taggedTemplateLiteral = require(\"/Users/taykim/Desktop/cs98/project-22f-zk-vote/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar code_1 = require(\"../code\");\nvar codegen_1 = require(\"../../compile/codegen\");\nvar util_1 = require(\"../../compile/util\");\nvar error = {\n  message: function message(_ref) {\n    var missingProperty = _ref.params.missingProperty;\n    return (0, codegen_1.str)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"must have required property '\", \"'\"])), missingProperty);\n  },\n  params: function params(_ref2) {\n    var missingProperty = _ref2.params.missingProperty;\n    return (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"{missingProperty: \", \"}\"])), missingProperty);\n  }\n};\nvar def = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error: error,\n  code: function code(cxt) {\n    var gen = cxt.gen,\n      schema = cxt.schema,\n      schemaCode = cxt.schemaCode,\n      data = cxt.data,\n      $data = cxt.$data,\n      it = cxt.it;\n    var opts = it.opts;\n    if (!$data && schema.length === 0) return;\n    var useLoop = schema.length >= opts.loopRequired;\n    if (it.allErrors) allErrorsMode();else exitOnErrorMode();\n    if (opts.strictRequired) {\n      var props = cxt.parentSchema.properties;\n      var definedProperties = cxt.it.definedProperties;\n      var _iterator = _createForOfIteratorHelper(schema),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var requiredKey = _step.value;\n          if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n            var schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n            var msg = \"required property \\\"\".concat(requiredKey, \"\\\" is not defined at \\\"\").concat(schemaPath, \"\\\" (strictRequired)\");\n            (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    function allErrorsMode() {\n      if (useLoop || $data) {\n        cxt.block$data(codegen_1.nil, loopAllRequired);\n      } else {\n        var _iterator2 = _createForOfIteratorHelper(schema),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var prop = _step2.value;\n            (0, code_1.checkReportMissingProp)(cxt, prop);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n    function exitOnErrorMode() {\n      var missing = gen.let(\"missing\");\n      if (useLoop || $data) {\n        var valid = gen.let(\"valid\", true);\n        cxt.block$data(valid, function () {\n          return loopUntilMissing(missing, valid);\n        });\n        cxt.ok(valid);\n      } else {\n        gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n        (0, code_1.reportMissingProp)(cxt, missing);\n        gen.else();\n      }\n    }\n    function loopAllRequired() {\n      gen.forOf(\"prop\", schemaCode, function (prop) {\n        cxt.setParams({\n          missingProperty: prop\n        });\n        gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), function () {\n          return cxt.error();\n        });\n      });\n    }\n    function loopUntilMissing(missing, valid) {\n      cxt.setParams({\n        missingProperty: missing\n      });\n      gen.forOf(missing, schemaCode, function () {\n        gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n        gen.if((0, codegen_1.not)(valid), function () {\n          cxt.error();\n          gen.break();\n        });\n      }, codegen_1.nil);\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/validation/required.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property '${missingProperty}'`,\n    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,\n};\nconst def = {\n    keyword: \"required\",\n    type: \"object\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, schema, schemaCode, data, $data, it } = cxt;\n        const { opts } = it;\n        if (!$data && schema.length === 0)\n            return;\n        const useLoop = schema.length >= opts.loopRequired;\n        if (it.allErrors)\n            allErrorsMode();\n        else\n            exitOnErrorMode();\n        if (opts.strictRequired) {\n            const props = cxt.parentSchema.properties;\n            const { definedProperties } = cxt.it;\n            for (const requiredKey of schema) {\n                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n                    const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n                }\n            }\n        }\n        function allErrorsMode() {\n            if (useLoop || $data) {\n                cxt.block$data(codegen_1.nil, loopAllRequired);\n            }\n            else {\n                for (const prop of schema) {\n                    (0, code_1.checkReportMissingProp)(cxt, prop);\n                }\n            }\n        }\n        function exitOnErrorMode() {\n            const missing = gen.let(\"missing\");\n            if (useLoop || $data) {\n                const valid = gen.let(\"valid\", true);\n                cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n                cxt.ok(valid);\n            }\n            else {\n                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n                (0, code_1.reportMissingProp)(cxt, missing);\n                gen.else();\n            }\n        }\n        function loopAllRequired() {\n            gen.forOf(\"prop\", schemaCode, (prop) => {\n                cxt.setParams({ missingProperty: prop });\n                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n            });\n        }\n        function loopUntilMissing(missing, valid) {\n            cxt.setParams({ missingProperty: missing });\n            gen.forOf(missing, schemaCode, () => {\n                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n                gen.if((0, codegen_1.not)(valid), () => {\n                    cxt.error();\n                    gen.break();\n                });\n            }, codegen_1.nil);\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=required.js.map"]},"metadata":{},"sourceType":"script"}