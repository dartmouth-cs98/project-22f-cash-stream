{"ast":null,"code":"import _regeneratorRuntime from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { ethers } from \"ethers\";\nimport Host from \"./Host\";\nimport { SFError } from \"./SFError\";\nimport SuperfluidABI from \"./abi/Superfluid.json\";\nimport { getTransactionDescription, removeSigHashFromCallData } from \"./utils\";\nvar operationTypeStringToTypeMap = new Map([[\"ERC20_APPROVE\", 1], [\"ERC20_TRANSFER_FROM\", 2], [\"SUPERTOKEN_UPGRADE\", 101], [\"SUPERTOKEN_DOWNGRADE\", 102], [\"SUPERFLUID_CALL_AGREEMENT\", 201], [\"CALL_APP_ACTION\", 202]]);\n/**\n * BatchCall Helper Class\n * @description A helper class to create `BatchCall` objects which can be executed.\n */\nvar BatchCall = /*#__PURE__*/function () {\n  function BatchCall(options) {\n    var _this = this;\n    _classCallCheck(this, BatchCall);\n    /**\n     * Gets the call agreement function arguments.\n     * @param callData callData of the function\n     * @returns {ethers.utils.Result} call agreement function arguments\n     */\n    this.getCallAgreementFunctionArgs = function (callData) {\n      return getTransactionDescription(SuperfluidABI.abi, callData).args;\n    };\n    /**\n     * Given an `Operation` object, gets the `OperationStruct` object.\n     * @param operation an `Operation` object\n     * @param index the index of the `Operation` in the batchCall\n     * @returns {Promise<OperationStruct>} OperationStruct object for batchCall\n     */\n    this.getOperationStruct = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(operation, index) {\n        var operationType, populatedTransaction, encoder, functionArgs, data;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                operationType = operationTypeStringToTypeMap.get(operation.type);\n                _context.next = 3;\n                return operation.populateTransactionPromise;\n              case 3:\n                populatedTransaction = _context.sent;\n                if (operationType) {\n                  _context.next = 6;\n                  break;\n                }\n                throw new SFError({\n                  type: \"UNSUPPORTED_OPERATION\",\n                  customMessage: \"The operation at index \" + index + \" is unsupported.\"\n                });\n              case 6:\n                if (!(!populatedTransaction.to || !populatedTransaction.data)) {\n                  _context.next = 8;\n                  break;\n                }\n                throw new SFError({\n                  type: \"MISSING_TRANSACTION_PROPERTIES\",\n                  customMessage: \"The transaction is missing the to or data property.\"\n                });\n              case 8:\n                if (!(operation.type === \"SUPERFLUID_CALL_AGREEMENT\")) {\n                  _context.next = 13;\n                  break;\n                }\n                encoder = ethers.utils.defaultAbiCoder;\n                functionArgs = _this.getCallAgreementFunctionArgs(populatedTransaction.data);\n                data = encoder.encode([\"bytes\", \"bytes\"], [functionArgs[\"callData\"], functionArgs[\"userData\"]]);\n                return _context.abrupt(\"return\", {\n                  operationType: operationType,\n                  target: functionArgs[\"agreementClass\"],\n                  data: data\n                });\n              case 13:\n                return _context.abrupt(\"return\", {\n                  operationType: operationType,\n                  target: populatedTransaction.to,\n                  data: removeSigHashFromCallData(populatedTransaction.data)\n                });\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function (_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    /**\n     * Executes a batch call given the operations on this class.\n     * @param signer the signer of the transaction\n     * @returns {Promise<ethers.ContractTransaction>} ContractTransaction object\n     */\n    this.exec = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(signer) {\n        var operationStructArray;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return Promise.all(_this.getOperationStructArrayPromises);\n              case 3:\n                operationStructArray = _context2.sent;\n                _context2.next = 6;\n                return _this.host.contract.connect(signer).batchCall(operationStructArray);\n              case 6:\n                return _context2.abrupt(\"return\", _context2.sent);\n              case 9:\n                _context2.prev = 9;\n                _context2.t0 = _context2[\"catch\"](0);\n                throw new SFError({\n                  type: \"BATCH_CALL_ERROR\",\n                  customMessage: \"There was an error executing your batch call:\",\n                  errorObject: _context2.t0\n                });\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[0, 9]]);\n      }));\n      return function (_x3) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    /* istanbul ignore next */\n    // TODO: user signs the transaction they'd like to execute and gives\n    // this data to the trusted forwarder to sign\n    /**\n     * Executes a forward batch call given the operations on this class.\n     * @param signer the signer of the transaction\n     * @returns {Promise<ethers.ContractTransaction>} ContractTransaction object\n     */\n    this.execForward = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(signer) {\n        var operationStructArray;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return Promise.all(_this.getOperationStructArrayPromises);\n              case 3:\n                operationStructArray = _context3.sent;\n                _context3.next = 6;\n                return _this.host.contract.connect(signer).forwardBatchCall(operationStructArray);\n              case 6:\n                return _context3.abrupt(\"return\", _context3.sent);\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](0);\n                throw new SFError({\n                  type: \"BATCH_CALL_ERROR\",\n                  customMessage: \"There was an error executing your batch call:\",\n                  errorObject: _context3.t0\n                });\n              case 12:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[0, 9]]);\n      }));\n      return function (_x4) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n    this.options = options;\n    this.host = new Host(options.hostAddress);\n  }\n  /**\n   * Gets an array of `OperationStruct` objects to be passed to batchCall.\n   * @returns {Promise<OperationStruct>[]} array of operation struct promises\n   */\n  _createClass(BatchCall, [{\n    key: \"getOperationStructArrayPromises\",\n    get: function get() {\n      var _this2 = this;\n      return this.options.operations.map(function (x, i) {\n        return _this2.getOperationStruct(x, i);\n      });\n    }\n  }]);\n  return BatchCall;\n}();\nexport { BatchCall as default };","map":{"version":3,"sources":["../../src/BatchCall.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ethers } from \"ethers\";\nimport Host from \"./Host\";\nimport { SFError } from \"./SFError\";\nimport SuperfluidABI from \"./abi/Superfluid.json\";\nimport { getTransactionDescription, removeSigHashFromCallData } from \"./utils\";\nconst operationTypeStringToTypeMap = new Map([\n    [\"ERC20_APPROVE\", 1],\n    [\"ERC20_TRANSFER_FROM\", 2],\n    [\"SUPERTOKEN_UPGRADE\", 101],\n    [\"SUPERTOKEN_DOWNGRADE\", 102],\n    [\"SUPERFLUID_CALL_AGREEMENT\", 201],\n    [\"CALL_APP_ACTION\", 202],\n]);\n/**\n * BatchCall Helper Class\n * @description A helper class to create `BatchCall` objects which can be executed.\n */\nexport default class BatchCall {\n    constructor(options) {\n        /**\n         * Gets the call agreement function arguments.\n         * @param callData callData of the function\n         * @returns {ethers.utils.Result} call agreement function arguments\n         */\n        this.getCallAgreementFunctionArgs = (callData) => getTransactionDescription(SuperfluidABI.abi, callData).args;\n        /**\n         * Given an `Operation` object, gets the `OperationStruct` object.\n         * @param operation an `Operation` object\n         * @param index the index of the `Operation` in the batchCall\n         * @returns {Promise<OperationStruct>} OperationStruct object for batchCall\n         */\n        this.getOperationStruct = async (operation, index) => {\n            const operationType = operationTypeStringToTypeMap.get(operation.type);\n            const populatedTransaction = await operation.populateTransactionPromise;\n            if (!operationType) {\n                throw new SFError({\n                    type: \"UNSUPPORTED_OPERATION\",\n                    customMessage: \"The operation at index \" + index + \" is unsupported.\",\n                });\n            }\n            /* istanbul ignore next */\n            if (!populatedTransaction.to || !populatedTransaction.data) {\n                throw new SFError({\n                    type: \"MISSING_TRANSACTION_PROPERTIES\",\n                    customMessage: \"The transaction is missing the to or data property.\",\n                });\n            }\n            // Handles the Superfluid Call Agreement\n            // The only operation which has a target that is not the\n            // same as the to property of the transaction.\n            if (operation.type === \"SUPERFLUID_CALL_AGREEMENT\") {\n                const encoder = ethers.utils.defaultAbiCoder;\n                const functionArgs = this.getCallAgreementFunctionArgs(populatedTransaction.data);\n                const data = encoder.encode([\"bytes\", \"bytes\"], [functionArgs[\"callData\"], functionArgs[\"userData\"]]);\n                return {\n                    operationType,\n                    target: functionArgs[\"agreementClass\"],\n                    data,\n                };\n            }\n            // Handles other cases which are not call agreeement operation\n            return {\n                operationType,\n                target: populatedTransaction.to,\n                data: removeSigHashFromCallData(populatedTransaction.data),\n            };\n        };\n        /**\n         * Executes a batch call given the operations on this class.\n         * @param signer the signer of the transaction\n         * @returns {Promise<ethers.ContractTransaction>} ContractTransaction object\n         */\n        this.exec = async (signer) => {\n            try {\n                const operationStructArray = await Promise.all(this.getOperationStructArrayPromises);\n                return await this.host.contract\n                    .connect(signer)\n                    .batchCall(operationStructArray);\n            }\n            catch (err) {\n                throw new SFError({\n                    type: \"BATCH_CALL_ERROR\",\n                    customMessage: \"There was an error executing your batch call:\",\n                    errorObject: err,\n                });\n            }\n        };\n        /* istanbul ignore next */\n        // TODO: user signs the transaction they'd like to execute and gives\n        // this data to the trusted forwarder to sign\n        /**\n         * Executes a forward batch call given the operations on this class.\n         * @param signer the signer of the transaction\n         * @returns {Promise<ethers.ContractTransaction>} ContractTransaction object\n         */\n        this.execForward = async (signer) => {\n            try {\n                const operationStructArray = await Promise.all(this.getOperationStructArrayPromises);\n                return await this.host.contract\n                    .connect(signer)\n                    .forwardBatchCall(operationStructArray);\n            }\n            catch (err) {\n                throw new SFError({\n                    type: \"BATCH_CALL_ERROR\",\n                    customMessage: \"There was an error executing your batch call:\",\n                    errorObject: err,\n                });\n            }\n        };\n        this.options = options;\n        this.host = new Host(options.hostAddress);\n    }\n    /**\n     * Gets an array of `OperationStruct` objects to be passed to batchCall.\n     * @returns {Promise<OperationStruct>[]} array of operation struct promises\n     */\n    get getOperationStructArrayPromises() {\n        return this.options.operations.map((x, i) => this.getOperationStruct(x, i));\n    }\n}\n//# sourceMappingURL=BatchCall.js.map"]},"metadata":{},"sourceType":"module"}