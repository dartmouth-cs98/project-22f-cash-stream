{"ast":null,"code":"import _regeneratorRuntime from \"/Users/taykim/Desktop/cs98/project-22f-zk-vote/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"/Users/taykim/Desktop/cs98/project-22f-zk-vote/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"/Users/taykim/Desktop/cs98/project-22f-zk-vote/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/taykim/Desktop/cs98/project-22f-zk-vote/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/taykim/Desktop/cs98/project-22f-zk-vote/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _ from \"lodash\";\nimport { mapGetAllEventsQueryEvents } from \"./mapGetAllEventsQueryEvents\";\nimport { createLastIdPaging, createPagedResult, createSkipPaging, takePlusOne } from \"./pagination\";\nimport { SubgraphClient } from \"./subgraph/SubgraphClient\";\nimport { GetAccountTokenSnapshotsDocument } from \"./subgraph/queries/getAccountTokenSnapshots.generated\";\nimport { GetAllEventsDocument } from \"./subgraph/queries/getAllEvents.generated\";\nimport { GetIndexSubscriptionsDocument } from \"./subgraph/queries/getIndexSubscriptions.generated\";\nimport { GetIndexesDocument } from \"./subgraph/queries/getIndexes.generated\";\nimport { GetStreamsDocument } from \"./subgraph/queries/getStreams.generated\";\nimport { GetTokensDocument } from \"./subgraph/queries/getTokens.generated\";\nimport { typeGuard } from \"./utils\";\nimport { validateAccountTokenSnapshotRequest, validateEventRequest, validateIndexRequest, validateIndexSubscriptionRequest, validateStreamRequest, validateSuperTokenRequest } from \"./validation\";\n/**\n * Query Helper Class\n * @description A helper class to create `Query` objects which can be used to query different data.\n */\nvar Query = /*#__PURE__*/function () {\n  function Query(options) {\n    var _this = this;\n    _classCallCheck(this, Query);\n    this.listAllSuperTokens = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(filter) {\n        var paging,\n          ordering,\n          response,\n          mappedResult,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                paging = _args.length > 1 && _args[1] !== undefined ? _args[1] : createSkipPaging();\n                ordering = _args.length > 2 && _args[2] !== undefined ? _args[2] : {\n                  orderBy: \"createdAtBlockNumber\",\n                  orderDirection: \"desc\"\n                };\n                validateSuperTokenRequest(filter);\n                _context.next = 5;\n                return _this.subgraphClient.request(GetTokensDocument, {\n                  where: {\n                    isListed: filter.isListed,\n                    isSuperToken: true,\n                    id_gt: paging.lastId\n                  },\n                  orderBy: ordering === null || ordering === void 0 ? void 0 : ordering.orderBy,\n                  orderDirection: ordering === null || ordering === void 0 ? void 0 : ordering.orderDirection,\n                  first: takePlusOne(paging),\n                  skip: paging.skip\n                });\n              case 5:\n                response = _context.sent;\n                mappedResult = response.result.map(function (x) {\n                  return typeGuard(_objectSpread(_objectSpread({}, x), {}, {\n                    createdAtTimestamp: Number(x.createdAtTimestamp),\n                    createdAtBlockNumber: Number(x.createdAtBlockNumber)\n                  }));\n                });\n                return _context.abrupt(\"return\", createPagedResult(mappedResult, paging));\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    this.listIndexes = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(filter) {\n        var paging,\n          ordering,\n          _a,\n          _b,\n          response,\n          mappedResult,\n          _args2 = arguments;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                paging = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : createSkipPaging();\n                ordering = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {\n                  orderBy: \"createdAtBlockNumber\",\n                  orderDirection: \"desc\"\n                };\n                validateIndexRequest(filter);\n                _context2.next = 5;\n                return _this.subgraphClient.request(GetIndexesDocument, {\n                  where: {\n                    indexId: filter.indexId,\n                    publisher: (_a = filter.publisher) === null || _a === void 0 ? void 0 : _a.toLowerCase(),\n                    token: (_b = filter.token) === null || _b === void 0 ? void 0 : _b.toLowerCase(),\n                    id_gt: paging.lastId\n                  },\n                  orderBy: ordering === null || ordering === void 0 ? void 0 : ordering.orderBy,\n                  orderDirection: ordering === null || ordering === void 0 ? void 0 : ordering.orderDirection,\n                  first: takePlusOne(paging),\n                  skip: paging.skip\n                });\n              case 5:\n                response = _context2.sent;\n                mappedResult = response.result.map(function (x) {\n                  return typeGuard(_objectSpread(_objectSpread({}, x), {}, {\n                    publisher: x.publisher.id,\n                    createdAtTimestamp: Number(x.createdAtTimestamp),\n                    createdAtBlockNumber: Number(x.createdAtBlockNumber),\n                    updatedAtTimestamp: Number(x.updatedAtTimestamp),\n                    updatedAtBlockNumber: Number(x.updatedAtBlockNumber),\n                    token: _objectSpread(_objectSpread({}, x.token), {}, {\n                      createdAtTimestamp: Number(x.token.createdAtTimestamp),\n                      createdAtBlockNumber: Number(x.token.createdAtBlockNumber)\n                    })\n                  }));\n                });\n                return _context2.abrupt(\"return\", createPagedResult(mappedResult, paging));\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n      return function (_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    this.listIndexSubscriptions = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(filter) {\n        var paging,\n          ordering,\n          _a,\n          response,\n          mappedResult,\n          _args3 = arguments;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                paging = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : createSkipPaging();\n                ordering = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {\n                  orderBy: \"createdAtBlockNumber\",\n                  orderDirection: \"desc\"\n                };\n                validateIndexSubscriptionRequest(filter);\n                _context3.next = 5;\n                return _this.subgraphClient.request(GetIndexSubscriptionsDocument, {\n                  where: {\n                    subscriber: (_a = filter.subscriber) === null || _a === void 0 ? void 0 : _a.toLowerCase(),\n                    approved: filter.approved,\n                    id_gt: paging.lastId\n                  },\n                  orderBy: ordering === null || ordering === void 0 ? void 0 : ordering.orderBy,\n                  orderDirection: ordering === null || ordering === void 0 ? void 0 : ordering.orderDirection,\n                  first: takePlusOne(paging),\n                  skip: paging.skip\n                });\n              case 5:\n                response = _context3.sent;\n                mappedResult = response.result.map(function (x) {\n                  return typeGuard(_objectSpread(_objectSpread({}, x), {}, {\n                    subscriber: x.subscriber.id,\n                    createdAtTimestamp: Number(x.createdAtTimestamp),\n                    createdAtBlockNumber: Number(x.createdAtBlockNumber),\n                    updatedAtTimestamp: Number(x.updatedAtTimestamp),\n                    updatedAtBlockNumber: Number(x.updatedAtBlockNumber),\n                    index: _objectSpread(_objectSpread({}, x.index), {}, {\n                      token: _objectSpread(_objectSpread({}, x.index.token), {}, {\n                        createdAtTimestamp: Number(x.index.token.createdAtTimestamp),\n                        createdAtBlockNumber: Number(x.index.token.createdAtBlockNumber)\n                      })\n                    })\n                  }));\n                });\n                return _context3.abrupt(\"return\", createPagedResult(mappedResult, paging));\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      return function (_x3) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n    this.listStreams = /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(filter) {\n        var paging,\n          ordering,\n          _a,\n          _b,\n          _c,\n          response,\n          mappedResult,\n          _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                paging = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : createSkipPaging();\n                ordering = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {\n                  orderBy: \"createdAtBlockNumber\",\n                  orderDirection: \"desc\"\n                };\n                validateStreamRequest(filter);\n                _context4.next = 5;\n                return _this.subgraphClient.request(GetStreamsDocument, {\n                  where: {\n                    sender: (_a = filter.sender) === null || _a === void 0 ? void 0 : _a.toLowerCase(),\n                    receiver: (_b = filter.receiver) === null || _b === void 0 ? void 0 : _b.toLowerCase(),\n                    token: (_c = filter.token) === null || _c === void 0 ? void 0 : _c.toLowerCase(),\n                    id_gt: paging.lastId\n                  },\n                  orderBy: ordering === null || ordering === void 0 ? void 0 : ordering.orderBy,\n                  orderDirection: ordering === null || ordering === void 0 ? void 0 : ordering.orderDirection,\n                  first: takePlusOne(paging),\n                  skip: paging.skip\n                });\n              case 5:\n                response = _context4.sent;\n                mappedResult = response.result.map(function (x) {\n                  return typeGuard(_objectSpread(_objectSpread({}, x), {}, {\n                    sender: x.sender.id,\n                    receiver: x.receiver.id,\n                    createdAtTimestamp: Number(x.createdAtTimestamp),\n                    createdAtBlockNumber: Number(x.createdAtBlockNumber),\n                    updatedAtTimestamp: Number(x.updatedAtTimestamp),\n                    updatedAtBlockNumber: Number(x.updatedAtBlockNumber),\n                    token: _objectSpread(_objectSpread({}, x.token), {}, {\n                      createdAtTimestamp: Number(x.token.createdAtTimestamp),\n                      createdAtBlockNumber: Number(x.token.createdAtBlockNumber)\n                    }),\n                    flowUpdatedEvents: x.flowUpdatedEvents.map(function (y) {\n                      return _objectSpread(_objectSpread({}, y), {}, {\n                        blockNumber: Number(y.blockNumber),\n                        timestamp: Number(y.timestamp)\n                      });\n                    })\n                  }));\n                });\n                return _context4.abrupt(\"return\", createPagedResult(mappedResult, paging));\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n      return function (_x4) {\n        return _ref4.apply(this, arguments);\n      };\n    }();\n    this.listUserInteractedSuperTokens = /*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(filter) {\n        var paging,\n          ordering,\n          _a,\n          _b,\n          response,\n          mappedResult,\n          _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                paging = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : createSkipPaging();\n                ordering = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : {\n                  orderBy: \"updatedAtBlockNumber\",\n                  orderDirection: \"desc\"\n                };\n                validateAccountTokenSnapshotRequest(filter);\n                _context5.next = 5;\n                return _this.subgraphClient.request(GetAccountTokenSnapshotsDocument, {\n                  where: {\n                    account: (_a = filter.account) === null || _a === void 0 ? void 0 : _a.toLowerCase(),\n                    token: (_b = filter.token) === null || _b === void 0 ? void 0 : _b.toLowerCase(),\n                    id_gt: paging.lastId\n                  },\n                  orderBy: ordering === null || ordering === void 0 ? void 0 : ordering.orderBy,\n                  orderDirection: ordering === null || ordering === void 0 ? void 0 : ordering.orderDirection,\n                  first: takePlusOne(paging),\n                  skip: paging.skip\n                });\n              case 5:\n                response = _context5.sent;\n                mappedResult = response.result.map(function (x) {\n                  return typeGuard(_objectSpread(_objectSpread({}, x), {}, {\n                    account: x.account.id,\n                    updatedAtTimestamp: Number(x.updatedAtTimestamp),\n                    updatedAtBlockNumber: Number(x.updatedAtBlockNumber),\n                    token: _objectSpread(_objectSpread({}, x.token), {}, {\n                      createdAtTimestamp: Number(x.token.createdAtTimestamp),\n                      createdAtBlockNumber: Number(x.token.createdAtBlockNumber)\n                    })\n                  }));\n                });\n                return _context5.abrupt(\"return\", createPagedResult(mappedResult, paging));\n              case 8:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n      return function (_x5) {\n        return _ref5.apply(this, arguments);\n      };\n    }();\n    this.listEvents = /*#__PURE__*/function () {\n      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(filter) {\n        var paging,\n          ordering,\n          _a,\n          _b,\n          response,\n          _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                paging = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : createSkipPaging();\n                ordering = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : {\n                  orderBy: \"blockNumber\",\n                  orderDirection: \"desc\"\n                };\n                validateEventRequest(filter);\n                _context6.next = 5;\n                return _this.subgraphClient.request(GetAllEventsDocument, {\n                  orderBy: ordering === null || ordering === void 0 ? void 0 : ordering.orderBy,\n                  orderDirection: ordering === null || ordering === void 0 ? void 0 : ordering.orderDirection,\n                  where: {\n                    addresses_contains: filter.account ? [(_a = filter.account) === null || _a === void 0 ? void 0 : _a.toLowerCase()] : undefined,\n                    timestamp_gt: (_b = filter.timestamp_gt) === null || _b === void 0 ? void 0 : _b.toString(),\n                    id_gt: paging.lastId\n                  },\n                  first: takePlusOne(paging),\n                  skip: paging.skip\n                });\n              case 5:\n                response = _context6.sent;\n                return _context6.abrupt(\"return\", createPagedResult(mapGetAllEventsQueryEvents(response.events), paging));\n              case 7:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n      return function (_x6) {\n        return _ref6.apply(this, arguments);\n      };\n    }();\n    this.options = options;\n    this.subgraphClient = new SubgraphClient(this.options.customSubgraphQueriesEndpoint);\n  }\n  // TODO(KK): error callback?\n  // TODO(KK): retries?\n  // TODO(KK): tests\n  _createClass(Query, [{\n    key: \"on\",\n    value: function on(callback, ms, account, timeout) {\n      var _this2 = this;\n      if (ms < 1000) throw Error(\"Let's not go crazy with the queries...\");\n      // Account for the fact that Subgraph has lag and will insert events with the timestamp of the event from blockchain.\n      var clockSkew = 25000;\n      // Convert millisecond-based time to second-based time (which Subgraph uses).\n      var eventQueryTimestamp = Math.floor((new Date().getTime() - clockSkew) / 1000);\n      var isUnsubscribed = false;\n      var unsubscribe = function unsubscribe() {\n        isUnsubscribed = true;\n      };\n      var pollingStep = /*#__PURE__*/function () {\n        var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n          var allEvents, lastEvent;\n          return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  if (!isUnsubscribed) {\n                    _context7.next = 2;\n                    break;\n                  }\n                  return _context7.abrupt(\"return\");\n                case 2:\n                  _context7.next = 4;\n                  return listAllResults(function (paging) {\n                    return _this2.listEvents({\n                      account: account,\n                      timestamp_gt: eventQueryTimestamp\n                    }, paging, {\n                      orderBy: \"timestamp\",\n                      orderDirection: \"asc\"\n                    });\n                  });\n                case 4:\n                  allEvents = _context7.sent;\n                  // Filter next events by last timestamp of an event.\n                  // NOTE: Make sure to order events by timestamp in ascending order.\n                  lastEvent = _.last(allEvents);\n                  if (lastEvent) {\n                    callback(allEvents, unsubscribe);\n                    // Next event polling is done for events that have a timestamp later than the current latest event.\n                    eventQueryTimestamp = lastEvent.timestamp;\n                  }\n                  // This solution sets the interval based on last query returning, opposed to not taking request-response cycles into account at all.\n                  // This solution is more friendly to the Subgraph & more effective resource-wise with slow internet.\n                  return _context7.abrupt(\"return\", setTimeout(function () {\n                    // Fire and forget\n                    pollingStep();\n                  }, ms));\n                case 8:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }, _callee7);\n        }));\n        return function pollingStep() {\n          return _ref7.apply(this, arguments);\n        };\n      }();\n      if (timeout) {\n        setTimeout(function () {\n          unsubscribe();\n        }, timeout);\n      }\n      // Fire and forget\n      pollingStep();\n      return unsubscribe;\n    }\n  }]);\n  return Query;\n}();\n/**\n * A recursive function to fetch all possible results of a paged query.\n * @param pagedQuery A paginated query that takes {@link Paging} as input.\n */\nexport { Query as default };\nexport var listAllResults = /*#__PURE__*/function () {\n  var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(pagedQuery) {\n    var listAllRecursively;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            listAllRecursively = /*#__PURE__*/function () {\n              var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(paging) {\n                var pagedResult, nextResults;\n                return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n                  while (1) {\n                    switch (_context8.prev = _context8.next) {\n                      case 0:\n                        _context8.next = 2;\n                        return pagedQuery(paging);\n                      case 2:\n                        pagedResult = _context8.sent;\n                        if (pagedResult.nextPaging) {\n                          _context8.next = 5;\n                          break;\n                        }\n                        return _context8.abrupt(\"return\", pagedResult.data);\n                      case 5:\n                        _context8.next = 7;\n                        return listAllRecursively(pagedResult.nextPaging);\n                      case 7:\n                        nextResults = _context8.sent;\n                        return _context8.abrupt(\"return\", pagedResult.data.concat(nextResults));\n                      case 9:\n                      case \"end\":\n                        return _context8.stop();\n                    }\n                  }\n                }, _callee8);\n              }));\n              return function listAllRecursively(_x8) {\n                return _ref9.apply(this, arguments);\n              };\n            }();\n            return _context9.abrupt(\"return\", listAllRecursively(createLastIdPaging({\n              take: 999\n            })));\n          case 2:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  return function listAllResults(_x7) {\n    return _ref8.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["../../src/Query.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import _ from \"lodash\";\nimport { mapGetAllEventsQueryEvents } from \"./mapGetAllEventsQueryEvents\";\nimport { createLastIdPaging, createPagedResult, createSkipPaging, takePlusOne, } from \"./pagination\";\nimport { SubgraphClient } from \"./subgraph/SubgraphClient\";\nimport { GetAccountTokenSnapshotsDocument, } from \"./subgraph/queries/getAccountTokenSnapshots.generated\";\nimport { GetAllEventsDocument, } from \"./subgraph/queries/getAllEvents.generated\";\nimport { GetIndexSubscriptionsDocument, } from \"./subgraph/queries/getIndexSubscriptions.generated\";\nimport { GetIndexesDocument, } from \"./subgraph/queries/getIndexes.generated\";\nimport { GetStreamsDocument, } from \"./subgraph/queries/getStreams.generated\";\nimport { GetTokensDocument, } from \"./subgraph/queries/getTokens.generated\";\nimport { typeGuard } from \"./utils\";\nimport { validateAccountTokenSnapshotRequest, validateEventRequest, validateIndexRequest, validateIndexSubscriptionRequest, validateStreamRequest, validateSuperTokenRequest, } from \"./validation\";\n/**\n * Query Helper Class\n * @description A helper class to create `Query` objects which can be used to query different data.\n */\nexport default class Query {\n    constructor(options) {\n        this.listAllSuperTokens = async (filter, paging = createSkipPaging(), ordering = {\n            orderBy: \"createdAtBlockNumber\",\n            orderDirection: \"desc\",\n        }) => {\n            validateSuperTokenRequest(filter);\n            const response = await this.subgraphClient.request(GetTokensDocument, {\n                where: {\n                    isListed: filter.isListed,\n                    isSuperToken: true,\n                    id_gt: paging.lastId,\n                },\n                orderBy: ordering === null || ordering === void 0 ? void 0 : ordering.orderBy,\n                orderDirection: ordering === null || ordering === void 0 ? void 0 : ordering.orderDirection,\n                first: takePlusOne(paging),\n                skip: paging.skip,\n            });\n            const mappedResult = response.result.map((x) => typeGuard({\n                ...x,\n                createdAtTimestamp: Number(x.createdAtTimestamp),\n                createdAtBlockNumber: Number(x.createdAtBlockNumber),\n            }));\n            return createPagedResult(mappedResult, paging);\n        };\n        this.listIndexes = async (filter, paging = createSkipPaging(), ordering = {\n            orderBy: \"createdAtBlockNumber\",\n            orderDirection: \"desc\",\n        }) => {\n            var _a, _b;\n            validateIndexRequest(filter);\n            const response = await this.subgraphClient.request(GetIndexesDocument, {\n                where: {\n                    indexId: filter.indexId,\n                    publisher: (_a = filter.publisher) === null || _a === void 0 ? void 0 : _a.toLowerCase(),\n                    token: (_b = filter.token) === null || _b === void 0 ? void 0 : _b.toLowerCase(),\n                    id_gt: paging.lastId,\n                },\n                orderBy: ordering === null || ordering === void 0 ? void 0 : ordering.orderBy,\n                orderDirection: ordering === null || ordering === void 0 ? void 0 : ordering.orderDirection,\n                first: takePlusOne(paging),\n                skip: paging.skip,\n            });\n            const mappedResult = response.result.map((x) => typeGuard({\n                ...x,\n                publisher: x.publisher.id,\n                createdAtTimestamp: Number(x.createdAtTimestamp),\n                createdAtBlockNumber: Number(x.createdAtBlockNumber),\n                updatedAtTimestamp: Number(x.updatedAtTimestamp),\n                updatedAtBlockNumber: Number(x.updatedAtBlockNumber),\n                token: {\n                    ...x.token,\n                    createdAtTimestamp: Number(x.token.createdAtTimestamp),\n                    createdAtBlockNumber: Number(x.token.createdAtBlockNumber),\n                },\n            }));\n            return createPagedResult(mappedResult, paging);\n        };\n        this.listIndexSubscriptions = async (filter, paging = createSkipPaging(), ordering = {\n            orderBy: \"createdAtBlockNumber\",\n            orderDirection: \"desc\",\n        }) => {\n            var _a;\n            validateIndexSubscriptionRequest(filter);\n            const response = await this.subgraphClient.request(GetIndexSubscriptionsDocument, {\n                where: {\n                    subscriber: (_a = filter.subscriber) === null || _a === void 0 ? void 0 : _a.toLowerCase(),\n                    approved: filter.approved,\n                    id_gt: paging.lastId,\n                },\n                orderBy: ordering === null || ordering === void 0 ? void 0 : ordering.orderBy,\n                orderDirection: ordering === null || ordering === void 0 ? void 0 : ordering.orderDirection,\n                first: takePlusOne(paging),\n                skip: paging.skip,\n            });\n            const mappedResult = response.result.map((x) => typeGuard({\n                ...x,\n                subscriber: x.subscriber.id,\n                createdAtTimestamp: Number(x.createdAtTimestamp),\n                createdAtBlockNumber: Number(x.createdAtBlockNumber),\n                updatedAtTimestamp: Number(x.updatedAtTimestamp),\n                updatedAtBlockNumber: Number(x.updatedAtBlockNumber),\n                index: {\n                    ...x.index,\n                    token: {\n                        ...x.index.token,\n                        createdAtTimestamp: Number(x.index.token.createdAtTimestamp),\n                        createdAtBlockNumber: Number(x.index.token.createdAtBlockNumber),\n                    },\n                },\n            }));\n            return createPagedResult(mappedResult, paging);\n        };\n        this.listStreams = async (filter, paging = createSkipPaging(), ordering = {\n            orderBy: \"createdAtBlockNumber\",\n            orderDirection: \"desc\",\n        }) => {\n            var _a, _b, _c;\n            validateStreamRequest(filter);\n            const response = await this.subgraphClient.request(GetStreamsDocument, {\n                where: {\n                    sender: (_a = filter.sender) === null || _a === void 0 ? void 0 : _a.toLowerCase(),\n                    receiver: (_b = filter.receiver) === null || _b === void 0 ? void 0 : _b.toLowerCase(),\n                    token: (_c = filter.token) === null || _c === void 0 ? void 0 : _c.toLowerCase(),\n                    id_gt: paging.lastId,\n                },\n                orderBy: ordering === null || ordering === void 0 ? void 0 : ordering.orderBy,\n                orderDirection: ordering === null || ordering === void 0 ? void 0 : ordering.orderDirection,\n                first: takePlusOne(paging),\n                skip: paging.skip,\n            });\n            const mappedResult = response.result.map((x) => typeGuard({\n                ...x,\n                sender: x.sender.id,\n                receiver: x.receiver.id,\n                createdAtTimestamp: Number(x.createdAtTimestamp),\n                createdAtBlockNumber: Number(x.createdAtBlockNumber),\n                updatedAtTimestamp: Number(x.updatedAtTimestamp),\n                updatedAtBlockNumber: Number(x.updatedAtBlockNumber),\n                token: {\n                    ...x.token,\n                    createdAtTimestamp: Number(x.token.createdAtTimestamp),\n                    createdAtBlockNumber: Number(x.token.createdAtBlockNumber),\n                },\n                flowUpdatedEvents: x.flowUpdatedEvents.map((y) => ({\n                    ...y,\n                    blockNumber: Number(y.blockNumber),\n                    timestamp: Number(y.timestamp),\n                })),\n            }));\n            return createPagedResult(mappedResult, paging);\n        };\n        this.listUserInteractedSuperTokens = async (filter, paging = createSkipPaging(), ordering = {\n            orderBy: \"updatedAtBlockNumber\",\n            orderDirection: \"desc\",\n        }) => {\n            var _a, _b;\n            validateAccountTokenSnapshotRequest(filter);\n            const response = await this.subgraphClient.request(GetAccountTokenSnapshotsDocument, {\n                where: {\n                    account: (_a = filter.account) === null || _a === void 0 ? void 0 : _a.toLowerCase(),\n                    token: (_b = filter.token) === null || _b === void 0 ? void 0 : _b.toLowerCase(),\n                    id_gt: paging.lastId,\n                },\n                orderBy: ordering === null || ordering === void 0 ? void 0 : ordering.orderBy,\n                orderDirection: ordering === null || ordering === void 0 ? void 0 : ordering.orderDirection,\n                first: takePlusOne(paging),\n                skip: paging.skip,\n            });\n            const mappedResult = response.result.map((x) => typeGuard({\n                ...x,\n                account: x.account.id,\n                updatedAtTimestamp: Number(x.updatedAtTimestamp),\n                updatedAtBlockNumber: Number(x.updatedAtBlockNumber),\n                token: {\n                    ...x.token,\n                    createdAtTimestamp: Number(x.token.createdAtTimestamp),\n                    createdAtBlockNumber: Number(x.token.createdAtBlockNumber),\n                },\n            }));\n            return createPagedResult(mappedResult, paging);\n        };\n        this.listEvents = async (filter, paging = createSkipPaging(), ordering = {\n            orderBy: \"blockNumber\",\n            orderDirection: \"desc\",\n        }) => {\n            var _a, _b;\n            validateEventRequest(filter);\n            const response = await this.subgraphClient.request(GetAllEventsDocument, {\n                orderBy: ordering === null || ordering === void 0 ? void 0 : ordering.orderBy,\n                orderDirection: ordering === null || ordering === void 0 ? void 0 : ordering.orderDirection,\n                where: {\n                    addresses_contains: filter.account\n                        ? [(_a = filter.account) === null || _a === void 0 ? void 0 : _a.toLowerCase()]\n                        : undefined,\n                    timestamp_gt: (_b = filter.timestamp_gt) === null || _b === void 0 ? void 0 : _b.toString(),\n                    id_gt: paging.lastId,\n                },\n                first: takePlusOne(paging),\n                skip: paging.skip,\n            });\n            return createPagedResult(mapGetAllEventsQueryEvents(response.events), paging);\n        };\n        this.options = options;\n        this.subgraphClient = new SubgraphClient(this.options.customSubgraphQueriesEndpoint);\n    }\n    // TODO(KK): error callback?\n    // TODO(KK): retries?\n    // TODO(KK): tests\n    on(callback, ms, account, timeout) {\n        if (ms < 1000)\n            throw Error(\"Let's not go crazy with the queries...\");\n        // Account for the fact that Subgraph has lag and will insert events with the timestamp of the event from blockchain.\n        const clockSkew = 25000;\n        // Convert millisecond-based time to second-based time (which Subgraph uses).\n        let eventQueryTimestamp = Math.floor((new Date().getTime() - clockSkew) / 1000);\n        let isUnsubscribed = false;\n        const unsubscribe = () => {\n            isUnsubscribed = true;\n        };\n        const pollingStep = async () => {\n            if (isUnsubscribed) {\n                return;\n            }\n            const allEvents = await listAllResults((paging) => this.listEvents({\n                account: account,\n                timestamp_gt: eventQueryTimestamp,\n            }, paging, {\n                orderBy: \"timestamp\",\n                orderDirection: \"asc\",\n            }));\n            // Filter next events by last timestamp of an event.\n            // NOTE: Make sure to order events by timestamp in ascending order.\n            const lastEvent = _.last(allEvents);\n            if (lastEvent) {\n                callback(allEvents, unsubscribe);\n                // Next event polling is done for events that have a timestamp later than the current latest event.\n                eventQueryTimestamp = lastEvent.timestamp;\n            }\n            // This solution sets the interval based on last query returning, opposed to not taking request-response cycles into account at all.\n            // This solution is more friendly to the Subgraph & more effective resource-wise with slow internet.\n            return setTimeout(() => {\n                // Fire and forget\n                pollingStep();\n            }, ms);\n        };\n        if (timeout) {\n            setTimeout(() => {\n                unsubscribe();\n            }, timeout);\n        }\n        // Fire and forget\n        pollingStep();\n        return unsubscribe;\n    }\n}\n/**\n * A recursive function to fetch all possible results of a paged query.\n * @param pagedQuery A paginated query that takes {@link Paging} as input.\n */\nexport const listAllResults = async (pagedQuery) => {\n    const listAllRecursively = async (paging) => {\n        const pagedResult = await pagedQuery(paging);\n        if (!pagedResult.nextPaging)\n            return pagedResult.data;\n        const nextResults = await listAllRecursively(pagedResult.nextPaging);\n        return pagedResult.data.concat(nextResults);\n    };\n    return listAllRecursively(createLastIdPaging({ take: 999 }));\n};\n//# sourceMappingURL=Query.js.map"]},"metadata":{},"sourceType":"module"}