{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"../../compile/util\");\nvar def = {\n  keyword: \"allOf\",\n  schemaType: \"array\",\n  code: function code(cxt) {\n    var gen = cxt.gen,\n      schema = cxt.schema,\n      it = cxt.it;\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n    var valid = gen.name(\"valid\");\n    schema.forEach(function (sch, i) {\n      if ((0, util_1.alwaysValidSchema)(it, sch)) return;\n      var schCxt = cxt.subschema({\n        keyword: \"allOf\",\n        schemaProp: i\n      }, valid);\n      cxt.ok(valid);\n      cxt.mergeEvaluated(schCxt);\n    });\n  }\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/allOf.ts"],"names":[],"mappings":";;;;;AAEA,IAAA,MAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;AAEA,IAAM,GAAG,GAA0B;EACjC,OAAO,EAAE,OAAO;EAChB,UAAU,EAAE,OAAO;EACnB,IAAI,gBAAC,GAAe,EAAA;IAClB,IAAO,GAAG,GAAgB,GAAG,CAAtB,GAAG;MAAE,MAAM,GAAQ,GAAG,CAAjB,MAAM;MAAE,EAAE,GAAI,GAAG,CAAT,EAAE;IACtB;IACA,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC;IACvE,IAAM,KAAK,GAAG,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC;IAC/B,MAAM,CAAC,OAAO,CAAC,UAAC,GAAc,EAAE,CAAS,EAAI;MAC3C,IAAI,CAAA,CAAA,EAAA,MAAA,CAAA,iBAAiB,EAAC,EAAE,EAAE,GAAG,CAAC,EAAE;MAChC,IAAM,MAAM,GAAG,GAAG,CAAC,SAAS,CAAC;QAAC,OAAO,EAAE,OAAO;QAAE,UAAU,EAAE;MAAC,CAAC,EAAE,KAAK,CAAC;MACtE,GAAG,CAAC,EAAE,CAAC,KAAK,CAAC;MACb,GAAG,CAAC,cAAc,CAAC,MAAM,CAAC;IAC5B,CAAC,CAAC;EACJ;CACD;AAED,OAAA,CAAA,OAAA,GAAe,GAAG","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"allOf\",\n    schemaType: \"array\",\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        const valid = gen.name(\"valid\");\n        schema.forEach((sch, i) => {\n            if ((0, util_1.alwaysValidSchema)(it, sch))\n                return;\n            const schCxt = cxt.subschema({ keyword: \"allOf\", schemaProp: i }, valid);\n            cxt.ok(valid);\n            cxt.mergeEvaluated(schCxt);\n        });\n    },\n};\nexports.default = def;\n//# sourceMappingURL=allOf.js.map"]},"metadata":{},"sourceType":"script"}