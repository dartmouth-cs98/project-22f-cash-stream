{"ast":null,"code":"import _regeneratorRuntime from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createClass from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { ethers } from \"ethers\";\nimport { SFError } from \"./SFError\";\n/**\n * Operation Helper Class\n * @description A helper class to create `Operation` objects which can be executed or batched.\n */\nvar Operation = /*#__PURE__*/_createClass(function Operation(txn, type) {\n  var _this = this;\n  _classCallCheck(this, Operation);\n  /**\n   * Executes the operation via the provided signer.\n   * @description Populates all fields of the transaction, signs it and sends it to the network.\n   * @param signer The signer of the transacation\n   * @returns {ethers.providers.TransactionResponse} A TransactionResponse object which can be awaited\n   */\n  this.exec = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(signer) {\n      var populatedTransaction;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return _this.getPopulatedTransactionRequest(signer);\n            case 3:\n              populatedTransaction = _context.sent;\n              _context.next = 6;\n              return signer.sendTransaction(populatedTransaction);\n            case 6:\n              return _context.abrupt(\"return\", _context.sent);\n            case 9:\n              _context.prev = 9;\n              _context.t0 = _context[\"catch\"](0);\n              throw new SFError({\n                type: \"EXECUTE_TRANSACTION\",\n                customMessage: \"There was an error executing the transaction\",\n                errorObject: _context.t0\n              });\n            case 12:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 9]]);\n    }));\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /**\n   * Get the populated transaction by awaiting `populateTransactionPromise`.\n   * @description Note that we need to populate the txn with the signer.\n   * @returns {Promise<TransactionRequest>}\n   */\n  this.getPopulatedTransactionRequest = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(signer) {\n      var prePopulated;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return _this.populateTransactionPromise;\n            case 3:\n              prePopulated = _context2.sent;\n              _context2.next = 6;\n              return signer.populateTransaction(prePopulated);\n            case 6:\n              return _context2.abrupt(\"return\", _context2.sent);\n            case 9:\n              _context2.prev = 9;\n              _context2.t0 = _context2[\"catch\"](0);\n              throw new SFError({\n                type: \"POPULATE_TRANSACTION\",\n                customMessage: \"There was an error populating the transaction\",\n                errorObject: _context2.t0\n              });\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[0, 9]]);\n    }));\n    return function (_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /**\n   * Signs the populated transaction via the provided signer (what you intend on sending to the network).\n   * @param signer The signer of the transacation\n   * @returns {Promise<string>} Fully serialized, signed transaction\n   */\n  this.getSignedTransaction = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(signer) {\n      var populatedTransaction, signedTxn;\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.prev = 0;\n              _context3.next = 3;\n              return _this.getPopulatedTransactionRequest(signer);\n            case 3:\n              populatedTransaction = _context3.sent;\n              _context3.next = 6;\n              return signer.signTransaction(populatedTransaction);\n            case 6:\n              signedTxn = _context3.sent;\n              return _context3.abrupt(\"return\", signedTxn);\n            case 10:\n              _context3.prev = 10;\n              _context3.t0 = _context3[\"catch\"](0);\n              throw new SFError({\n                type: \"SIGN_TRANSACTION\",\n                customMessage: \"There was an error signing the transaction\",\n                errorObject: _context3.t0\n              });\n            case 13:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, null, [[0, 10]]);\n    }));\n    return function (_x3) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  /**\n   * Gets the transaction hash of the transaction.\n   * @description Calculates this by getting the keccak256 hash of the signedTxn.\n   * @param signer The signer of the transacation\n   * @returns {Promise<string>} The transaction hash of the transaction\n   */\n  this.getTransactionHash = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(signer) {\n      var signedTxn;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return _this.getSignedTransaction(signer);\n            case 2:\n              signedTxn = _context4.sent;\n              return _context4.abrupt(\"return\", ethers.utils.keccak256(signedTxn));\n            case 4:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    return function (_x4) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  this.populateTransactionPromise = txn;\n  this.type = type;\n});\nexport { Operation as default };","map":{"version":3,"sources":["../../src/Operation.ts"],"names":[],"mappings":";;;;AACA,SAAS,MAAM,QAAQ,QAAQ;AAE/B,SAAS,OAAO,QAAQ,WAAW;AAWnC;;;AAGG;AAHH,IAIqB,SAAS,6BAI1B,mBACI,GAAyC,EACzC,IAAmB,EAAA;EAAA;EAAA;EAMvB;;;;;AAKG;EACH,IAAA,CAAA,IAAI;IAAA,sEAAG,iBACH,MAAqB;MAAA;MAAA;QAAA;UAAA;YAAA;cAAA;cAAA;cAAA,OAIP,KAAI,CAAC,8BAA8B,CAAC,MAAM,CAAC;YAAA;cAD/C,oBAAoB;cAAA;cAAA,OAEb,MAAM,CAAC,eAAe,CAAC,oBAAoB,CAAC;YAAA;cAAA;YAAA;cAAA;cAAA;cAAA,MAEnD,IAAI,OAAO,CAAC;gBACd,IAAI,EAAE,qBAAqB;gBAC3B,aAAa,EAAE,8CAA8C;gBAC7D,WAAW;eACd,CAAC;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAET;IAAA;MAAA;IAAA;EAAA;EAED;;;;AAIG;EACH,IAAA,CAAA,8BAA8B;IAAA,uEAAG,kBAC7B,MAAqB;MAAA;MAAA;QAAA;UAAA;YAAA;cAAA;cAAA;cAAA,OAGU,KAAI,CAAC,0BAA0B;YAAA;cAApD,YAAY;cAAA;cAAA,OACL,MAAM,CAAC,mBAAmB,CAAC,YAAY,CAAC;YAAA;cAAA;YAAA;cAAA;cAAA;cAAA,MAG/C,IAAI,OAAO,CAAC;gBACd,IAAI,EAAE,sBAAsB;gBAC5B,aAAa,EAAE,+CAA+C;gBAC9D,WAAW;eACd,CAAC;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAET;IAAA;MAAA;IAAA;EAAA;EACD;;;;AAIG;EACH,IAAA,CAAA,oBAAoB;IAAA,uEAAG,kBAAO,MAAqB;MAAA;MAAA;QAAA;UAAA;YAAA;cAAA;cAAA;cAAA,OAGjC,KAAI,CAAC,8BAA8B,CAAC,MAAM,CAAC;YAAA;cAD/C,oBAAoB;cAAA;cAAA,OAEF,MAAM,CAAC,eAAe,CAC1C,oBAAoB,CACvB;YAAA;cAFK,SAAS;cAAA,kCAGR,SAAS;YAAA;cAAA;cAAA;cAAA,MAEV,IAAI,OAAO,CAAC;gBACd,IAAI,EAAE,kBAAkB;gBACxB,aAAa,EAAE,4CAA4C;gBAC3D,WAAW;eACd,CAAC;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAET;IAAA;MAAA;IAAA;EAAA;EAED;;;;;AAKG;EACH,IAAA,CAAA,kBAAkB;IAAA,uEAAG,kBAAO,MAAqB;MAAA;MAAA;QAAA;UAAA;YAAA;cAAA;cAAA,OACrB,KAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC;YAAA;cAAnD,SAAS;cAAA,kCACR,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,SAAS,CAAC;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAC3C;IAAA;MAAA;IAAA;EAAA;EA7EG,IAAI,CAAC,0BAA0B,GAAG,GAAG;EACrC,IAAI,CAAC,IAAI,GAAG,IAAI;AACpB,CAAC;AAAA,SAVgB,SAAS","sourceRoot":"","sourcesContent":["import { ethers } from \"ethers\";\nimport { SFError } from \"./SFError\";\n/**\n * Operation Helper Class\n * @description A helper class to create `Operation` objects which can be executed or batched.\n */\nexport default class Operation {\n    constructor(txn, type) {\n        /**\n         * Executes the operation via the provided signer.\n         * @description Populates all fields of the transaction, signs it and sends it to the network.\n         * @param signer The signer of the transacation\n         * @returns {ethers.providers.TransactionResponse} A TransactionResponse object which can be awaited\n         */\n        this.exec = async (signer) => {\n            try {\n                const populatedTransaction = await this.getPopulatedTransactionRequest(signer);\n                return await signer.sendTransaction(populatedTransaction);\n            }\n            catch (err) {\n                throw new SFError({\n                    type: \"EXECUTE_TRANSACTION\",\n                    customMessage: \"There was an error executing the transaction\",\n                    errorObject: err,\n                });\n            }\n        };\n        /**\n         * Get the populated transaction by awaiting `populateTransactionPromise`.\n         * @description Note that we need to populate the txn with the signer.\n         * @returns {Promise<TransactionRequest>}\n         */\n        this.getPopulatedTransactionRequest = async (signer) => {\n            try {\n                const prePopulated = await this.populateTransactionPromise;\n                return await signer.populateTransaction(prePopulated);\n            }\n            catch (err) {\n                /* istanbul ignore next */\n                throw new SFError({\n                    type: \"POPULATE_TRANSACTION\",\n                    customMessage: \"There was an error populating the transaction\",\n                    errorObject: err,\n                });\n            }\n        };\n        /**\n         * Signs the populated transaction via the provided signer (what you intend on sending to the network).\n         * @param signer The signer of the transacation\n         * @returns {Promise<string>} Fully serialized, signed transaction\n         */\n        this.getSignedTransaction = async (signer) => {\n            try {\n                const populatedTransaction = await this.getPopulatedTransactionRequest(signer);\n                const signedTxn = await signer.signTransaction(populatedTransaction);\n                return signedTxn;\n            }\n            catch (err) {\n                throw new SFError({\n                    type: \"SIGN_TRANSACTION\",\n                    customMessage: \"There was an error signing the transaction\",\n                    errorObject: err,\n                });\n            }\n        };\n        /**\n         * Gets the transaction hash of the transaction.\n         * @description Calculates this by getting the keccak256 hash of the signedTxn.\n         * @param signer The signer of the transacation\n         * @returns {Promise<string>} The transaction hash of the transaction\n         */\n        this.getTransactionHash = async (signer) => {\n            const signedTxn = await this.getSignedTransaction(signer);\n            return ethers.utils.keccak256(signedTxn);\n        };\n        this.populateTransactionPromise = txn;\n        this.type = type;\n    }\n}\n//# sourceMappingURL=Operation.js.map"]},"metadata":{},"sourceType":"module"}