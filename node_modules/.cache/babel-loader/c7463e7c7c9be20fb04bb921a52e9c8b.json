{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateAdditionalItems = void 0;\nvar codegen_1 = require(\"../../compile/codegen\");\nvar util_1 = require(\"../../compile/util\");\nvar error = {\n  message: function message(_ref) {\n    var len = _ref.params.len;\n    return (0, codegen_1.str)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"must NOT have more than \", \" items\"])), len);\n  },\n  params: function params(_ref2) {\n    var len = _ref2.params.len;\n    return (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"{limit: \", \"}\"])), len);\n  }\n};\nvar def = {\n  keyword: \"additionalItems\",\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error: error,\n  code: function code(cxt) {\n    var parentSchema = cxt.parentSchema,\n      it = cxt.it;\n    var items = parentSchema.items;\n    if (!Array.isArray(items)) {\n      (0, util_1.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n      return;\n    }\n    validateAdditionalItems(cxt, items);\n  }\n};\nfunction validateAdditionalItems(cxt, items) {\n  var gen = cxt.gen,\n    schema = cxt.schema,\n    data = cxt.data,\n    keyword = cxt.keyword,\n    it = cxt.it;\n  it.items = true;\n  var len = gen.const(\"len\", (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \".length\"])), data));\n  if (schema === false) {\n    cxt.setParams({\n      len: items.length\n    });\n    cxt.pass((0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \" <= \", \"\"])), len, items.length));\n  } else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n    var valid = gen.var(\"valid\", (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \" <= \", \"\"])), len, items.length)); // TODO var\n    gen.if((0, codegen_1.not)(valid), function () {\n      return validateItems(valid);\n    });\n    cxt.ok(valid);\n  }\n  function validateItems(valid) {\n    gen.forRange(\"i\", items.length, len, function (i) {\n      cxt.subschema({\n        keyword: keyword,\n        dataProp: i,\n        dataPropType: util_1.Type.Num\n      }, valid);\n      if (!it.allErrors) gen.if((0, codegen_1.not)(valid), function () {\n        return gen.break();\n      });\n    });\n  }\n}\nexports.validateAdditionalItems = validateAdditionalItems;\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/additionalItems.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateAdditionalItems = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: \"additionalItems\",\n    type: \"array\",\n    schemaType: [\"boolean\", \"object\"],\n    before: \"uniqueItems\",\n    error,\n    code(cxt) {\n        const { parentSchema, it } = cxt;\n        const { items } = parentSchema;\n        if (!Array.isArray(items)) {\n            (0, util_1.checkStrictMode)(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n            return;\n        }\n        validateAdditionalItems(cxt, items);\n    },\n};\nfunction validateAdditionalItems(cxt, items) {\n    const { gen, schema, data, keyword, it } = cxt;\n    it.items = true;\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    if (schema === false) {\n        cxt.setParams({ len: items.length });\n        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);\n    }\n    else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.var(\"valid\", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var\n        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));\n        cxt.ok(valid);\n    }\n    function validateItems(valid) {\n        gen.forRange(\"i\", items.length, len, (i) => {\n            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);\n            if (!it.allErrors)\n                gen.if((0, codegen_1.not)(valid), () => gen.break());\n        });\n    }\n}\nexports.validateAdditionalItems = validateAdditionalItems;\nexports.default = def;\n//# sourceMappingURL=additionalItems.js.map"]},"metadata":{},"sourceType":"script"}