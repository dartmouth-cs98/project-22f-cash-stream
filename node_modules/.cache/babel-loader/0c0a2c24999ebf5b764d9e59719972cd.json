{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _taggedTemplateLiteral = require(\"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20, _templateObject21, _templateObject22, _templateObject23, _templateObject24, _templateObject25, _templateObject26, _templateObject27, _templateObject28, _templateObject29, _templateObject30, _templateObject31, _templateObject32, _templateObject33, _templateObject34, _templateObject35, _templateObject36, _templateObject37, _templateObject38, _templateObject39;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nvar boolSchema_1 = require(\"./boolSchema\");\nvar dataType_1 = require(\"./dataType\");\nvar applicability_1 = require(\"./applicability\");\nvar dataType_2 = require(\"./dataType\");\nvar defaults_1 = require(\"./defaults\");\nvar keyword_1 = require(\"./keyword\");\nvar subschema_1 = require(\"./subschema\");\nvar codegen_1 = require(\"../codegen\");\nvar names_1 = require(\"../names\");\nvar resolve_1 = require(\"../resolve\");\nvar util_1 = require(\"../util\");\nvar errors_1 = require(\"../errors\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it);\n      return;\n    }\n  }\n  validateFunction(it, function () {\n    return (0, boolSchema_1.topBoolOrEmptySchema)(it);\n  });\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction(_ref, body) {\n  var gen = _ref.gen,\n    validateName = _ref.validateName,\n    schema = _ref.schema,\n    schemaEnv = _ref.schemaEnv,\n    opts = _ref.opts;\n  if (opts.code.es5) {\n    gen.func(validateName, (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \", \", \"\"])), names_1.default.data, names_1.default.valCxt), schemaEnv.$async, function () {\n      gen.code((0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\\\"use strict\\\"; \", \"\"])), funcSourceUrl(schema, opts)));\n      destructureValCxtES5(gen, opts);\n      gen.code(body);\n    });\n  } else {\n    gen.func(validateName, (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \", \", \"\"])), names_1.default.data, destructureValCxt(opts)), schemaEnv.$async, function () {\n      return gen.code(funcSourceUrl(schema, opts)).code(body);\n    });\n  }\n}\nfunction destructureValCxt(opts) {\n  return (0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"{\", \"=\\\"\\\", \", \", \", \", \", \"=\", \"\", \"}={}\"])), names_1.default.instancePath, names_1.default.parentData, names_1.default.parentDataProperty, names_1.default.rootData, names_1.default.data, opts.dynamicRef ? (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\", \", \"={}\"])), names_1.default.dynamicAnchors) : codegen_1.nil);\n}\nfunction destructureValCxtES5(gen, opts) {\n  gen.if(names_1.default.valCxt, function () {\n    gen.var(names_1.default.instancePath, (0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.instancePath));\n    gen.var(names_1.default.parentData, (0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.parentData));\n    gen.var(names_1.default.parentDataProperty, (0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.parentDataProperty));\n    gen.var(names_1.default.rootData, (0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.rootData));\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.dynamicAnchors));\n  }, function () {\n    gen.var(names_1.default.instancePath, (0, codegen_1._)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"\\\"\\\"\"]))));\n    gen.var(names_1.default.parentData, (0, codegen_1._)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"undefined\"]))));\n    gen.var(names_1.default.parentDataProperty, (0, codegen_1._)(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"undefined\"]))));\n    gen.var(names_1.default.rootData, names_1.default.data);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"{}\"]))));\n  });\n}\nfunction topSchemaObjCode(it) {\n  var schema = it.schema,\n    opts = it.opts,\n    gen = it.gen;\n  validateFunction(it, function () {\n    if (opts.$comment && schema.$comment) commentKeyword(it);\n    checkNoDefault(it);\n    gen.let(names_1.default.vErrors, null);\n    gen.let(names_1.default.errors, 0);\n    if (opts.unevaluated) resetEvaluated(it);\n    typeAndKeywords(it);\n    returnResults(it);\n  });\n  return;\n}\nfunction resetEvaluated(it) {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  var gen = it.gen,\n    validateName = it.validateName;\n  it.evaluated = gen.const(\"evaluated\", (0, codegen_1._)(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\"\", \".evaluated\"])), validateName));\n  gen.if((0, codegen_1._)(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral([\"\", \".dynamicProps\"])), it.evaluated), function () {\n    return gen.assign((0, codegen_1._)(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral([\"\", \".props\"])), it.evaluated), (0, codegen_1._)(_templateObject18 || (_templateObject18 = _taggedTemplateLiteral([\"undefined\"]))));\n  });\n  gen.if((0, codegen_1._)(_templateObject19 || (_templateObject19 = _taggedTemplateLiteral([\"\", \".dynamicItems\"])), it.evaluated), function () {\n    return gen.assign((0, codegen_1._)(_templateObject20 || (_templateObject20 = _taggedTemplateLiteral([\"\", \".items\"])), it.evaluated), (0, codegen_1._)(_templateObject21 || (_templateObject21 = _taggedTemplateLiteral([\"undefined\"]))));\n  });\n}\nfunction funcSourceUrl(schema, opts) {\n  var schId = typeof schema == \"object\" && schema[opts.schemaId];\n  return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)(_templateObject22 || (_templateObject22 = _taggedTemplateLiteral([\"/*# sourceURL=\", \" */\"])), schId) : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid);\n      return;\n    }\n  }\n  (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules(_ref2) {\n  var schema = _ref2.schema,\n    self = _ref2.self;\n  if (typeof schema == \"boolean\") return !schema;\n  for (var key in schema) {\n    if (self.RULES.all[key]) return true;\n  }\n  return false;\n}\nfunction isSchemaObj(it) {\n  return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n  var schema = it.schema,\n    gen = it.gen,\n    opts = it.opts;\n  if (opts.$comment && schema.$comment) commentKeyword(it);\n  updateContext(it);\n  checkAsyncSchema(it);\n  var errsCount = gen.const(\"_errs\", names_1.default.errors);\n  typeAndKeywords(it, errsCount);\n  // TODO var\n  gen.var(valid, (0, codegen_1._)(_templateObject23 || (_templateObject23 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), errsCount, names_1.default.errors));\n}\nfunction checkKeywords(it) {\n  (0, util_1.checkUnknownRules)(it);\n  checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);\n  var types = (0, dataType_1.getSchemaTypes)(it.schema);\n  var checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n  schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n  var schema = it.schema,\n    errSchemaPath = it.errSchemaPath,\n    opts = it.opts,\n    self = it.self;\n  if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n    self.logger.warn(\"$ref: keywords ignored in schema at path \\\"\".concat(errSchemaPath, \"\\\"\"));\n  }\n}\nfunction checkNoDefault(it) {\n  var schema = it.schema,\n    opts = it.opts;\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n  }\n}\nfunction updateContext(it) {\n  var schId = it.schema[it.opts.schemaId];\n  if (schId) it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword(_ref3) {\n  var gen = _ref3.gen,\n    schemaEnv = _ref3.schemaEnv,\n    schema = _ref3.schema,\n    errSchemaPath = _ref3.errSchemaPath,\n    opts = _ref3.opts;\n  var msg = schema.$comment;\n  if (opts.$comment === true) {\n    gen.code((0, codegen_1._)(_templateObject24 || (_templateObject24 = _taggedTemplateLiteral([\"\", \".logger.log(\", \")\"])), names_1.default.self, msg));\n  } else if (typeof opts.$comment == \"function\") {\n    var schemaPath = (0, codegen_1.str)(_templateObject25 || (_templateObject25 = _taggedTemplateLiteral([\"\", \"/$comment\"])), errSchemaPath);\n    var rootName = gen.scopeValue(\"root\", {\n      ref: schemaEnv.root\n    });\n    gen.code((0, codegen_1._)(_templateObject26 || (_templateObject26 = _taggedTemplateLiteral([\"\", \".opts.$comment(\", \", \", \", \", \".schema)\"])), names_1.default.self, msg, schemaPath, rootName));\n  }\n}\nfunction returnResults(it) {\n  var gen = it.gen,\n    schemaEnv = it.schemaEnv,\n    validateName = it.validateName,\n    ValidationError = it.ValidationError,\n    opts = it.opts;\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if((0, codegen_1._)(_templateObject27 || (_templateObject27 = _taggedTemplateLiteral([\"\", \" === 0\"])), names_1.default.errors), function () {\n      return gen.return(names_1.default.data);\n    }, function () {\n      return gen.throw((0, codegen_1._)(_templateObject28 || (_templateObject28 = _taggedTemplateLiteral([\"new \", \"(\", \")\"])), ValidationError, names_1.default.vErrors));\n    });\n  } else {\n    gen.assign((0, codegen_1._)(_templateObject29 || (_templateObject29 = _taggedTemplateLiteral([\"\", \".errors\"])), validateName), names_1.default.vErrors);\n    if (opts.unevaluated) assignEvaluated(it);\n    gen.return((0, codegen_1._)(_templateObject30 || (_templateObject30 = _taggedTemplateLiteral([\"\", \" === 0\"])), names_1.default.errors));\n  }\n}\nfunction assignEvaluated(_ref4) {\n  var gen = _ref4.gen,\n    evaluated = _ref4.evaluated,\n    props = _ref4.props,\n    items = _ref4.items;\n  if (props instanceof codegen_1.Name) gen.assign((0, codegen_1._)(_templateObject31 || (_templateObject31 = _taggedTemplateLiteral([\"\", \".props\"])), evaluated), props);\n  if (items instanceof codegen_1.Name) gen.assign((0, codegen_1._)(_templateObject32 || (_templateObject32 = _taggedTemplateLiteral([\"\", \".items\"])), evaluated), items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n  var gen = it.gen,\n    schema = it.schema,\n    data = it.data,\n    allErrors = it.allErrors,\n    opts = it.opts,\n    self = it.self;\n  var RULES = self.RULES;\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n    gen.block(function () {\n      return keywordCode(it, \"$ref\", RULES.all.$ref.definition);\n    }); // TODO typecast\n    return;\n  }\n  if (!opts.jtd) checkStrictTypes(it, types);\n  gen.block(function () {\n    var _iterator = _createForOfIteratorHelper(RULES.rules),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var group = _step.value;\n        groupKeywords(group);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    groupKeywords(RULES.post);\n  });\n  function groupKeywords(group) {\n    if (!(0, applicability_1.shouldUseGroup)(schema, group)) return;\n    if (group.type) {\n      gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n      iterateKeywords(it, group);\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else();\n        (0, dataType_2.reportTypeError)(it);\n      }\n      gen.endIf();\n    } else {\n      iterateKeywords(it, group);\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if((0, codegen_1._)(_templateObject33 || (_templateObject33 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), names_1.default.errors, errsCount || 0));\n  }\n}\nfunction iterateKeywords(it, group) {\n  var gen = it.gen,\n    schema = it.schema,\n    useDefaults = it.opts.useDefaults;\n  if (useDefaults) (0, defaults_1.assignDefaults)(it, group.type);\n  gen.block(function () {\n    var _iterator2 = _createForOfIteratorHelper(group.rules),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var rule = _step2.value;\n        if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n          keywordCode(it, rule.keyword, rule.definition, group.type);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  });\n}\nfunction checkStrictTypes(it, types) {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return;\n  checkContextTypes(it, types);\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);\n  checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n  if (!types.length) return;\n  if (!it.dataTypes.length) {\n    it.dataTypes = types;\n    return;\n  }\n  types.forEach(function (t) {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, \"type \\\"\".concat(t, \"\\\" not allowed by context \\\"\").concat(it.dataTypes.join(\",\"), \"\\\"\"));\n    }\n  });\n  it.dataTypes = it.dataTypes.filter(function (t) {\n    return includesType(types, t);\n  });\n}\nfunction checkMultipleTypes(it, ts) {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n  }\n}\nfunction checkKeywordTypes(it, ts) {\n  var rules = it.self.RULES.all;\n  for (var keyword in rules) {\n    var rule = rules[keyword];\n    if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n      var type = rule.definition.type;\n      if (type.length && !type.some(function (t) {\n        return hasApplicableType(ts, t);\n      })) {\n        strictTypesError(it, \"missing type \\\"\".concat(type.join(\",\"), \"\\\" for keyword \\\"\").concat(keyword, \"\\\"\"));\n      }\n    }\n  }\n}\nfunction hasApplicableType(schTs, kwdT) {\n  return schTs.includes(kwdT) || kwdT === \"number\" && schTs.includes(\"integer\");\n}\nfunction includesType(ts, t) {\n  return ts.includes(t) || t === \"integer\" && ts.includes(\"number\");\n}\nfunction strictTypesError(it, msg) {\n  var schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n  msg += \" at \\\"\".concat(schemaPath, \"\\\" (strictTypes)\");\n  (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nvar KeywordCxt = /*#__PURE__*/function () {\n  function KeywordCxt(it, def, keyword) {\n    _classCallCheck(this, KeywordCxt);\n    (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n    this.gen = it.gen;\n    this.allErrors = it.allErrors;\n    this.keyword = keyword;\n    this.data = it.data;\n    this.schema = it.schema[keyword];\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n    this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n    this.schemaType = def.schemaType;\n    this.parentSchema = it.schema;\n    this.params = {};\n    this.it = it;\n    this.def = def;\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n    } else {\n      this.schemaCode = this.schemaValue;\n      if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(\"\".concat(keyword, \" value must be \").concat(JSON.stringify(def.schemaType)));\n      }\n    }\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n    }\n  }\n  _createClass(KeywordCxt, [{\n    key: \"result\",\n    value: function result(condition, successAction, failAction) {\n      this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n    }\n  }, {\n    key: \"failResult\",\n    value: function failResult(condition, successAction, failAction) {\n      this.gen.if(condition);\n      if (failAction) failAction();else this.error();\n      if (successAction) {\n        this.gen.else();\n        successAction();\n        if (this.allErrors) this.gen.endIf();\n      } else {\n        if (this.allErrors) this.gen.endIf();else this.gen.else();\n      }\n    }\n  }, {\n    key: \"pass\",\n    value: function pass(condition, failAction) {\n      this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(condition) {\n      if (condition === undefined) {\n        this.error();\n        if (!this.allErrors) this.gen.if(false); // this branch will be removed by gen.optimize\n        return;\n      }\n      this.gen.if(condition);\n      this.error();\n      if (this.allErrors) this.gen.endIf();else this.gen.else();\n    }\n  }, {\n    key: \"fail$data\",\n    value: function fail$data(condition) {\n      if (!this.$data) return this.fail(condition);\n      var schemaCode = this.schemaCode;\n      this.fail((0, codegen_1._)(_templateObject34 || (_templateObject34 = _taggedTemplateLiteral([\"\", \" !== undefined && (\", \")\"])), schemaCode, (0, codegen_1.or)(this.invalid$data(), condition)));\n    }\n  }, {\n    key: \"error\",\n    value: function error(append, errorParams, errorPaths) {\n      if (errorParams) {\n        this.setParams(errorParams);\n        this._error(append, errorPaths);\n        this.setParams({});\n        return;\n      }\n      this._error(append, errorPaths);\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(append, errorPaths) {\n      ;\n      (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n  }, {\n    key: \"$dataError\",\n    value: function $dataError() {\n      (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition');\n      (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n    }\n  }, {\n    key: \"ok\",\n    value: function ok(cond) {\n      if (!this.allErrors) this.gen.if(cond);\n    }\n  }, {\n    key: \"setParams\",\n    value: function setParams(obj, assign) {\n      if (assign) Object.assign(this.params, obj);else this.params = obj;\n    }\n  }, {\n    key: \"block$data\",\n    value: function block$data(valid, codeBlock) {\n      var _this = this;\n      var $dataValid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : codegen_1.nil;\n      this.gen.block(function () {\n        _this.check$data(valid, $dataValid);\n        codeBlock();\n      });\n    }\n  }, {\n    key: \"check$data\",\n    value: function check$data() {\n      var valid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : codegen_1.nil;\n      var $dataValid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : codegen_1.nil;\n      if (!this.$data) return;\n      var gen = this.gen,\n        schemaCode = this.schemaCode,\n        schemaType = this.schemaType,\n        def = this.def;\n      gen.if((0, codegen_1.or)((0, codegen_1._)(_templateObject35 || (_templateObject35 = _taggedTemplateLiteral([\"\", \" === undefined\"])), schemaCode), $dataValid));\n      if (valid !== codegen_1.nil) gen.assign(valid, true);\n      if (schemaType.length || def.validateSchema) {\n        gen.elseIf(this.invalid$data());\n        this.$dataError();\n        if (valid !== codegen_1.nil) gen.assign(valid, false);\n      }\n      gen.else();\n    }\n  }, {\n    key: \"invalid$data\",\n    value: function invalid$data() {\n      var gen = this.gen,\n        schemaCode = this.schemaCode,\n        schemaType = this.schemaType,\n        def = this.def,\n        it = this.it;\n      return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n      function wrong$DataType() {\n        if (schemaType.length) {\n          /* istanbul ignore if */\n          if (!(schemaCode instanceof codegen_1.Name)) throw new Error(\"ajv implementation error\");\n          var st = Array.isArray(schemaType) ? schemaType : [schemaType];\n          return (0, codegen_1._)(_templateObject36 || (_templateObject36 = _taggedTemplateLiteral([\"\", \"\"])), (0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong));\n        }\n        return codegen_1.nil;\n      }\n      function invalid$DataSchema() {\n        if (def.validateSchema) {\n          var validateSchemaRef = gen.scopeValue(\"validate$data\", {\n            ref: def.validateSchema\n          }); // TODO value.code for standalone\n          return (0, codegen_1._)(_templateObject37 || (_templateObject37 = _taggedTemplateLiteral([\"!\", \"(\", \")\"])), validateSchemaRef, schemaCode);\n        }\n        return codegen_1.nil;\n      }\n    }\n  }, {\n    key: \"subschema\",\n    value: function subschema(appl, valid) {\n      var subschema = (0, subschema_1.getSubschema)(this.it, appl);\n      (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n      (0, subschema_1.extendSubschemaMode)(subschema, appl);\n      var nextContext = _objectSpread(_objectSpread(_objectSpread({}, this.it), subschema), {}, {\n        items: undefined,\n        props: undefined\n      });\n      subschemaCode(nextContext, valid);\n      return nextContext;\n    }\n  }, {\n    key: \"mergeEvaluated\",\n    value: function mergeEvaluated(schemaCxt, toName) {\n      var it = this.it,\n        gen = this.gen;\n      if (!it.opts.unevaluated) return;\n      if (it.props !== true && schemaCxt.props !== undefined) {\n        it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n      }\n      if (it.items !== true && schemaCxt.items !== undefined) {\n        it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n      }\n    }\n  }, {\n    key: \"mergeValidEvaluated\",\n    value: function mergeValidEvaluated(schemaCxt, valid) {\n      var _this2 = this;\n      var it = this.it,\n        gen = this.gen;\n      if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n        gen.if(valid, function () {\n          return _this2.mergeEvaluated(schemaCxt, codegen_1.Name);\n        });\n        return true;\n      }\n    }\n  }]);\n  return KeywordCxt;\n}();\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n  var cxt = new KeywordCxt(it, def, keyword);\n  if (\"code\" in def) {\n    def.code(cxt, ruleType);\n  } else if (cxt.$data && def.validate) {\n    (0, keyword_1.funcKeywordCode)(cxt, def);\n  } else if (\"macro\" in def) {\n    (0, keyword_1.macroKeywordCode)(cxt, def);\n  } else if (def.compile || def.validate) {\n    (0, keyword_1.funcKeywordCode)(cxt, def);\n  }\n}\nvar JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nvar RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, _ref5) {\n  var dataLevel = _ref5.dataLevel,\n    dataNames = _ref5.dataNames,\n    dataPathArr = _ref5.dataPathArr;\n  var jsonPointer;\n  var data;\n  if ($data === \"\") return names_1.default.rootData;\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(\"Invalid JSON-pointer: \".concat($data));\n    jsonPointer = $data;\n    data = names_1.default.rootData;\n  } else {\n    var matches = RELATIVE_JSON_POINTER.exec($data);\n    if (!matches) throw new Error(\"Invalid JSON-pointer: \".concat($data));\n    var up = +matches[1];\n    jsonPointer = matches[2];\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up));\n      return dataPathArr[dataLevel - up];\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up));\n    data = dataNames[dataLevel - up];\n    if (!jsonPointer) return data;\n  }\n  var expr = data;\n  var segments = jsonPointer.split(\"/\");\n  var _iterator3 = _createForOfIteratorHelper(segments),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var segment = _step3.value;\n      if (segment) {\n        data = (0, codegen_1._)(_templateObject38 || (_templateObject38 = _taggedTemplateLiteral([\"\", \"\", \"\"])), data, (0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment)));\n        expr = (0, codegen_1._)(_templateObject39 || (_templateObject39 = _taggedTemplateLiteral([\"\", \" && \", \"\"])), expr, data);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return expr;\n  function errorMsg(pointerType, up) {\n    return \"Cannot access \".concat(pointerType, \" \").concat(up, \" levels up, current level is \").concat(dataLevel);\n  }\n}\nexports.getData = getData;","map":{"version":3,"sources":["../../../lib/compile/validate/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = require(\"./boolSchema\");\nconst dataType_1 = require(\"./dataType\");\nconst applicability_1 = require(\"./applicability\");\nconst dataType_2 = require(\"./dataType\");\nconst defaults_1 = require(\"./defaults\");\nconst keyword_1 = require(\"./keyword\");\nconst subschema_1 = require(\"./subschema\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst resolve_1 = require(\"../resolve\");\nconst util_1 = require(\"../util\");\nconst errors_1 = require(\"../errors\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            topSchemaObjCode(it);\n            return;\n        }\n    }\n    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n    if (opts.code.es5) {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n            gen.code((0, codegen_1._) `\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n            destructureValCxtES5(gen, opts);\n            gen.code(body);\n        });\n    }\n    else {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n    }\n}\nfunction destructureValCxt(opts) {\n    return (0, codegen_1._) `{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n    gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n    }, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `\"\"`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);\n    });\n}\nfunction topSchemaObjCode(it) {\n    const { schema, opts, gen } = it;\n    validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n            commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n            resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n    });\n    return;\n}\nfunction resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen, validateName } = it;\n    it.evaluated = gen.const(\"evaluated\", (0, codegen_1._) `${validateName}.evaluated`);\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n    const schId = typeof schema == \"object\" && schema[opts.schemaId];\n    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules({ schema, self }) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (self.RULES.all[key])\n            return true;\n    return false;\n}\nfunction isSchemaObj(it) {\n    return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n    const { schema, gen, opts } = it;\n    if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n    updateContext(it);\n    checkAsyncSchema(it);\n    const errsCount = gen.const(\"_errs\", names_1.default.errors);\n    typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n    (0, util_1.checkUnknownRules)(it);\n    checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n    const types = (0, dataType_1.getSchemaTypes)(it.schema);\n    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n    schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n    const { schema, errSchemaPath, opts, self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n        self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n    }\n}\nfunction checkNoDefault(it) {\n    const { schema, opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n        (0, util_1.checkStrictMode)(it, \"default is ignored in the schema root\");\n    }\n}\nfunction updateContext(it) {\n    const schId = it.schema[it.opts.schemaId];\n    if (schId)\n        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) {\n        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);\n    }\n    else if (typeof opts.$comment == \"function\") {\n        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction returnResults(it) {\n    const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n    if (schemaEnv.$async) {\n        // TODO assign unevaluated\n        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n            assignEvaluated(it);\n        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);\n    }\n}\nfunction assignEvaluated({ gen, evaluated, props, items }) {\n    if (props instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.props`, props);\n    if (items instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen, schema, data, allErrors, opts, self } = it;\n    const { RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd)\n        checkStrictTypes(it, types);\n    gen.block(() => {\n        for (const group of RULES.rules)\n            groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!(0, applicability_1.shouldUseGroup)(schema, group))\n            return;\n        if (group.type) {\n            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n            iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                (0, dataType_2.reportTypeError)(it);\n            }\n            gen.endIf();\n        }\n        else {\n            iterateKeywords(it, group);\n        }\n        // TODO make it \"ok\" call?\n        if (!allErrors)\n            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction iterateKeywords(it, group) {\n    const { gen, schema, opts: { useDefaults }, } = it;\n    if (useDefaults)\n        (0, defaults_1.assignDefaults)(it, group.type);\n    gen.block(() => {\n        for (const rule of group.rules) {\n            if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n                keywordCode(it, rule.keyword, rule.definition, group.type);\n            }\n        }\n    });\n}\nfunction checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n    checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n    checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n    if (!types.length)\n        return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n            strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n    });\n    it.dataTypes = it.dataTypes.filter((t) => includesType(types, t));\n}\nfunction checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n    }\n}\nfunction checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n            const { type } = rule.definition;\n            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n                strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n            }\n        }\n    }\n}\nfunction hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"));\n}\nfunction includesType(ts, t) {\n    return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"));\n}\nfunction strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at \"${schemaPath}\" (strictTypes)`;\n    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n    constructor(it, def, keyword) {\n        (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n            this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        }\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n            }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n            this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n    }\n    result(condition, successAction, failAction) {\n        this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n    }\n    failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n            failAction();\n        else\n            this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors)\n                this.gen.endIf();\n        }\n        else {\n            if (this.allErrors)\n                this.gen.endIf();\n            else\n                this.gen.else();\n        }\n    }\n    pass(condition, failAction) {\n        this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors)\n                this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n            this.gen.endIf();\n        else\n            this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data)\n            return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined)\n            throw new Error('add \"trackErrors\" to keyword definition');\n        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors)\n            this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign)\n            Object.assign(this.params, obj);\n        else\n            this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n            return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n            gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== codegen_1.nil)\n                gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */\n                if (!(schemaCode instanceof codegen_1.Name))\n                    throw new Error(\"ajv implementation error\");\n                const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n            }\n            return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema }); // TODO value.code for standalone\n                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;\n            }\n            return codegen_1.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n        (0, subschema_1.extendSubschemaMode)(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n            return;\n        if (it.props !== true && schemaCxt.props !== undefined) {\n            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== undefined) {\n            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n            return true;\n        }\n    }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n    const cxt = new KeywordCxt(it, def, keyword);\n    if (\"code\" in def) {\n        def.code(cxt, ruleType);\n    }\n    else if (cxt.$data && def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n    else if (\"macro\" in def) {\n        (0, keyword_1.macroKeywordCode)(cxt, def);\n    }\n    else if (def.compile || def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, { dataLevel, dataNames, dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === \"\")\n        return names_1.default.rootData;\n    if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n    }\n    else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n            if (up >= dataLevel)\n                throw new Error(errorMsg(\"property/index\", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n            throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n            return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split(\"/\");\n    for (const segment of segments) {\n        if (segment) {\n            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n            expr = (0, codegen_1._) `${expr} && ${data}`;\n        }\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nexports.getData = getData;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}