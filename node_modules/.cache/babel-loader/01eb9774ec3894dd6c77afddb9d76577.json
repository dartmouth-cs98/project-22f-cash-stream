{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _taggedTemplateLiteral = require(\"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20, _templateObject21, _templateObject22, _templateObject23, _templateObject24, _templateObject25, _templateObject26, _templateObject27, _templateObject28, _templateObject29, _templateObject30, _templateObject31, _templateObject32, _templateObject33;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nvar rules_1 = require(\"../rules\");\nvar applicability_1 = require(\"./applicability\");\nvar errors_1 = require(\"../errors\");\nvar codegen_1 = require(\"../codegen\");\nvar util_1 = require(\"../util\");\nvar DataType;\n(function (DataType) {\n  DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n  DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType = exports.DataType || (exports.DataType = {}));\nfunction getSchemaTypes(schema) {\n  var types = getJSONTypes(schema.type);\n  var hasNull = types.includes(\"null\");\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\");\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"');\n    }\n    if (schema.nullable === true) types.push(\"null\");\n  }\n  return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\nfunction getJSONTypes(ts) {\n  var types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n  if (types.every(rules_1.isJSONType)) return types;\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n  var gen = it.gen,\n    data = it.data,\n    opts = it.opts;\n  var coerceTo = coerceToTypes(types, opts.coerceTypes);\n  var checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n  if (checkTypes) {\n    var wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n    gen.if(wrongType, function () {\n      if (coerceTo.length) coerceData(it, types, coerceTo);else reportTypeError(it);\n    });\n  }\n  return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nvar COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction coerceToTypes(types, coerceTypes) {\n  return coerceTypes ? types.filter(function (t) {\n    return COERCIBLE.has(t) || coerceTypes === \"array\" && t === \"array\";\n  }) : [];\n}\nfunction coerceData(it, types, coerceTo) {\n  var gen = it.gen,\n    data = it.data,\n    opts = it.opts;\n  var dataType = gen.let(\"dataType\", (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"typeof \", \"\"])), data));\n  var coerced = gen.let(\"coerced\", (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"undefined\"]))));\n  if (opts.coerceTypes === \"array\") {\n    gen.if((0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \" == 'object' && Array.isArray(\", \") && \", \".length == 1\"])), dataType, data, data), function () {\n      return gen.assign(data, (0, codegen_1._)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \"[0]\"])), data)).assign(dataType, (0, codegen_1._)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"typeof \", \"\"])), data)).if(checkDataTypes(types, data, opts.strictNumbers), function () {\n        return gen.assign(coerced, data);\n      });\n    });\n  }\n  gen.if((0, codegen_1._)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \" !== undefined\"])), coerced));\n  var _iterator = _createForOfIteratorHelper(coerceTo),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var t = _step.value;\n      if (COERCIBLE.has(t) || t === \"array\" && opts.coerceTypes === \"array\") {\n        coerceSpecificType(t);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  gen.else();\n  reportTypeError(it);\n  gen.endIf();\n  gen.if((0, codegen_1._)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \" !== undefined\"])), coerced), function () {\n    gen.assign(data, coerced);\n    assignParentData(it, coerced);\n  });\n  function coerceSpecificType(t) {\n    switch (t) {\n      case \"string\":\n        gen.elseIf((0, codegen_1._)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \" == \\\"number\\\" || \", \" == \\\"boolean\\\"\"])), dataType, dataType)).assign(coerced, (0, codegen_1._)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\\\"\\\" + \", \"\"])), data)).elseIf((0, codegen_1._)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \" === null\"])), data)).assign(coerced, (0, codegen_1._)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"\\\"\\\"\"]))));\n        return;\n      case \"number\":\n        gen.elseIf((0, codegen_1._)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"\", \" == \\\"boolean\\\" || \", \" === null\\n              || (\", \" == \\\"string\\\" && \", \" && \", \" == +\", \")\"])), dataType, data, dataType, data, data, data)).assign(coerced, (0, codegen_1._)(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"+\", \"\"])), data));\n        return;\n      case \"integer\":\n        gen.elseIf((0, codegen_1._)(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"\", \" === \\\"boolean\\\" || \", \" === null\\n              || (\", \" === \\\"string\\\" && \", \" && \", \" == +\", \" && !(\", \" % 1))\"])), dataType, data, dataType, data, data, data, data)).assign(coerced, (0, codegen_1._)(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\"+\", \"\"])), data));\n        return;\n      case \"boolean\":\n        gen.elseIf((0, codegen_1._)(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral([\"\", \" === \\\"false\\\" || \", \" === 0 || \", \" === null\"])), data, data, data)).assign(coerced, false).elseIf((0, codegen_1._)(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral([\"\", \" === \\\"true\\\" || \", \" === 1\"])), data, data)).assign(coerced, true);\n        return;\n      case \"null\":\n        gen.elseIf((0, codegen_1._)(_templateObject18 || (_templateObject18 = _taggedTemplateLiteral([\"\", \" === \\\"\\\" || \", \" === 0 || \", \" === false\"])), data, data, data));\n        gen.assign(coerced, null);\n        return;\n      case \"array\":\n        gen.elseIf((0, codegen_1._)(_templateObject19 || (_templateObject19 = _taggedTemplateLiteral([\"\", \" === \\\"string\\\" || \", \" === \\\"number\\\"\\n              || \", \" === \\\"boolean\\\" || \", \" === null\"])), dataType, dataType, dataType, data)).assign(coerced, (0, codegen_1._)(_templateObject20 || (_templateObject20 = _taggedTemplateLiteral([\"[\", \"]\"])), data));\n    }\n  }\n}\nfunction assignParentData(_ref, expr) {\n  var gen = _ref.gen,\n    parentData = _ref.parentData,\n    parentDataProperty = _ref.parentDataProperty;\n  // TODO use gen.property\n  gen.if((0, codegen_1._)(_templateObject21 || (_templateObject21 = _taggedTemplateLiteral([\"\", \" !== undefined\"])), parentData), function () {\n    return gen.assign((0, codegen_1._)(_templateObject22 || (_templateObject22 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), parentData, parentDataProperty), expr);\n  });\n}\nfunction checkDataType(dataType, data, strictNums) {\n  var correct = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DataType.Correct;\n  var EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n  var cond;\n  switch (dataType) {\n    case \"null\":\n      return (0, codegen_1._)(_templateObject23 || (_templateObject23 = _taggedTemplateLiteral([\"\", \" \", \" null\"])), data, EQ);\n    case \"array\":\n      cond = (0, codegen_1._)(_templateObject24 || (_templateObject24 = _taggedTemplateLiteral([\"Array.isArray(\", \")\"])), data);\n      break;\n    case \"object\":\n      cond = (0, codegen_1._)(_templateObject25 || (_templateObject25 = _taggedTemplateLiteral([\"\", \" && typeof \", \" == \\\"object\\\" && !Array.isArray(\", \")\"])), data, data, data);\n      break;\n    case \"integer\":\n      cond = numCond((0, codegen_1._)(_templateObject26 || (_templateObject26 = _taggedTemplateLiteral([\"!(\", \" % 1) && !isNaN(\", \")\"])), data, data));\n      break;\n    case \"number\":\n      cond = numCond();\n      break;\n    default:\n      return (0, codegen_1._)(_templateObject27 || (_templateObject27 = _taggedTemplateLiteral([\"typeof \", \" \", \" \", \"\"])), data, EQ, dataType);\n  }\n  return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n  function numCond() {\n    var _cond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : codegen_1.nil;\n    return (0, codegen_1.and)((0, codegen_1._)(_templateObject28 || (_templateObject28 = _taggedTemplateLiteral([\"typeof \", \" == \\\"number\\\"\"])), data), _cond, strictNums ? (0, codegen_1._)(_templateObject29 || (_templateObject29 = _taggedTemplateLiteral([\"isFinite(\", \")\"])), data) : codegen_1.nil);\n  }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct);\n  }\n  var cond;\n  var types = (0, util_1.toHash)(dataTypes);\n  if (types.array && types.object) {\n    var notObj = (0, codegen_1._)(_templateObject30 || (_templateObject30 = _taggedTemplateLiteral([\"typeof \", \" != \\\"object\\\"\"])), data);\n    cond = types.null ? notObj : (0, codegen_1._)(_templateObject31 || (_templateObject31 = _taggedTemplateLiteral([\"!\", \" || \", \"\"])), data, notObj);\n    delete types.null;\n    delete types.array;\n    delete types.object;\n  } else {\n    cond = codegen_1.nil;\n  }\n  if (types.number) delete types.integer;\n  for (var t in types) {\n    cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n  }\n  return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nvar typeError = {\n  message: function message(_ref2) {\n    var schema = _ref2.schema;\n    return \"must be \".concat(schema);\n  },\n  params: function params(_ref3) {\n    var schema = _ref3.schema,\n      schemaValue = _ref3.schemaValue;\n    return typeof schema == \"string\" ? (0, codegen_1._)(_templateObject32 || (_templateObject32 = _taggedTemplateLiteral([\"{type: \", \"}\"])), schema) : (0, codegen_1._)(_templateObject33 || (_templateObject33 = _taggedTemplateLiteral([\"{type: \", \"}\"])), schemaValue);\n  }\n};\nfunction reportTypeError(it) {\n  var cxt = getTypeErrorContext(it);\n  (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n  var gen = it.gen,\n    data = it.data,\n    schema = it.schema;\n  var schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n  return {\n    gen: gen,\n    keyword: \"type\",\n    data: data,\n    schema: schema.type,\n    schemaCode: schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it: it\n  };\n}","map":{"version":3,"sources":["../../../lib/compile/validate/dataType.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nconst rules_1 = require(\"../rules\");\nconst applicability_1 = require(\"./applicability\");\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst util_1 = require(\"../util\");\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"Correct\"] = 0] = \"Correct\";\n    DataType[DataType[\"Wrong\"] = 1] = \"Wrong\";\n})(DataType = exports.DataType || (exports.DataType = {}));\nfunction getSchemaTypes(schema) {\n    const types = getJSONTypes(schema.type);\n    const hasNull = types.includes(\"null\");\n    if (hasNull) {\n        if (schema.nullable === false)\n            throw new Error(\"type: null contradicts nullable: false\");\n    }\n    else {\n        if (!types.length && schema.nullable !== undefined) {\n            throw new Error('\"nullable\" cannot be used without \"type\"');\n        }\n        if (schema.nullable === true)\n            types.push(\"null\");\n    }\n    return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\nfunction getJSONTypes(ts) {\n    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n    if (types.every(rules_1.isJSONType))\n        return types;\n    throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n    const { gen, data, opts } = it;\n    const coerceTo = coerceToTypes(types, opts.coerceTypes);\n    const checkTypes = types.length > 0 &&\n        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n    if (checkTypes) {\n        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n        gen.if(wrongType, () => {\n            if (coerceTo.length)\n                coerceData(it, types, coerceTo);\n            else\n                reportTypeError(it);\n        });\n    }\n    return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction coerceToTypes(types, coerceTypes) {\n    return coerceTypes\n        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n        : [];\n}\nfunction coerceData(it, types, coerceTo) {\n    const { gen, data, opts } = it;\n    const dataType = gen.let(\"dataType\", (0, codegen_1._) `typeof ${data}`);\n    const coerced = gen.let(\"coerced\", (0, codegen_1._) `undefined`);\n    if (opts.coerceTypes === \"array\") {\n        gen.if((0, codegen_1._) `${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen\n            .assign(data, (0, codegen_1._) `${data}[0]`)\n            .assign(dataType, (0, codegen_1._) `typeof ${data}`)\n            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n    }\n    gen.if((0, codegen_1._) `${coerced} !== undefined`);\n    for (const t of coerceTo) {\n        if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n            coerceSpecificType(t);\n        }\n    }\n    gen.else();\n    reportTypeError(it);\n    gen.endIf();\n    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {\n        gen.assign(data, coerced);\n        assignParentData(it, coerced);\n    });\n    function coerceSpecificType(t) {\n        switch (t) {\n            case \"string\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n                    .assign(coerced, (0, codegen_1._) `\"\" + ${data}`)\n                    .elseIf((0, codegen_1._) `${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `\"\"`);\n                return;\n            case \"number\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"integer\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case \"boolean\":\n                gen\n                    .elseIf((0, codegen_1._) `${data} === \"false\" || ${data} === 0 || ${data} === null`)\n                    .assign(coerced, false)\n                    .elseIf((0, codegen_1._) `${data} === \"true\" || ${data} === 1`)\n                    .assign(coerced, true);\n                return;\n            case \"null\":\n                gen.elseIf((0, codegen_1._) `${data} === \"\" || ${data} === 0 || ${data} === false`);\n                gen.assign(coerced, null);\n                return;\n            case \"array\":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `[${data}]`);\n        }\n    }\n}\nfunction assignParentData({ gen, parentData, parentDataProperty }, expr) {\n    // TODO use gen.property\n    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));\n}\nfunction checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n    let cond;\n    switch (dataType) {\n        case \"null\":\n            return (0, codegen_1._) `${data} ${EQ} null`;\n        case \"array\":\n            cond = (0, codegen_1._) `Array.isArray(${data})`;\n            break;\n        case \"object\":\n            cond = (0, codegen_1._) `${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`;\n            break;\n        case \"integer\":\n            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);\n            break;\n        case \"number\":\n            cond = numCond();\n            break;\n        default:\n            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;\n    }\n    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n    function numCond(_cond = codegen_1.nil) {\n        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == \"number\"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);\n    }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n    if (dataTypes.length === 1) {\n        return checkDataType(dataTypes[0], data, strictNums, correct);\n    }\n    let cond;\n    const types = (0, util_1.toHash)(dataTypes);\n    if (types.array && types.object) {\n        const notObj = (0, codegen_1._) `typeof ${data} != \"object\"`;\n        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;\n        delete types.null;\n        delete types.array;\n        delete types.object;\n    }\n    else {\n        cond = codegen_1.nil;\n    }\n    if (types.number)\n        delete types.integer;\n    for (const t in types)\n        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n    return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n    message: ({ schema }) => `must be ${schema}`,\n    params: ({ schema, schemaValue }) => typeof schema == \"string\" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,\n};\nfunction reportTypeError(it) {\n    const cxt = getTypeErrorContext(it);\n    (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n    const { gen, data, schema } = it;\n    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, \"type\");\n    return {\n        gen,\n        keyword: \"type\",\n        data,\n        schema: schema.type,\n        schemaCode,\n        schemaValue: schemaCode,\n        parentSchema: schema,\n        params: {},\n        it,\n    };\n}\n//# sourceMappingURL=dataType.js.map"]},"metadata":{},"sourceType":"script"}