{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { EC } from \"./elliptic\";\nimport { arrayify, hexlify, hexZeroPad, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nvar _curve = null;\nfunction getCurve() {\n  if (!_curve) {\n    _curve = new EC(\"secp256k1\");\n  }\n  return _curve;\n}\nexport var SigningKey = /*#__PURE__*/function () {\n  function SigningKey(privateKey) {\n    _classCallCheck(this, SigningKey);\n    defineReadOnly(this, \"curve\", \"secp256k1\");\n    defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n    var keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n    defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n    defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n    defineReadOnly(this, \"_isSigningKey\", true);\n  }\n  _createClass(SigningKey, [{\n    key: \"_addPoint\",\n    value: function _addPoint(other) {\n      var p0 = getCurve().keyFromPublic(arrayify(this.publicKey));\n      var p1 = getCurve().keyFromPublic(arrayify(other));\n      return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n  }, {\n    key: \"signDigest\",\n    value: function signDigest(digest) {\n      var keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n      var digestBytes = arrayify(digest);\n      if (digestBytes.length !== 32) {\n        logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n      }\n      var signature = keyPair.sign(digestBytes, {\n        canonical: true\n      });\n      return splitSignature({\n        recoveryParam: signature.recoveryParam,\n        r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n        s: hexZeroPad(\"0x\" + signature.s.toString(16), 32)\n      });\n    }\n  }, {\n    key: \"computeSharedSecret\",\n    value: function computeSharedSecret(otherKey) {\n      var keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n      var otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n      return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n  }], [{\n    key: \"isSigningKey\",\n    value: function isSigningKey(value) {\n      return !!(value && value._isSigningKey);\n    }\n  }]);\n  return SigningKey;\n}();\nexport function recoverPublicKey(digest, signature) {\n  var sig = splitSignature(signature);\n  var rs = {\n    r: arrayify(sig.r),\n    s: arrayify(sig.s)\n  };\n  return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\nexport function computePublicKey(key, compressed) {\n  var bytes = arrayify(key);\n  if (bytes.length === 32) {\n    var signingKey = new SigningKey(bytes);\n    if (compressed) {\n      return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n    }\n    return signingKey.publicKey;\n  } else if (bytes.length === 33) {\n    if (compressed) {\n      return hexlify(bytes);\n    }\n    return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n  } else if (bytes.length === 65) {\n    if (!compressed) {\n      return hexlify(bytes);\n    }\n    return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n  }\n  return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}","map":{"version":3,"sources":["../src.ts/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nimport { EC } from \"./elliptic\";\nimport { arrayify, hexlify, hexZeroPad, splitSignature } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nlet _curve = null;\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC(\"secp256k1\");\n    }\n    return _curve;\n}\nexport class SigningKey {\n    constructor(privateKey) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n    _addPoint(other) {\n        const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 = getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n    signDigest(digest) {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        });\n    }\n    computeSharedSecret(otherKey) {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n    static isSigningKey(value) {\n        return !!(value && value._isSigningKey);\n    }\n}\nexport function recoverPublicKey(digest, signature) {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\nexport function computePublicKey(key, compressed) {\n    const bytes = arrayify(key);\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n    }\n    else if (bytes.length === 33) {\n        if (compressed) {\n            return hexlify(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n    }\n    else if (bytes.length === 65) {\n        if (!compressed) {\n            return hexlify(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n    return logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}