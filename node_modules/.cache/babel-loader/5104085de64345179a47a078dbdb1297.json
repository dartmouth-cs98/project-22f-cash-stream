{"ast":null,"code":"\"use strict\";\n\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\nimport { computeHmac } from \"@ethersproject/sha2\";\nexport function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {\n  password = arrayify(password);\n  salt = arrayify(salt);\n  var hLen;\n  var l = 1;\n  var DK = new Uint8Array(keylen);\n  var block1 = new Uint8Array(salt.length + 4);\n  block1.set(salt);\n  //salt.copy(block1, 0, 0, salt.length)\n  var r;\n  var T;\n  for (var i = 1; i <= l; i++) {\n    //block1.writeUInt32BE(i, salt.length)\n    block1[salt.length] = i >> 24 & 0xff;\n    block1[salt.length + 1] = i >> 16 & 0xff;\n    block1[salt.length + 2] = i >> 8 & 0xff;\n    block1[salt.length + 3] = i & 0xff;\n    //let U = createHmac(password).update(block1).digest();\n    var U = arrayify(computeHmac(hashAlgorithm, password, block1));\n    if (!hLen) {\n      hLen = U.length;\n      T = new Uint8Array(hLen);\n      l = Math.ceil(keylen / hLen);\n      r = keylen - (l - 1) * hLen;\n    }\n    //U.copy(T, 0, 0, hLen)\n    T.set(U);\n    for (var j = 1; j < iterations; j++) {\n      //U = createHmac(password).update(U).digest();\n      U = arrayify(computeHmac(hashAlgorithm, password, U));\n      for (var k = 0; k < hLen; k++) {\n        T[k] ^= U[k];\n      }\n    }\n    var destPos = (i - 1) * hLen;\n    var len = i === l ? r : hLen;\n    //T.copy(DK, destPos, 0, len)\n    DK.set(arrayify(T).slice(0, len), destPos);\n  }\n  return hexlify(DK);\n}","map":{"version":3,"sources":["../src.ts/browser-pbkdf2.ts"],"names":[],"mappings":"AAAA,YAAY;;AAEZ,SAAS,QAAQ,EAAa,OAAO,QAAQ,sBAAsB;AACnE,SAAS,WAAW,QAA4B,qBAAqB;AAErE,OAAM,SAAU,MAAM,CAAC,QAAmB,EAAE,IAAe,EAAE,UAAkB,EAAE,MAAc,EAAE,aAAqB,EAAA;EAClH,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC;EAC7B,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC;EACrB,IAAI,IAAI;EACR,IAAI,CAAC,GAAG,CAAC;EACT,IAAM,EAAE,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC;EACjC,IAAM,MAAM,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;EAC9C,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC;EAChB;EAEA,IAAI,CAAS;EACb,IAAI,CAAa;EAEjB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;IACzB;IACA,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,GAAI,CAAC,IAAI,EAAE,GAAI,IAAI;IACtC,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,GAAI,CAAC,IAAI,EAAE,GAAI,IAAI;IAC1C,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,GAAI,CAAC,IAAI,CAAC,GAAI,IAAI;IACzC,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI;IAElC;IACA,IAAI,CAAC,GAAG,QAAQ,CAAC,WAAW,CAAqB,aAAa,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;IAElF,IAAI,CAAC,IAAI,EAAE;MACP,IAAI,GAAG,CAAC,CAAC,MAAM;MACf,CAAC,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC;MACxB,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;MAC5B,CAAC,GAAG,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,IAAI;IAC9B;IAED;IACA,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;IAGR,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,EAAE,CAAC,EAAE,EAAE;MACjC;MACA,CAAC,GAAG,QAAQ,CAAC,WAAW,CAAqB,aAAa,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC;MACzE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE;QAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;MAAA;IAC9C;IAGD,IAAM,OAAO,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,IAAI;IAC9B,IAAM,GAAG,GAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,IAAK;IAChC;IACA,EAAE,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,OAAO,CAAC;EAC7C;EAED,OAAO,OAAO,CAAC,EAAE,CAAC;AACtB","sourceRoot":"","sourcesContent":["\"use strict\";\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\nimport { computeHmac } from \"@ethersproject/sha2\";\nexport function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {\n    password = arrayify(password);\n    salt = arrayify(salt);\n    let hLen;\n    let l = 1;\n    const DK = new Uint8Array(keylen);\n    const block1 = new Uint8Array(salt.length + 4);\n    block1.set(salt);\n    //salt.copy(block1, 0, 0, salt.length)\n    let r;\n    let T;\n    for (let i = 1; i <= l; i++) {\n        //block1.writeUInt32BE(i, salt.length)\n        block1[salt.length] = (i >> 24) & 0xff;\n        block1[salt.length + 1] = (i >> 16) & 0xff;\n        block1[salt.length + 2] = (i >> 8) & 0xff;\n        block1[salt.length + 3] = i & 0xff;\n        //let U = createHmac(password).update(block1).digest();\n        let U = arrayify(computeHmac(hashAlgorithm, password, block1));\n        if (!hLen) {\n            hLen = U.length;\n            T = new Uint8Array(hLen);\n            l = Math.ceil(keylen / hLen);\n            r = keylen - (l - 1) * hLen;\n        }\n        //U.copy(T, 0, 0, hLen)\n        T.set(U);\n        for (let j = 1; j < iterations; j++) {\n            //U = createHmac(password).update(U).digest();\n            U = arrayify(computeHmac(hashAlgorithm, password, U));\n            for (let k = 0; k < hLen; k++)\n                T[k] ^= U[k];\n        }\n        const destPos = (i - 1) * hLen;\n        const len = (i === l ? r : hLen);\n        //T.copy(DK, destPos, 0, len)\n        DK.set(arrayify(T).slice(0, len), destPos);\n    }\n    return hexlify(DK);\n}\n//# sourceMappingURL=pbkdf2.js.map"]},"metadata":{},"sourceType":"module"}