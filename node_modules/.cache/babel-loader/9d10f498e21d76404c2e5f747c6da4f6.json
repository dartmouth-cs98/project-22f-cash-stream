{"ast":null,"code":"\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\n///////////////////////////////\nfunction isHexable(value) {\n  return !!value.toHexString;\n}\nfunction addSlice(array) {\n  if (array.slice) {\n    return array;\n  }\n  array.slice = function () {\n    var args = Array.prototype.slice.call(arguments);\n    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n  };\n  return array;\n}\nexport function isBytesLike(value) {\n  return isHexString(value) && !(value.length % 2) || isBytes(value);\n}\nfunction isInteger(value) {\n  return typeof value === \"number\" && value == value && value % 1 === 0;\n}\nexport function isBytes(value) {\n  if (value == null) {\n    return false;\n  }\n  if (value.constructor === Uint8Array) {\n    return true;\n  }\n  if (typeof value === \"string\") {\n    return false;\n  }\n  if (!isInteger(value.length) || value.length < 0) {\n    return false;\n  }\n  for (var i = 0; i < value.length; i++) {\n    var v = value[i];\n    if (!isInteger(v) || v < 0 || v >= 256) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function arrayify(value, options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof value === \"number\") {\n    logger.checkSafeUint53(value, \"invalid arrayify value\");\n    var result = [];\n    while (value) {\n      result.unshift(value & 0xff);\n      value = parseInt(String(value / 256));\n    }\n    if (result.length === 0) {\n      result.push(0);\n    }\n    return addSlice(new Uint8Array(result));\n  }\n  if (options.allowMissingPrefix && typeof value === \"string\" && value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  }\n  if (isHexable(value)) {\n    value = value.toHexString();\n  }\n  if (isHexString(value)) {\n    var hex = value.substring(2);\n    if (hex.length % 2) {\n      if (options.hexPad === \"left\") {\n        hex = \"0\" + hex;\n      } else if (options.hexPad === \"right\") {\n        hex += \"0\";\n      } else {\n        logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n      }\n    }\n    var _result = [];\n    for (var i = 0; i < hex.length; i += 2) {\n      _result.push(parseInt(hex.substring(i, i + 2), 16));\n    }\n    return addSlice(new Uint8Array(_result));\n  }\n  if (isBytes(value)) {\n    return addSlice(new Uint8Array(value));\n  }\n  return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\nexport function concat(items) {\n  var objects = items.map(function (item) {\n    return arrayify(item);\n  });\n  var length = objects.reduce(function (accum, item) {\n    return accum + item.length;\n  }, 0);\n  var result = new Uint8Array(length);\n  objects.reduce(function (offset, object) {\n    result.set(object, offset);\n    return offset + object.length;\n  }, 0);\n  return addSlice(result);\n}\nexport function stripZeros(value) {\n  var result = arrayify(value);\n  if (result.length === 0) {\n    return result;\n  }\n  // Find the first non-zero entry\n  var start = 0;\n  while (start < result.length && result[start] === 0) {\n    start++;\n  }\n  // If we started with zeros, strip them\n  if (start) {\n    result = result.slice(start);\n  }\n  return result;\n}\nexport function zeroPad(value, length) {\n  value = arrayify(value);\n  if (value.length > length) {\n    logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n  }\n  var result = new Uint8Array(length);\n  result.set(value, length - value.length);\n  return addSlice(result);\n}\nexport function isHexString(value, length) {\n  if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n  if (length && value.length !== 2 + 2 * length) {\n    return false;\n  }\n  return true;\n}\nvar HexCharacters = \"0123456789abcdef\";\nexport function hexlify(value, options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof value === \"number\") {\n    logger.checkSafeUint53(value, \"invalid hexlify value\");\n    var hex = \"\";\n    while (value) {\n      hex = HexCharacters[value & 0xf] + hex;\n      value = Math.floor(value / 16);\n    }\n    if (hex.length) {\n      if (hex.length % 2) {\n        hex = \"0\" + hex;\n      }\n      return \"0x\" + hex;\n    }\n    return \"0x00\";\n  }\n  if (typeof value === \"bigint\") {\n    value = value.toString(16);\n    if (value.length % 2) {\n      return \"0x0\" + value;\n    }\n    return \"0x\" + value;\n  }\n  if (options.allowMissingPrefix && typeof value === \"string\" && value.substring(0, 2) !== \"0x\") {\n    value = \"0x\" + value;\n  }\n  if (isHexable(value)) {\n    return value.toHexString();\n  }\n  if (isHexString(value)) {\n    if (value.length % 2) {\n      if (options.hexPad === \"left\") {\n        value = \"0x0\" + value.substring(2);\n      } else if (options.hexPad === \"right\") {\n        value += \"0\";\n      } else {\n        logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n      }\n    }\n    return value.toLowerCase();\n  }\n  if (isBytes(value)) {\n    var result = \"0x\";\n    for (var i = 0; i < value.length; i++) {\n      var v = value[i];\n      result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n  }\n  return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data) {\n  if (typeof data !== \"string\") {\n    data = hexlify(data);\n  } else if (!isHexString(data) || data.length % 2) {\n    return null;\n  }\n  return (data.length - 2) / 2;\n}\nexport function hexDataSlice(data, offset, endOffset) {\n  if (typeof data !== \"string\") {\n    data = hexlify(data);\n  } else if (!isHexString(data) || data.length % 2) {\n    logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n  }\n  offset = 2 + 2 * offset;\n  if (endOffset != null) {\n    return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n  }\n  return \"0x\" + data.substring(offset);\n}\nexport function hexConcat(items) {\n  var result = \"0x\";\n  items.forEach(function (item) {\n    result += hexlify(item).substring(2);\n  });\n  return result;\n}\nexport function hexValue(value) {\n  var trimmed = hexStripZeros(hexlify(value, {\n    hexPad: \"left\"\n  }));\n  if (trimmed === \"0x\") {\n    return \"0x0\";\n  }\n  return trimmed;\n}\nexport function hexStripZeros(value) {\n  if (typeof value !== \"string\") {\n    value = hexlify(value);\n  }\n  if (!isHexString(value)) {\n    logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n  }\n  value = value.substring(2);\n  var offset = 0;\n  while (offset < value.length && value[offset] === \"0\") {\n    offset++;\n  }\n  return \"0x\" + value.substring(offset);\n}\nexport function hexZeroPad(value, length) {\n  if (typeof value !== \"string\") {\n    value = hexlify(value);\n  } else if (!isHexString(value)) {\n    logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n  }\n  if (value.length > 2 * length + 2) {\n    logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n  }\n  while (value.length < 2 * length + 2) {\n    value = \"0x0\" + value.substring(2);\n  }\n  return value;\n}\nexport function splitSignature(signature) {\n  var result = {\n    r: \"0x\",\n    s: \"0x\",\n    _vs: \"0x\",\n    recoveryParam: 0,\n    v: 0,\n    yParityAndS: \"0x\",\n    compact: \"0x\"\n  };\n  if (isBytesLike(signature)) {\n    var bytes = arrayify(signature);\n    // Get the r, s and v\n    if (bytes.length === 64) {\n      // EIP-2098; pull the v from the top bit of s and clear it\n      result.v = 27 + (bytes[32] >> 7);\n      bytes[32] &= 0x7f;\n      result.r = hexlify(bytes.slice(0, 32));\n      result.s = hexlify(bytes.slice(32, 64));\n    } else if (bytes.length === 65) {\n      result.r = hexlify(bytes.slice(0, 32));\n      result.s = hexlify(bytes.slice(32, 64));\n      result.v = bytes[64];\n    } else {\n      logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n    }\n    // Allow a recid to be used as the v\n    if (result.v < 27) {\n      if (result.v === 0 || result.v === 1) {\n        result.v += 27;\n      } else {\n        logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n      }\n    }\n    // Compute recoveryParam from v\n    result.recoveryParam = 1 - result.v % 2;\n    // Compute _vs from recoveryParam and s\n    if (result.recoveryParam) {\n      bytes[32] |= 0x80;\n    }\n    result._vs = hexlify(bytes.slice(32, 64));\n  } else {\n    result.r = signature.r;\n    result.s = signature.s;\n    result.v = signature.v;\n    result.recoveryParam = signature.recoveryParam;\n    result._vs = signature._vs;\n    // If the _vs is available, use it to populate missing s, v and recoveryParam\n    // and verify non-missing s, v and recoveryParam\n    if (result._vs != null) {\n      var _vs2 = zeroPad(arrayify(result._vs), 32);\n      result._vs = hexlify(_vs2);\n      // Set or check the recid\n      var recoveryParam = _vs2[0] >= 128 ? 1 : 0;\n      if (result.recoveryParam == null) {\n        result.recoveryParam = recoveryParam;\n      } else if (result.recoveryParam !== recoveryParam) {\n        logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n      }\n      // Set or check the s\n      _vs2[0] &= 0x7f;\n      var s = hexlify(_vs2);\n      if (result.s == null) {\n        result.s = s;\n      } else if (result.s !== s) {\n        logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n      }\n    }\n    // Use recid and v to populate each other\n    if (result.recoveryParam == null) {\n      if (result.v == null) {\n        logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n      } else if (result.v === 0 || result.v === 1) {\n        result.recoveryParam = result.v;\n      } else {\n        result.recoveryParam = 1 - result.v % 2;\n      }\n    } else {\n      if (result.v == null) {\n        result.v = 27 + result.recoveryParam;\n      } else {\n        var recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;\n        if (result.recoveryParam !== recId) {\n          logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n        }\n      }\n    }\n    if (result.r == null || !isHexString(result.r)) {\n      logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n    } else {\n      result.r = hexZeroPad(result.r, 32);\n    }\n    if (result.s == null || !isHexString(result.s)) {\n      logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n    } else {\n      result.s = hexZeroPad(result.s, 32);\n    }\n    var vs = arrayify(result.s);\n    if (vs[0] >= 128) {\n      logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n    }\n    if (result.recoveryParam) {\n      vs[0] |= 0x80;\n    }\n    var _vs = hexlify(vs);\n    if (result._vs) {\n      if (!isHexString(result._vs)) {\n        logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n      }\n      result._vs = hexZeroPad(result._vs, 32);\n    }\n    // Set or check the _vs\n    if (result._vs == null) {\n      result._vs = _vs;\n    } else if (result._vs !== _vs) {\n      logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n    }\n  }\n  result.yParityAndS = result._vs;\n  result.compact = result.r + result.yParityAndS.substring(2);\n  return result;\n}\nexport function joinSignature(signature) {\n  signature = splitSignature(signature);\n  return hexlify(concat([signature.r, signature.s, signature.recoveryParam ? \"0x1c\" : \"0x1b\"]));\n}","map":{"version":3,"sources":["../src.ts/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n///////////////////////////////\nfunction isHexable(value) {\n    return !!(value.toHexString);\n}\nfunction addSlice(array) {\n    if (array.slice) {\n        return array;\n    }\n    array.slice = function () {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    };\n    return array;\n}\nexport function isBytesLike(value) {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\nfunction isInteger(value) {\n    return (typeof (value) === \"number\" && value == value && (value % 1) === 0);\n}\nexport function isBytes(value) {\n    if (value == null) {\n        return false;\n    }\n    if (value.constructor === Uint8Array) {\n        return true;\n    }\n    if (typeof (value) === \"string\") {\n        return false;\n    }\n    if (!isInteger(value.length) || value.length < 0) {\n        return false;\n    }\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function arrayify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) {\n            result.push(0);\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        value = value.toHexString();\n    }\n    if (isHexString(value)) {\n        let hex = value.substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            }\n            else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            }\n            else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\nexport function concat(items) {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n    const result = new Uint8Array(length);\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n    return addSlice(result);\n}\nexport function stripZeros(value) {\n    let result = arrayify(value);\n    if (result.length === 0) {\n        return result;\n    }\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) {\n        start++;\n    }\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n    return result;\n}\nexport function zeroPad(value, length) {\n    value = arrayify(value);\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\nexport function isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nconst HexCharacters = \"0123456789abcdef\";\nexport function hexlify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n        if (hex.length) {\n            if (hex.length % 2) {\n                hex = \"0\" + hex;\n            }\n            return \"0x\" + hex;\n        }\n        return \"0x00\";\n    }\n    if (typeof (value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) {\n            return (\"0x0\" + value);\n        }\n        return \"0x\" + value;\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        return value.toHexString();\n    }\n    if (isHexString(value)) {\n        if (value.length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + value.substring(2);\n            }\n            else if (options.hexPad === \"right\") {\n                value += \"0\";\n            }\n            else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return value.toLowerCase();\n    }\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            let v = value[i];\n            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n    return (data.length - 2) / 2;\n}\nexport function hexDataSlice(data, offset, endOffset) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n    }\n    offset = 2 + 2 * offset;\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n    return \"0x\" + data.substring(offset);\n}\nexport function hexConcat(items) {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\nexport function hexValue(value) {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") {\n        return \"0x0\";\n    }\n    return trimmed;\n}\nexport function hexStripZeros(value) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") {\n        offset++;\n    }\n    return \"0x\" + value.substring(offset);\n}\nexport function hexZeroPad(value, length) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    return value;\n}\nexport function splitSignature(signature) {\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n    if (isBytesLike(signature)) {\n        let bytes = arrayify(signature);\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n        }\n        else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        }\n        else {\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            }\n            else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) {\n            bytes[32] |= 0x80;\n        }\n        result._vs = hexlify(bytes.slice(32, 64));\n    }\n    else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1 : 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            }\n            else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            }\n            else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            }\n            else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            }\n            else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        }\n        else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            }\n            else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        }\n        else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        }\n        else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) {\n            vs[0] |= 0x80;\n        }\n        const _vs = hexlify(vs);\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        }\n        else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n    return result;\n}\nexport function joinSignature(signature) {\n    signature = splitSignature(signature);\n    return hexlify(concat([\n        signature.r,\n        signature.s,\n        (signature.recoveryParam ? \"0x1c\" : \"0x1b\")\n    ]));\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}