{"ast":null,"code":"import _regeneratorRuntime from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createClass from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { ethers } from \"ethers\";\nimport Host from \"./Host\";\nimport { SFError } from \"./SFError\";\nimport IInstantDistributionAgreementV1ABI from \"./abi/IInstantDistributionAgreementV1.json\";\nimport { normalizeAddress } from \"./utils\";\nvar idaInterface = new ethers.utils.Interface(IInstantDistributionAgreementV1ABI.abi);\n/**\n * Instant Distribution Agreement V1 Helper Class\n * @description A helper class to interact with the IDAV1 contract.\n */\nvar InstantDistributionAgreementV1 = /*#__PURE__*/_createClass(function InstantDistributionAgreementV1(options) {\n  var _this = this;\n  _classCallCheck(this, InstantDistributionAgreementV1);\n  /** ### IDA Read Functions ### */\n  /**\n   * Get the details of a `Subscription`.\n   * @param superToken the superToken of the agreement\n   * @param publisher the address of the publisher of the index\n   * @param indexId the index id\n   * @param subscriber the subscriber's address\n   * @param providerOrSigner a provider or signer object\n   * @returns {Promise<IWeb3Subscription>} Web3 Subscription object\n   */\n  this.getSubscription = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {\n      var normalizedToken, normalizedPublisher, normalizedSubscriber, subscription;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              normalizedToken = normalizeAddress(params.superToken);\n              normalizedPublisher = normalizeAddress(params.publisher);\n              normalizedSubscriber = normalizeAddress(params.subscriber);\n              _context.prev = 3;\n              _context.next = 6;\n              return _this.contract.connect(params.providerOrSigner).getSubscription(normalizedToken, normalizedPublisher, params.indexId, normalizedSubscriber);\n            case 6:\n              subscription = _context.sent;\n              return _context.abrupt(\"return\", {\n                exist: subscription.exist,\n                approved: subscription.approved,\n                units: subscription.units.toString(),\n                pendingDistribution: subscription.pendingDistribution.toString()\n              });\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context[\"catch\"](3);\n              throw new SFError({\n                type: \"IDAV1_READ\",\n                customMessage: \"There was an error getting the subscription\",\n                errorObject: _context.t0\n              });\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[3, 10]]);\n    }));\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /**\n   * Get the details of an `Index`.\n   * @param superToken the superToken of the agreement\n   * @param publisher the address of the publisher of the index\n   * @param indexId the index id\n   * @param providerOrSigner a provider or signer object\n   * @returns {Promise<IWeb3Index>} Web3 Index object\n   */\n  this.getIndex = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {\n      var normalizedToken, normalizedPublisher, index;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              normalizedToken = normalizeAddress(params.superToken);\n              normalizedPublisher = normalizeAddress(params.publisher);\n              _context2.prev = 2;\n              _context2.next = 5;\n              return _this.contract.connect(params.providerOrSigner).getIndex(normalizedToken, normalizedPublisher, params.indexId);\n            case 5:\n              index = _context2.sent;\n              return _context2.abrupt(\"return\", {\n                exist: index.exist,\n                indexValue: index.indexValue.toString(),\n                totalUnitsApproved: index.totalUnitsApproved.toString(),\n                totalUnitsPending: index.totalUnitsPending.toString()\n              });\n            case 9:\n              _context2.prev = 9;\n              _context2.t0 = _context2[\"catch\"](2);\n              throw new SFError({\n                type: \"IDAV1_READ\",\n                customMessage: \"There was an error getting the index\",\n                errorObject: _context2.t0\n              });\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[2, 9]]);\n    }));\n    return function (_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /** ### IDA Write Functions ### */\n  /**\n   * Creates an IDA Index.\n   * @param indexId The id of the index.\n   * @param superToken The address of the `index` superToken.\n   * @param userData Extra user data provided.\n   * @param overrides ethers overrides object for more control over the transaction sent.\n   * @returns {Operation} An instance of Operation which can be executed or batched.\n   */\n  this.createIndex = function (params) {\n    var normalizedToken = normalizeAddress(params.superToken);\n    var callData = idaInterface.encodeFunctionData(\"createIndex\", [normalizedToken, params.indexId, \"0x\"]);\n    return _this.host.populateCallAgreementTxnAndReturnOperation(_this.options.config.idaV1Address, callData, params.userData, params.overrides);\n  };\n  /**\n   * Distributes `amount` of `superToken` to an index\n   * @param indexId The id of the index.\n   * @param amount The amount of `superToken` to be distributed.\n   * @param superToken The superToken to be distributed.\n   * @param userData Extra user data provided.\n   * @param overrides ethers overrides object for more control over the transaction sent.\n   * @returns {Operation} An instance of Operation which can be executed or batched.\n   */\n  this.distribute = function (params) {\n    var normalizedToken = normalizeAddress(params.superToken);\n    var callData = idaInterface.encodeFunctionData(\"distribute\", [normalizedToken, params.indexId, params.amount, \"0x\"]);\n    return _this.host.populateCallAgreementTxnAndReturnOperation(_this.options.config.idaV1Address, callData, params.userData, params.overrides);\n  };\n  /**\n   * Updates the `indexValue` of an index.\n   * @description NOTE: It has the same effect as `distribute`, but is closer to the low level data structure of the index.\n   * @param indexId The id of the index.\n   * @param indexValue The new indexValue.\n   * @param superToken The superToken to be distributed.\n   * @param userData Extra user data provided.\n   * @param overrides ethers overrides object for more control over the transaction sent.\n   * @returns {Operation} An instance of Operation which can be executed or batched.\n   */\n  this.updateIndexValue = function (params) {\n    var normalizedToken = normalizeAddress(params.superToken);\n    var callData = idaInterface.encodeFunctionData(\"updateIndex\", [normalizedToken, params.indexId, params.indexValue, \"0x\"]);\n    return _this.host.populateCallAgreementTxnAndReturnOperation(_this.options.config.idaV1Address, callData, params.userData, params.overrides);\n  };\n  /**\n   * Updates the `units` allocated to a Subscription.\n   * @param indexId The id of the index.\n   * @param superToken The superToken of the index.\n   * @param subscriber The subscriber address whose units you want to update.\n   * @param units The amount of units you want to update to.\n   * @param userData Extra user data provided.\n   * @param overrides ethers overrides object for more control over the transaction sent.\n   * @returns {Operation} An instance of Operation which can be executed or batched.\n   */\n  this.updateSubscriptionUnits = function (params) {\n    var normalizedToken = normalizeAddress(params.superToken);\n    var normalizedSubscriber = normalizeAddress(params.subscriber);\n    var callData = idaInterface.encodeFunctionData(\"updateSubscription\", [normalizedToken, params.indexId, normalizedSubscriber, params.units, \"0x\"]);\n    return _this.host.populateCallAgreementTxnAndReturnOperation(_this.options.config.idaV1Address, callData, params.userData, params.overrides);\n  };\n  /**\n   * Approves a Subscription, so the Subscriber won't need to claim tokens when the Publisher distributes.\n   * @param indexId The id of the index.\n   * @param superToken The superToken of the index.\n   * @param publisher The publisher of the index you want to approve.\n   * @param userData Extra user data provided.\n   * @param overrides ethers overrides object for more control over the transaction sent.\n   * @returns {Operation} An instance of Operation which can be executed or batched.\n   */\n  this.approveSubscription = function (params) {\n    var normalizedPublisher = normalizeAddress(params.publisher);\n    var normalizedToken = normalizeAddress(params.superToken);\n    var callData = idaInterface.encodeFunctionData(\"approveSubscription\", [normalizedToken, normalizedPublisher, params.indexId, \"0x\"]);\n    return _this.host.populateCallAgreementTxnAndReturnOperation(_this.options.config.idaV1Address, callData, params.userData, params.overrides);\n  };\n  /**\n   * Revokes a Subscription, so the Subscriber will need to claim tokens when the Publisher distributres.\n   * @param indexId The id of the index.\n   * @param superToken The superToken of the index.\n   * @param subscriber The subscriber address whose subscription you want to revoke.\n   * @param userData Extra user data provided.\n   * @param overrides ethers overrides object for more control over the transaction sent.\n   * @returns {Operation} An instance of Operation which can be executed or batched.\n   */\n  this.revokeSubscription = function (params) {\n    var normalizedPublisher = normalizeAddress(params.publisher);\n    var normalizedToken = normalizeAddress(params.superToken);\n    var callData = idaInterface.encodeFunctionData(\"revokeSubscription\", [normalizedToken, normalizedPublisher, params.indexId, \"0x\"]);\n    return _this.host.populateCallAgreementTxnAndReturnOperation(_this.options.config.idaV1Address, callData, params.userData, params.overrides);\n  };\n  /**\n   * Deletes a Subscription by setting the `units` allocated to the Subscriber to 0.\n   * @param indexId The id of the index.\n   * @param superToken The superToken of the index.\n   * @param subscriber The subscriber address whose subscription you want to delete.\n   * @param publisher The publisher address of the index you are targetting.\n   * @param userData Extra user data provided.\n   * @param overrides ethers overrides object for more control over the transaction sent.\n   * @returns {Operation} An instance of Operation which can be executed or batched.\n   */\n  this.deleteSubscription = function (params) {\n    var normalizedPublisher = normalizeAddress(params.publisher);\n    var normalizedToken = normalizeAddress(params.superToken);\n    var normalizedSubscriber = normalizeAddress(params.subscriber);\n    var callData = idaInterface.encodeFunctionData(\"deleteSubscription\", [normalizedToken, normalizedPublisher, params.indexId, normalizedSubscriber, \"0x\"]);\n    return _this.host.populateCallAgreementTxnAndReturnOperation(_this.options.config.idaV1Address, callData, params.userData, params.overrides);\n  };\n  /**\n   * Claims any pending tokens allocated to the Subscription (unapproved).\n   * @param indexId The id of the index.\n   * @param superToken The superToken of the index.\n   * @param subscriber The subscriber address whose subscription you want to delete.\n   * @param publisher The publisher address of the index you are targetting.\n   * @param userData Extra user data provided.\n   * @param overrides ethers overrides object for more control over the transaction sent.\n   * @returns {Operation} An instance of Operation which can be executed or batched.\n   */\n  this.claim = function (params) {\n    var normalizedPublisher = normalizeAddress(params.publisher);\n    var normalizedToken = normalizeAddress(params.superToken);\n    var normalizedSubscriber = normalizeAddress(params.subscriber);\n    var callData = idaInterface.encodeFunctionData(\"claim\", [normalizedToken, normalizedPublisher, params.indexId, normalizedSubscriber, \"0x\"]);\n    return _this.host.populateCallAgreementTxnAndReturnOperation(_this.options.config.idaV1Address, callData, params.userData, params.overrides);\n  };\n  this.options = options;\n  this.host = new Host(options.config.hostAddress);\n  this.contract = new ethers.Contract(this.options.config.idaV1Address, IInstantDistributionAgreementV1ABI.abi);\n});\nexport { InstantDistributionAgreementV1 as default };","map":{"version":3,"sources":["../../src/InstantDistributionAgreementV1.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ethers } from \"ethers\";\nimport Host from \"./Host\";\nimport { SFError } from \"./SFError\";\nimport IInstantDistributionAgreementV1ABI from \"./abi/IInstantDistributionAgreementV1.json\";\nimport { normalizeAddress } from \"./utils\";\nconst idaInterface = new ethers.utils.Interface(IInstantDistributionAgreementV1ABI.abi);\n/**\n * Instant Distribution Agreement V1 Helper Class\n * @description A helper class to interact with the IDAV1 contract.\n */\nexport default class InstantDistributionAgreementV1 {\n    constructor(options) {\n        /** ### IDA Read Functions ### */\n        /**\n         * Get the details of a `Subscription`.\n         * @param superToken the superToken of the agreement\n         * @param publisher the address of the publisher of the index\n         * @param indexId the index id\n         * @param subscriber the subscriber's address\n         * @param providerOrSigner a provider or signer object\n         * @returns {Promise<IWeb3Subscription>} Web3 Subscription object\n         */\n        this.getSubscription = async (params) => {\n            const normalizedToken = normalizeAddress(params.superToken);\n            const normalizedPublisher = normalizeAddress(params.publisher);\n            const normalizedSubscriber = normalizeAddress(params.subscriber);\n            try {\n                const subscription = await this.contract\n                    .connect(params.providerOrSigner)\n                    .getSubscription(normalizedToken, normalizedPublisher, params.indexId, normalizedSubscriber);\n                return {\n                    exist: subscription.exist,\n                    approved: subscription.approved,\n                    units: subscription.units.toString(),\n                    pendingDistribution: subscription.pendingDistribution.toString(),\n                };\n            }\n            catch (err) {\n                throw new SFError({\n                    type: \"IDAV1_READ\",\n                    customMessage: \"There was an error getting the subscription\",\n                    errorObject: err,\n                });\n            }\n        };\n        /**\n         * Get the details of an `Index`.\n         * @param superToken the superToken of the agreement\n         * @param publisher the address of the publisher of the index\n         * @param indexId the index id\n         * @param providerOrSigner a provider or signer object\n         * @returns {Promise<IWeb3Index>} Web3 Index object\n         */\n        this.getIndex = async (params) => {\n            const normalizedToken = normalizeAddress(params.superToken);\n            const normalizedPublisher = normalizeAddress(params.publisher);\n            try {\n                const index = await this.contract\n                    .connect(params.providerOrSigner)\n                    .getIndex(normalizedToken, normalizedPublisher, params.indexId);\n                return {\n                    exist: index.exist,\n                    indexValue: index.indexValue.toString(),\n                    totalUnitsApproved: index.totalUnitsApproved.toString(),\n                    totalUnitsPending: index.totalUnitsPending.toString(),\n                };\n            }\n            catch (err) {\n                throw new SFError({\n                    type: \"IDAV1_READ\",\n                    customMessage: \"There was an error getting the index\",\n                    errorObject: err,\n                });\n            }\n        };\n        /** ### IDA Write Functions ### */\n        /**\n         * Creates an IDA Index.\n         * @param indexId The id of the index.\n         * @param superToken The address of the `index` superToken.\n         * @param userData Extra user data provided.\n         * @param overrides ethers overrides object for more control over the transaction sent.\n         * @returns {Operation} An instance of Operation which can be executed or batched.\n         */\n        this.createIndex = (params) => {\n            const normalizedToken = normalizeAddress(params.superToken);\n            const callData = idaInterface.encodeFunctionData(\"createIndex\", [\n                normalizedToken,\n                params.indexId,\n                \"0x\",\n            ]);\n            return this.host.populateCallAgreementTxnAndReturnOperation(this.options.config.idaV1Address, callData, params.userData, params.overrides);\n        };\n        /**\n         * Distributes `amount` of `superToken` to an index\n         * @param indexId The id of the index.\n         * @param amount The amount of `superToken` to be distributed.\n         * @param superToken The superToken to be distributed.\n         * @param userData Extra user data provided.\n         * @param overrides ethers overrides object for more control over the transaction sent.\n         * @returns {Operation} An instance of Operation which can be executed or batched.\n         */\n        this.distribute = (params) => {\n            const normalizedToken = normalizeAddress(params.superToken);\n            const callData = idaInterface.encodeFunctionData(\"distribute\", [\n                normalizedToken,\n                params.indexId,\n                params.amount,\n                \"0x\",\n            ]);\n            return this.host.populateCallAgreementTxnAndReturnOperation(this.options.config.idaV1Address, callData, params.userData, params.overrides);\n        };\n        /**\n         * Updates the `indexValue` of an index.\n         * @description NOTE: It has the same effect as `distribute`, but is closer to the low level data structure of the index.\n         * @param indexId The id of the index.\n         * @param indexValue The new indexValue.\n         * @param superToken The superToken to be distributed.\n         * @param userData Extra user data provided.\n         * @param overrides ethers overrides object for more control over the transaction sent.\n         * @returns {Operation} An instance of Operation which can be executed or batched.\n         */\n        this.updateIndexValue = (params) => {\n            const normalizedToken = normalizeAddress(params.superToken);\n            const callData = idaInterface.encodeFunctionData(\"updateIndex\", [\n                normalizedToken,\n                params.indexId,\n                params.indexValue,\n                \"0x\",\n            ]);\n            return this.host.populateCallAgreementTxnAndReturnOperation(this.options.config.idaV1Address, callData, params.userData, params.overrides);\n        };\n        /**\n         * Updates the `units` allocated to a Subscription.\n         * @param indexId The id of the index.\n         * @param superToken The superToken of the index.\n         * @param subscriber The subscriber address whose units you want to update.\n         * @param units The amount of units you want to update to.\n         * @param userData Extra user data provided.\n         * @param overrides ethers overrides object for more control over the transaction sent.\n         * @returns {Operation} An instance of Operation which can be executed or batched.\n         */\n        this.updateSubscriptionUnits = (params) => {\n            const normalizedToken = normalizeAddress(params.superToken);\n            const normalizedSubscriber = normalizeAddress(params.subscriber);\n            const callData = idaInterface.encodeFunctionData(\"updateSubscription\", [\n                normalizedToken,\n                params.indexId,\n                normalizedSubscriber,\n                params.units,\n                \"0x\",\n            ]);\n            return this.host.populateCallAgreementTxnAndReturnOperation(this.options.config.idaV1Address, callData, params.userData, params.overrides);\n        };\n        /**\n         * Approves a Subscription, so the Subscriber won't need to claim tokens when the Publisher distributes.\n         * @param indexId The id of the index.\n         * @param superToken The superToken of the index.\n         * @param publisher The publisher of the index you want to approve.\n         * @param userData Extra user data provided.\n         * @param overrides ethers overrides object for more control over the transaction sent.\n         * @returns {Operation} An instance of Operation which can be executed or batched.\n         */\n        this.approveSubscription = (params) => {\n            const normalizedPublisher = normalizeAddress(params.publisher);\n            const normalizedToken = normalizeAddress(params.superToken);\n            const callData = idaInterface.encodeFunctionData(\"approveSubscription\", [normalizedToken, normalizedPublisher, params.indexId, \"0x\"]);\n            return this.host.populateCallAgreementTxnAndReturnOperation(this.options.config.idaV1Address, callData, params.userData, params.overrides);\n        };\n        /**\n         * Revokes a Subscription, so the Subscriber will need to claim tokens when the Publisher distributres.\n         * @param indexId The id of the index.\n         * @param superToken The superToken of the index.\n         * @param subscriber The subscriber address whose subscription you want to revoke.\n         * @param userData Extra user data provided.\n         * @param overrides ethers overrides object for more control over the transaction sent.\n         * @returns {Operation} An instance of Operation which can be executed or batched.\n         */\n        this.revokeSubscription = (params) => {\n            const normalizedPublisher = normalizeAddress(params.publisher);\n            const normalizedToken = normalizeAddress(params.superToken);\n            const callData = idaInterface.encodeFunctionData(\"revokeSubscription\", [\n                normalizedToken,\n                normalizedPublisher,\n                params.indexId,\n                \"0x\",\n            ]);\n            return this.host.populateCallAgreementTxnAndReturnOperation(this.options.config.idaV1Address, callData, params.userData, params.overrides);\n        };\n        /**\n         * Deletes a Subscription by setting the `units` allocated to the Subscriber to 0.\n         * @param indexId The id of the index.\n         * @param superToken The superToken of the index.\n         * @param subscriber The subscriber address whose subscription you want to delete.\n         * @param publisher The publisher address of the index you are targetting.\n         * @param userData Extra user data provided.\n         * @param overrides ethers overrides object for more control over the transaction sent.\n         * @returns {Operation} An instance of Operation which can be executed or batched.\n         */\n        this.deleteSubscription = (params) => {\n            const normalizedPublisher = normalizeAddress(params.publisher);\n            const normalizedToken = normalizeAddress(params.superToken);\n            const normalizedSubscriber = normalizeAddress(params.subscriber);\n            const callData = idaInterface.encodeFunctionData(\"deleteSubscription\", [\n                normalizedToken,\n                normalizedPublisher,\n                params.indexId,\n                normalizedSubscriber,\n                \"0x\",\n            ]);\n            return this.host.populateCallAgreementTxnAndReturnOperation(this.options.config.idaV1Address, callData, params.userData, params.overrides);\n        };\n        /**\n         * Claims any pending tokens allocated to the Subscription (unapproved).\n         * @param indexId The id of the index.\n         * @param superToken The superToken of the index.\n         * @param subscriber The subscriber address whose subscription you want to delete.\n         * @param publisher The publisher address of the index you are targetting.\n         * @param userData Extra user data provided.\n         * @param overrides ethers overrides object for more control over the transaction sent.\n         * @returns {Operation} An instance of Operation which can be executed or batched.\n         */\n        this.claim = (params) => {\n            const normalizedPublisher = normalizeAddress(params.publisher);\n            const normalizedToken = normalizeAddress(params.superToken);\n            const normalizedSubscriber = normalizeAddress(params.subscriber);\n            const callData = idaInterface.encodeFunctionData(\"claim\", [\n                normalizedToken,\n                normalizedPublisher,\n                params.indexId,\n                normalizedSubscriber,\n                \"0x\",\n            ]);\n            return this.host.populateCallAgreementTxnAndReturnOperation(this.options.config.idaV1Address, callData, params.userData, params.overrides);\n        };\n        this.options = options;\n        this.host = new Host(options.config.hostAddress);\n        this.contract = new ethers.Contract(this.options.config.idaV1Address, IInstantDistributionAgreementV1ABI.abi);\n    }\n}\n//# sourceMappingURL=InstantDistributionAgreementV1.js.map"]},"metadata":{},"sourceType":"module"}