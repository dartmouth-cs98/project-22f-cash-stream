{"ast":null,"code":"import { SFError } from \"./SFError\";\nimport { chainIds, chainIdToResolverDataMap } from \"./constants\";\nimport { isNullOrEmpty } from \"./utils\";\nexport var validateFrameworkConstructorOptions = function validateFrameworkConstructorOptions(options) {\n  if (!options.chainId) {\n    throw new SFError({\n      type: \"FRAMEWORK_INITIALIZATION\",\n      customMessage: \"You must input chainId.\"\n    });\n  }\n  if (!options.provider) {\n    throw new SFError({\n      type: \"FRAMEWORK_INITIALIZATION\",\n      customMessage: \"You must pass in a provider, an injected web3.js or ethers.js instance when initializing the framework.\"\n    });\n  }\n  // if the user inputs a chainId that isn't part of the resolver\n  // that is, an unsupported network/chain\n  if (options.chainId != null && !chainIds.includes(options.chainId)) {\n    if (isNullOrEmpty(options.resolverAddress)) {\n      throw new SFError({\n        type: \"FRAMEWORK_INITIALIZATION\",\n        customMessage: \"You must input your own resolver address if you use an unsupported network.\"\n      });\n    }\n  }\n};\n/**\n * Subgraph Query endpoint is empty string and will break at runtime if this is not handled.\n * @param options\n * @returns SubgraphQueriesEndpoint which is a custom endpoint or based on selected network\n */\nexport var getSubgraphQueriesEndpoint = function getSubgraphQueriesEndpoint(options) {\n  var resolverData = options.chainId ? chainIdToResolverDataMap.get(options.chainId) : null;\n  if (resolverData) {\n    return resolverData.subgraphAPIEndpoint;\n  }\n  return \"\"; // return empty string\n};\n/**\n * We check that the user has input a networkName or chainId and that they are both supported.\n * @param options.chainId the chainId of the desired network\n * @param options.networkName the name of the desired network\n * @returns the network name\n */\nexport var getNetworkName = function getNetworkName(options) {\n  var _a;\n  return (options.chainId ? (_a = chainIdToResolverDataMap.get(options.chainId)) === null || _a === void 0 ? void 0 : _a.networkName : undefined) || \"custom\";\n};","map":{"version":3,"sources":["../../src/frameworkHelpers.ts"],"names":[],"mappings":"AACA,SAAS,OAAO,QAAQ,WAAW;AACnC,SAAS,QAAQ,EAAE,wBAAwB,QAAQ,aAAa;AAChE,SAAS,aAAa,QAAQ,SAAS;AAEvC,OAAO,IAAM,mCAAmC,GAAG,SAAtC,mCAAmC,CAC5C,OAA0B,EAC1B;EACA,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE;IAClB,MAAM,IAAI,OAAO,CAAC;MACd,IAAI,EAAE,0BAA0B;MAChC,aAAa,EAAE;KAClB,CAAC;EACL;EAED,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE;IACnB,MAAM,IAAI,OAAO,CAAC;MACd,IAAI,EAAE,0BAA0B;MAChC,aAAa,EACT;KACP,CAAC;EACL;EAED;EACA;EACA,IAAI,OAAO,CAAC,OAAO,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;IAChE,IAAI,aAAa,CAAC,OAAO,CAAC,eAAe,CAAC,EAAE;MACxC,MAAM,IAAI,OAAO,CAAC;QACd,IAAI,EAAE,0BAA0B;QAChC,aAAa,EACT;OACP,CAAC;IACL;EACJ;AACL,CAAC;AAED;;;;AAIG;AACH,OAAO,IAAM,0BAA0B,GAAG,SAA7B,0BAA0B,CAAI,OAA0B,EAAI;EACrE,IAAM,YAAY,GAAG,OAAO,CAAC,OAAO,GAC9B,wBAAwB,CAAC,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC,GAC7C,IAAI;EACV,IAAI,YAAY,EAAE;IACd,OAAO,YAAY,CAAC,mBAAmB;EAC1C;EAED,OAAO,EAAE,CAAC,CAAC;AACf,CAAC;AAMD;;;;;AAKG;AACH,OAAO,IAAM,cAAc,GAAG,SAAjB,cAAc,CAAI,OAA2B,EAAY;;EAClE,OACI,CAAC,OAAO,CAAC,OAAO,GACV,CAAA,EAAA,GAAA,wBAAwB,CAAC,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,WAAW,GAC1D,SAAS,KAAK,QAAQ;AAEpC,CAAC","sourceRoot":"","sourcesContent":["import { SFError } from \"./SFError\";\nimport { chainIds, chainIdToResolverDataMap } from \"./constants\";\nimport { isNullOrEmpty } from \"./utils\";\nexport const validateFrameworkConstructorOptions = (options) => {\n    if (!options.chainId) {\n        throw new SFError({\n            type: \"FRAMEWORK_INITIALIZATION\",\n            customMessage: \"You must input chainId.\",\n        });\n    }\n    if (!options.provider) {\n        throw new SFError({\n            type: \"FRAMEWORK_INITIALIZATION\",\n            customMessage: \"You must pass in a provider, an injected web3.js or ethers.js instance when initializing the framework.\",\n        });\n    }\n    // if the user inputs a chainId that isn't part of the resolver\n    // that is, an unsupported network/chain\n    if (options.chainId != null && !chainIds.includes(options.chainId)) {\n        if (isNullOrEmpty(options.resolverAddress)) {\n            throw new SFError({\n                type: \"FRAMEWORK_INITIALIZATION\",\n                customMessage: \"You must input your own resolver address if you use an unsupported network.\",\n            });\n        }\n    }\n};\n/**\n * Subgraph Query endpoint is empty string and will break at runtime if this is not handled.\n * @param options\n * @returns SubgraphQueriesEndpoint which is a custom endpoint or based on selected network\n */\nexport const getSubgraphQueriesEndpoint = (options) => {\n    const resolverData = options.chainId\n        ? chainIdToResolverDataMap.get(options.chainId)\n        : null;\n    if (resolverData) {\n        return resolverData.subgraphAPIEndpoint;\n    }\n    return \"\"; // return empty string\n};\n/**\n * We check that the user has input a networkName or chainId and that they are both supported.\n * @param options.chainId the chainId of the desired network\n * @param options.networkName the name of the desired network\n * @returns the network name\n */\nexport const getNetworkName = (options) => {\n    var _a;\n    return ((options.chainId\n        ? (_a = chainIdToResolverDataMap.get(options.chainId)) === null || _a === void 0 ? void 0 : _a.networkName\n        : undefined) || \"custom\");\n};\n//# sourceMappingURL=frameworkHelpers.js.map"]},"metadata":{},"sourceType":"module"}