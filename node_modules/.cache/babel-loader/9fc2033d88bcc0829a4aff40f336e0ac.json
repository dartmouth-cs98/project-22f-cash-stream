{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { arrayify, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nvar logger = new Logger(version);\nexport function checkResultErrors(result) {\n  // Find the first error (if any)\n  var errors = [];\n  var checkErrors = function checkErrors(path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n    for (var key in object) {\n      var childPath = path.slice();\n      childPath.push(key);\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n  checkErrors([], result);\n  return errors;\n}\nexport var Coder = /*#__PURE__*/function () {\n  function Coder(name, type, localName, dynamic) {\n    _classCallCheck(this, Coder);\n    // @TODO: defineReadOnly these\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n  _createClass(Coder, [{\n    key: \"_throwError\",\n    value: function _throwError(message, value) {\n      logger.throwArgumentError(message, this.localName, value);\n    }\n  }]);\n  return Coder;\n}();\nexport var Writer = /*#__PURE__*/function () {\n  function Writer(wordSize) {\n    _classCallCheck(this, Writer);\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    this._data = [];\n    this._dataLength = 0;\n    this._padding = new Uint8Array(wordSize);\n  }\n  _createClass(Writer, [{\n    key: \"data\",\n    get: function get() {\n      return hexConcat(this._data);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._dataLength;\n    }\n  }, {\n    key: \"_writeData\",\n    value: function _writeData(data) {\n      this._data.push(data);\n      this._dataLength += data.length;\n      return data.length;\n    }\n  }, {\n    key: \"appendWriter\",\n    value: function appendWriter(writer) {\n      return this._writeData(concat(writer._data));\n    }\n    // Arrayish items; padded on the right to wordSize\n  }, {\n    key: \"writeBytes\",\n    value: function writeBytes(value) {\n      var bytes = arrayify(value);\n      var paddingOffset = bytes.length % this.wordSize;\n      if (paddingOffset) {\n        bytes = concat([bytes, this._padding.slice(paddingOffset)]);\n      }\n      return this._writeData(bytes);\n    }\n  }, {\n    key: \"_getValue\",\n    value: function _getValue(value) {\n      var bytes = arrayify(BigNumber.from(value));\n      if (bytes.length > this.wordSize) {\n        logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n          length: this.wordSize,\n          offset: bytes.length\n        });\n      }\n      if (bytes.length % this.wordSize) {\n        bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n      }\n      return bytes;\n    }\n    // BigNumberish items; padded on the left to wordSize\n  }, {\n    key: \"writeValue\",\n    value: function writeValue(value) {\n      return this._writeData(this._getValue(value));\n    }\n  }, {\n    key: \"writeUpdatableValue\",\n    value: function writeUpdatableValue() {\n      var _this = this;\n      var offset = this._data.length;\n      this._data.push(this._padding);\n      this._dataLength += this.wordSize;\n      return function (value) {\n        _this._data[offset] = _this._getValue(value);\n      };\n    }\n  }]);\n  return Writer;\n}();\nexport var Reader = /*#__PURE__*/function () {\n  function Reader(data, wordSize, coerceFunc, allowLoose) {\n    _classCallCheck(this, Reader);\n    defineReadOnly(this, \"_data\", arrayify(data));\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n    defineReadOnly(this, \"allowLoose\", allowLoose);\n    this._offset = 0;\n  }\n  _createClass(Reader, [{\n    key: \"data\",\n    get: function get() {\n      return hexlify(this._data);\n    }\n  }, {\n    key: \"consumed\",\n    get: function get() {\n      return this._offset;\n    }\n    // The default Coerce function\n  }, {\n    key: \"coerce\",\n    value: function coerce(name, value) {\n      if (this._coerceFunc) {\n        return this._coerceFunc(name, value);\n      }\n      return Reader.coerce(name, value);\n    }\n  }, {\n    key: \"_peekBytes\",\n    value: function _peekBytes(offset, length, loose) {\n      var alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n      if (this._offset + alignedLength > this._data.length) {\n        if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n          alignedLength = length;\n        } else {\n          logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n            length: this._data.length,\n            offset: this._offset + alignedLength\n          });\n        }\n      }\n      return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n  }, {\n    key: \"subReader\",\n    value: function subReader(offset) {\n      return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n  }, {\n    key: \"readBytes\",\n    value: function readBytes(length, loose) {\n      var bytes = this._peekBytes(0, length, !!loose);\n      this._offset += bytes.length;\n      // @TODO: Make sure the length..end bytes are all 0?\n      return bytes.slice(0, length);\n    }\n  }, {\n    key: \"readValue\",\n    value: function readValue() {\n      return BigNumber.from(this.readBytes(this.wordSize));\n    }\n  }], [{\n    key: \"coerce\",\n    value: function coerce(name, value) {\n      var match = name.match(\"^u?int([0-9]+)$\");\n      if (match && parseInt(match[1]) <= 48) {\n        value = value.toNumber();\n      }\n      return value;\n    }\n  }]);\n  return Reader;\n}();","map":{"version":3,"sources":["../../src.ts/coders/abstract-coder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nimport { arrayify, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\nexport function checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function (path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            }\n            catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nexport class Coder {\n    constructor(name, type, localName, dynamic) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    _throwError(message, value) {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n}\nexport class Writer {\n    constructor(wordSize) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n    get data() {\n        return hexConcat(this._data);\n    }\n    get length() { return this._dataLength; }\n    _writeData(data) {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this._writeData(concat(writer._data));\n    }\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value) {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([bytes, this._padding.slice(paddingOffset)]);\n        }\n        return this._writeData(bytes);\n    }\n    _getValue(value) {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n        }\n        return bytes;\n    }\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value) {\n        return this._writeData(this._getValue(value));\n    }\n    writeUpdatableValue() {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\nexport class Reader {\n    constructor(data, wordSize, coerceFunc, allowLoose) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n        this._offset = 0;\n    }\n    get data() { return hexlify(this._data); }\n    get consumed() { return this._offset; }\n    // The default Coerce function\n    static coerce(name, value) {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) {\n            value = value.toNumber();\n        }\n        return value;\n    }\n    coerce(name, value) {\n        if (this._coerceFunc) {\n            return this._coerceFunc(name, value);\n        }\n        return Reader.coerce(name, value);\n    }\n    _peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            }\n            else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n    subReader(offset) {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n    readBytes(length, loose) {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    readValue() {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n//# sourceMappingURL=abstract-coder.js.map"]},"metadata":{},"sourceType":"module"}