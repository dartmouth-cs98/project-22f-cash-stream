{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;\nfunction schemaHasRulesForType(_ref, type) {\n  var schema = _ref.schema,\n    self = _ref.self;\n  var group = self.RULES.types[type];\n  return group && group !== true && shouldUseGroup(schema, group);\n}\nexports.schemaHasRulesForType = schemaHasRulesForType;\nfunction shouldUseGroup(schema, group) {\n  return group.rules.some(function (rule) {\n    return shouldUseRule(schema, rule);\n  });\n}\nexports.shouldUseGroup = shouldUseGroup;\nfunction shouldUseRule(schema, rule) {\n  var _a;\n  return schema[rule.keyword] !== undefined || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some(function (kwd) {\n    return schema[kwd] !== undefined;\n  }));\n}\nexports.shouldUseRule = shouldUseRule;","map":{"version":3,"sources":["../../../lib/compile/validate/applicability.ts"],"names":[],"mappings":";;;;;;AAIA,SAAgB,qBAAqB,OAEnC,IAAc,EAAA;EAAA,IADb,MAAM,QAAN,MAAM;IAAE,IAAI,QAAJ,IAAI;EAGb,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC;EACpC,OAAO,KAAK,IAAI,KAAK,KAAK,IAAI,IAAI,cAAc,CAAC,MAAM,EAAE,KAAK,CAAC;AACjE;AANA,OAAA,CAAA,qBAAA,GAAA,qBAAA;AAQA,SAAgB,cAAc,CAAC,MAAuB,EAAE,KAAgB,EAAA;EACtE,OAAO,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,UAAC,IAAI;IAAA,OAAK,aAAa,CAAC,MAAM,EAAE,IAAI,CAAC;EAAA,EAAC;AAChE;AAFA,OAAA,CAAA,cAAA,GAAA,cAAA;AAIA,SAAgB,aAAa,CAAC,MAAuB,EAAE,IAAU,EAAA;;EAC/D,OACE,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,SAAS,KAClC,CAAA,EAAA,GAAA,IAAI,CAAC,UAAU,CAAC,UAAU,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,IAAI,CAAC,UAAC,GAAG;IAAA,OAAK,MAAM,CAAC,GAAG,CAAC,KAAK,SAAS;EAAA,EAAC,CAAA;AAExE;AALA,OAAA,CAAA,aAAA,GAAA,aAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;\nfunction schemaHasRulesForType({ schema, self }, type) {\n    const group = self.RULES.types[type];\n    return group && group !== true && shouldUseGroup(schema, group);\n}\nexports.schemaHasRulesForType = schemaHasRulesForType;\nfunction shouldUseGroup(schema, group) {\n    return group.rules.some((rule) => shouldUseRule(schema, rule));\n}\nexports.shouldUseGroup = shouldUseGroup;\nfunction shouldUseRule(schema, rule) {\n    var _a;\n    return (schema[rule.keyword] !== undefined ||\n        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));\n}\nexports.shouldUseRule = shouldUseRule;\n//# sourceMappingURL=applicability.js.map"]},"metadata":{},"sourceType":"script"}