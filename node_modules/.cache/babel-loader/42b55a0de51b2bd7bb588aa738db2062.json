{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar codegen_1 = require(\"../../compile/codegen\");\nvar util_1 = require(\"../../compile/util\");\nvar error = {\n  message: function message(_ref) {\n    var params = _ref.params;\n    return (0, codegen_1.str)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"must match \\\"\", \"\\\" schema\"])), params.ifClause);\n  },\n  params: function params(_ref2) {\n    var _params = _ref2.params;\n    return (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"{failingKeyword: \", \"}\"])), _params.ifClause);\n  }\n};\nvar def = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error: error,\n  code: function code(cxt) {\n    var gen = cxt.gen,\n      parentSchema = cxt.parentSchema,\n      it = cxt.it;\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n    }\n    var hasThen = hasSchema(it, \"then\");\n    var hasElse = hasSchema(it, \"else\");\n    if (!hasThen && !hasElse) return;\n    var valid = gen.let(\"valid\", true);\n    var schValid = gen.name(\"_valid\");\n    validateIf();\n    cxt.reset();\n    if (hasThen && hasElse) {\n      var ifClause = gen.let(\"ifClause\");\n      cxt.setParams({\n        ifClause: ifClause\n      });\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"));\n    } else {\n      gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n    }\n    cxt.pass(valid, function () {\n      return cxt.error(true);\n    });\n    function validateIf() {\n      var schCxt = cxt.subschema({\n        keyword: \"if\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false\n      }, schValid);\n      cxt.mergeEvaluated(schCxt);\n    }\n    function validateClause(keyword, ifClause) {\n      return function () {\n        var schCxt = cxt.subschema({\n          keyword: keyword\n        }, schValid);\n        gen.assign(valid, schValid);\n        cxt.mergeValidEvaluated(schCxt, valid);\n        if (ifClause) gen.assign(ifClause, (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \"\"])), keyword));else cxt.setParams({\n          ifClause: keyword\n        });\n      };\n    }\n  }\n};\nfunction hasSchema(it, keyword) {\n  var schema = it.schema[keyword];\n  return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/if.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params }) => (0, codegen_1.str) `must match \"${params.ifClause}\" schema`,\n    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,\n};\nconst def = {\n    keyword: \"if\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, parentSchema, it } = cxt;\n        if (parentSchema.then === undefined && parentSchema.else === undefined) {\n            (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n        }\n        const hasThen = hasSchema(it, \"then\");\n        const hasElse = hasSchema(it, \"else\");\n        if (!hasThen && !hasElse)\n            return;\n        const valid = gen.let(\"valid\", true);\n        const schValid = gen.name(\"_valid\");\n        validateIf();\n        cxt.reset();\n        if (hasThen && hasElse) {\n            const ifClause = gen.let(\"ifClause\");\n            cxt.setParams({ ifClause });\n            gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n        }\n        else if (hasThen) {\n            gen.if(schValid, validateClause(\"then\"));\n        }\n        else {\n            gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n        }\n        cxt.pass(valid, () => cxt.error(true));\n        function validateIf() {\n            const schCxt = cxt.subschema({\n                keyword: \"if\",\n                compositeRule: true,\n                createErrors: false,\n                allErrors: false,\n            }, schValid);\n            cxt.mergeEvaluated(schCxt);\n        }\n        function validateClause(keyword, ifClause) {\n            return () => {\n                const schCxt = cxt.subschema({ keyword }, schValid);\n                gen.assign(valid, schValid);\n                cxt.mergeValidEvaluated(schCxt, valid);\n                if (ifClause)\n                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);\n                else\n                    cxt.setParams({ ifClause: keyword });\n            };\n        }\n    },\n};\nfunction hasSchema(it, keyword) {\n    const schema = it.schema[keyword];\n    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\nexports.default = def;\n//# sourceMappingURL=if.js.map"]},"metadata":{},"sourceType":"script"}