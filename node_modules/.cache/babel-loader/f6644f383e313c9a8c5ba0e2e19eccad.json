{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateTuple = void 0;\nvar codegen_1 = require(\"../../compile/codegen\");\nvar util_1 = require(\"../../compile/util\");\nvar code_1 = require(\"../code\");\nvar def = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code: function code(cxt) {\n    var schema = cxt.schema,\n      it = cxt.it;\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema);\n    it.items = true;\n    if ((0, util_1.alwaysValidSchema)(it, schema)) return;\n    cxt.ok((0, code_1.validateArray)(cxt));\n  }\n};\nfunction validateTuple(cxt, extraItems) {\n  var schArr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : cxt.schema;\n  var gen = cxt.gen,\n    parentSchema = cxt.parentSchema,\n    data = cxt.data,\n    keyword = cxt.keyword,\n    it = cxt.it;\n  checkStrictTuple(parentSchema);\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n  }\n  var valid = gen.name(\"valid\");\n  var len = gen.const(\"len\", (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \".length\"])), data));\n  schArr.forEach(function (sch, i) {\n    if ((0, util_1.alwaysValidSchema)(it, sch)) return;\n    gen.if((0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \" > \", \"\"])), len, i), function () {\n      return cxt.subschema({\n        keyword: keyword,\n        schemaProp: i,\n        dataProp: i\n      }, valid);\n    });\n    cxt.ok(valid);\n  });\n  function checkStrictTuple(sch) {\n    var opts = it.opts,\n      errSchemaPath = it.errSchemaPath;\n    var l = schArr.length;\n    var fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n    if (opts.strictTuples && !fullTuple) {\n      var msg = \"\\\"\".concat(keyword, \"\\\" is \").concat(l, \"-tuple, but minItems or maxItems/\").concat(extraItems, \" are not specified or different at path \\\"\").concat(errSchemaPath, \"\\\"\");\n      (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n    }\n  }\n}\nexports.validateTuple = validateTuple;\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/items.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateTuple = void 0;\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst code_1 = require(\"../code\");\nconst def = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"array\", \"boolean\"],\n    before: \"uniqueItems\",\n    code(cxt) {\n        const { schema, it } = cxt;\n        if (Array.isArray(schema))\n            return validateTuple(cxt, \"additionalItems\", schema);\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nfunction validateTuple(cxt, extraItems, schArr = cxt.schema) {\n    const { gen, parentSchema, data, keyword, it } = cxt;\n    checkStrictTuple(parentSchema);\n    if (it.opts.unevaluated && schArr.length && it.items !== true) {\n        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n    }\n    const valid = gen.name(\"valid\");\n    const len = gen.const(\"len\", (0, codegen_1._) `${data}.length`);\n    schArr.forEach((sch, i) => {\n        if ((0, util_1.alwaysValidSchema)(it, sch))\n            return;\n        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({\n            keyword,\n            schemaProp: i,\n            dataProp: i,\n        }, valid));\n        cxt.ok(valid);\n    });\n    function checkStrictTuple(sch) {\n        const { opts, errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n            const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`;\n            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n    }\n}\nexports.validateTuple = validateTuple;\nexports.default = def;\n//# sourceMappingURL=items.js.map"]},"metadata":{},"sourceType":"script"}