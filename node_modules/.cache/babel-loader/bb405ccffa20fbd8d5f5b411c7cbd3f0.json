{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _templateObject, _templateObject2, _templateObject3;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar codegen_1 = require(\"../../compile/codegen\");\nvar util_1 = require(\"../../compile/util\");\nvar error = {\n  message: \"must match exactly one schema in oneOf\",\n  params: function params(_ref) {\n    var _params = _ref.params;\n    return (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"{passingSchemas: \", \"}\"])), _params.passing);\n  }\n};\nvar def = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error: error,\n  code: function code(cxt) {\n    var gen = cxt.gen,\n      schema = cxt.schema,\n      parentSchema = cxt.parentSchema,\n      it = cxt.it;\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n    if (it.opts.discriminator && parentSchema.discriminator) return;\n    var schArr = schema;\n    var valid = gen.let(\"valid\", false);\n    var passing = gen.let(\"passing\", null);\n    var schValid = gen.name(\"_valid\");\n    cxt.setParams({\n      passing: passing\n    });\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n    gen.block(validateOneOf);\n    cxt.result(valid, function () {\n      return cxt.reset();\n    }, function () {\n      return cxt.error(true);\n    });\n    function validateOneOf() {\n      schArr.forEach(function (sch, i) {\n        var schCxt;\n        if ((0, util_1.alwaysValidSchema)(it, sch)) {\n          gen.var(schValid, true);\n        } else {\n          schCxt = cxt.subschema({\n            keyword: \"oneOf\",\n            schemaProp: i,\n            compositeRule: true\n          }, schValid);\n        }\n        if (i > 0) {\n          gen.if((0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \" && \", \"\"])), schValid, valid)).assign(valid, false).assign(passing, (0, codegen_1._)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"[\", \", \", \"]\"])), passing, i)).else();\n        }\n        gen.if(schValid, function () {\n          gen.assign(valid, true);\n          gen.assign(passing, i);\n          if (schCxt) cxt.mergeEvaluated(schCxt, codegen_1.Name);\n        });\n      });\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/oneOf.ts"],"names":[],"mappings":";;;;;;;AAOA,IAAA,SAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;AASA,IAAM,KAAK,GAA2B;EACpC,OAAO,EAAE,wCAAwC;EACjD,MAAM,EAAE;IAAA,IAAE,OAAM,QAAN,MAAM;IAAA,QAAM,CAAA,EAAA,SAAA,CAAA,CAAC,6FAAoB,OAAM,CAAC,OAAO;EAAA;CAC1D;AAED,IAAM,GAAG,GAA0B;EACjC,OAAO,EAAE,OAAO;EAChB,UAAU,EAAE,OAAO;EACnB,WAAW,EAAE,IAAI;EACjB,KAAK,EAAL,KAAK;EACL,IAAI,gBAAC,GAAe,EAAA;IAClB,IAAO,GAAG,GAA8B,GAAG,CAApC,GAAG;MAAE,MAAM,GAAsB,GAAG,CAA/B,MAAM;MAAE,YAAY,GAAQ,GAAG,CAAvB,YAAY;MAAE,EAAE,GAAI,GAAG,CAAT,EAAE;IACpC;IACA,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC;IACvE,IAAI,EAAE,CAAC,IAAI,CAAC,aAAa,IAAI,YAAY,CAAC,aAAa,EAAE;IACzD,IAAM,MAAM,GAAgB,MAAM;IAClC,IAAM,KAAK,GAAG,GAAG,CAAC,GAAG,CAAC,OAAO,EAAE,KAAK,CAAC;IACrC,IAAM,OAAO,GAAG,GAAG,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC;IACxC,IAAM,QAAQ,GAAG,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC;IACnC,GAAG,CAAC,SAAS,CAAC;MAAC,OAAO,EAAP;IAAO,CAAC,CAAC;IACxB;IAEA,GAAG,CAAC,KAAK,CAAC,aAAa,CAAC;IAExB,GAAG,CAAC,MAAM,CACR,KAAK,EACL;MAAA,OAAM,GAAG,CAAC,KAAK,EAAE;IAAA,GACjB;MAAA,OAAM,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC;IAAA,EACtB;IAED,SAAS,aAAa,GAAA;MACpB,MAAM,CAAC,OAAO,CAAC,UAAC,GAAc,EAAE,CAAS,EAAI;QAC3C,IAAI,MAA6B;QACjC,IAAI,CAAA,CAAA,EAAA,MAAA,CAAA,iBAAiB,EAAC,EAAE,EAAE,GAAG,CAAC,EAAE;UAC9B,GAAG,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC;SACxB,MAAM;UACL,MAAM,GAAG,GAAG,CAAC,SAAS,CACpB;YACE,OAAO,EAAE,OAAO;YAChB,UAAU,EAAE,CAAC;YACb,aAAa,EAAE;WAChB,EACD,QAAQ,CACT;QACF;QAED,IAAI,CAAC,GAAG,CAAC,EAAE;UACT,GAAG,CACA,EAAE,EAAC,CAAA,EAAA,SAAA,CAAA,CAAC,qFAAG,QAAQ,EAAO,KAAK,EAAG,CAC9B,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,CACpB,MAAM,CAAC,OAAO,GAAE,CAAA,EAAA,SAAA,CAAA,CAAC,qFAAI,OAAO,EAAK,CAAC,EAAI,CACtC,IAAI,EAAE;QACV;QAED,GAAG,CAAC,EAAE,CAAC,QAAQ,EAAE,YAAK;UACpB,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC;UACvB,GAAG,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,CAAC;UACtB,IAAI,MAAM,EAAE,GAAG,CAAC,cAAc,CAAC,MAAM,EAAE,SAAA,CAAA,IAAI,CAAC;QAC9C,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ;EACF;CACD;AAED,OAAA,CAAA,OAAA,GAAe,GAAG","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: \"must match exactly one schema in oneOf\",\n    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,\n};\nconst def = {\n    keyword: \"oneOf\",\n    schemaType: \"array\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error(\"ajv implementation error\");\n        if (it.opts.discriminator && parentSchema.discriminator)\n            return;\n        const schArr = schema;\n        const valid = gen.let(\"valid\", false);\n        const passing = gen.let(\"passing\", null);\n        const schValid = gen.name(\"_valid\");\n        cxt.setParams({ passing });\n        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n        gen.block(validateOneOf);\n        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n        function validateOneOf() {\n            schArr.forEach((sch, i) => {\n                let schCxt;\n                if ((0, util_1.alwaysValidSchema)(it, sch)) {\n                    gen.var(schValid, true);\n                }\n                else {\n                    schCxt = cxt.subschema({\n                        keyword: \"oneOf\",\n                        schemaProp: i,\n                        compositeRule: true,\n                    }, schValid);\n                }\n                if (i > 0) {\n                    gen\n                        .if((0, codegen_1._) `${schValid} && ${valid}`)\n                        .assign(valid, false)\n                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)\n                        .else();\n                }\n                gen.if(schValid, () => {\n                    gen.assign(valid, true);\n                    gen.assign(passing, i);\n                    if (schCxt)\n                        cxt.mergeEvaluated(schCxt, codegen_1.Name);\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=oneOf.js.map"]},"metadata":{},"sourceType":"script"}