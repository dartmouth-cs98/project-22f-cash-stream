{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"/Users/taykim/Desktop/cs98/cs98_fall_demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nfunction now() {\n  return new Date().getTime();\n}\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks) {\n  var result = null;\n  for (var i = 0; i < networks.length; i++) {\n    var network = networks[i];\n    // Null! We do not know our network; bail.\n    if (network == null) {\n      return null;\n    }\n    if (result) {\n      // Make sure the network matches the previous networks\n      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {\n        logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n      }\n    } else {\n      result = network;\n    }\n  }\n  return result;\n}\nfunction median(values, maxDelta) {\n  values = values.slice().sort();\n  var middle = Math.floor(values.length / 2);\n  // Odd length; take the middle\n  if (values.length % 2) {\n    return values[middle];\n  }\n  // Even length; take the average of the two middle\n  var a = values[middle - 1],\n    b = values[middle];\n  if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n    return null;\n  }\n  return (a + b) / 2;\n}\nfunction serialize(value) {\n  if (value === null) {\n    return \"null\";\n  } else if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return JSON.stringify(value);\n  } else if (typeof value === \"string\") {\n    return value;\n  } else if (BigNumber.isBigNumber(value)) {\n    return value.toString();\n  } else if (Array.isArray(value)) {\n    return JSON.stringify(value.map(function (i) {\n      return serialize(i);\n    }));\n  } else if (typeof value === \"object\") {\n    var keys = Object.keys(value);\n    keys.sort();\n    return \"{\" + keys.map(function (key) {\n      var v = value[key];\n      if (typeof v === \"function\") {\n        v = \"[function]\";\n      } else {\n        v = serialize(v);\n      }\n      return JSON.stringify(key) + \":\" + v;\n    }).join(\",\") + \"}\";\n  }\n  throw new Error(\"unknown value type: \" + typeof value);\n}\n// Next request ID to use for emitting debug info\nvar nextRid = 1;\n;\nfunction stall(duration) {\n  var cancel = null;\n  var timer = null;\n  var promise = new Promise(function (resolve) {\n    cancel = function cancel() {\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n      resolve();\n    };\n    timer = setTimeout(cancel, duration);\n  });\n  var wait = function wait(func) {\n    promise = promise.then(func);\n    return promise;\n  };\n  function getPromise() {\n    return promise;\n  }\n  return {\n    cancel: cancel,\n    getPromise: getPromise,\n    wait: wait\n  };\n}\nvar ForwardErrors = [Logger.errors.CALL_EXCEPTION, Logger.errors.INSUFFICIENT_FUNDS, Logger.errors.NONCE_EXPIRED, Logger.errors.REPLACEMENT_UNDERPRICED, Logger.errors.UNPREDICTABLE_GAS_LIMIT];\nvar ForwardProperties = [\"address\", \"args\", \"errorArgs\", \"errorSignature\", \"method\", \"transaction\"];\n;\nfunction exposeDebugConfig(config, now) {\n  var result = {\n    weight: config.weight\n  };\n  Object.defineProperty(result, \"provider\", {\n    get: function get() {\n      return config.provider;\n    }\n  });\n  if (config.start) {\n    result.start = config.start;\n  }\n  if (now) {\n    result.duration = now - config.start;\n  }\n  if (config.done) {\n    if (config.error) {\n      result.error = config.error;\n    } else {\n      result.result = config.result || null;\n    }\n  }\n  return result;\n}\nfunction normalizedTally(normalize, quorum) {\n  return function (configs) {\n    // Count the votes for each result\n    var tally = {};\n    configs.forEach(function (c) {\n      var value = normalize(c.result);\n      if (!tally[value]) {\n        tally[value] = {\n          count: 0,\n          result: c.result\n        };\n      }\n      tally[value].count++;\n    });\n    // Check for a quorum on any given result\n    var keys = Object.keys(tally);\n    for (var i = 0; i < keys.length; i++) {\n      var check = tally[keys[i]];\n      if (check.count >= quorum) {\n        return check.result;\n      }\n    }\n    // No quroum\n    return undefined;\n  };\n}\nfunction getProcessFunc(provider, method, params) {\n  var normalize = serialize;\n  switch (method) {\n    case \"getBlockNumber\":\n      // Return the median value, unless there is (median + 1) is also\n      // present, in which case that is probably true and the median\n      // is going to be stale soon. In the event of a malicious node,\n      // the lie will be true soon enough.\n      return function (configs) {\n        var values = configs.map(function (c) {\n          return c.result;\n        });\n        // Get the median block number\n        var blockNumber = median(configs.map(function (c) {\n          return c.result;\n        }), 2);\n        if (blockNumber == null) {\n          return undefined;\n        }\n        blockNumber = Math.ceil(blockNumber);\n        // If the next block height is present, its prolly safe to use\n        if (values.indexOf(blockNumber + 1) >= 0) {\n          blockNumber++;\n        }\n        // Don't ever roll back the blockNumber\n        if (blockNumber >= provider._highestBlockNumber) {\n          provider._highestBlockNumber = blockNumber;\n        }\n        return provider._highestBlockNumber;\n      };\n    case \"getGasPrice\":\n      // Return the middle (round index up) value, similar to median\n      // but do not average even entries and choose the higher.\n      // Malicious actors must compromise 50% of the nodes to lie.\n      return function (configs) {\n        var values = configs.map(function (c) {\n          return c.result;\n        });\n        values.sort();\n        return values[Math.floor(values.length / 2)];\n      };\n    case \"getEtherPrice\":\n      // Returns the median price. Malicious actors must compromise at\n      // least 50% of the nodes to lie (in a meaningful way).\n      return function (configs) {\n        return median(configs.map(function (c) {\n          return c.result;\n        }));\n      };\n    // No additional normalizing required; serialize is enough\n    case \"getBalance\":\n    case \"getTransactionCount\":\n    case \"getCode\":\n    case \"getStorageAt\":\n    case \"call\":\n    case \"estimateGas\":\n    case \"getLogs\":\n      break;\n    // We drop the confirmations from transactions as it is approximate\n    case \"getTransaction\":\n    case \"getTransactionReceipt\":\n      normalize = function normalize(tx) {\n        if (tx == null) {\n          return null;\n        }\n        tx = shallowCopy(tx);\n        tx.confirmations = -1;\n        return serialize(tx);\n      };\n      break;\n    // We drop the confirmations from transactions as it is approximate\n    case \"getBlock\":\n      // We drop the confirmations from transactions as it is approximate\n      if (params.includeTransactions) {\n        normalize = function normalize(block) {\n          if (block == null) {\n            return null;\n          }\n          block = shallowCopy(block);\n          block.transactions = block.transactions.map(function (tx) {\n            tx = shallowCopy(tx);\n            tx.confirmations = -1;\n            return tx;\n          });\n          return serialize(block);\n        };\n      } else {\n        normalize = function normalize(block) {\n          if (block == null) {\n            return null;\n          }\n          return serialize(block);\n        };\n      }\n      break;\n    default:\n      throw new Error(\"unknown method: \" + method);\n  }\n  // Return the result if and only if the expected quorum is\n  // satisfied and agreed upon for the final result.\n  return normalizedTally(normalize, provider.quorum);\n}\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nfunction waitForSync(config, blockNumber) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var provider;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            provider = config.provider;\n            if (!(provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1)) {\n              _context.next = 3;\n              break;\n            }\n            return _context.abrupt(\"return\", provider);\n          case 3:\n            return _context.abrupt(\"return\", poll(function () {\n              return new Promise(function (resolve, reject) {\n                setTimeout(function () {\n                  // We are synced\n                  if (provider.blockNumber >= blockNumber) {\n                    return resolve(provider);\n                  }\n                  // We're done; just quit\n                  if (config.cancelled) {\n                    return resolve(null);\n                  }\n                  // Try again, next block\n                  return resolve(undefined);\n                }, 0);\n              });\n            }, {\n              oncePoll: provider\n            }));\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\nfunction getRunner(config, currentBlockNumber, method, params) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var provider, filter;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            provider = config.provider;\n            _context2.t0 = method;\n            _context2.next = _context2.t0 === \"getBlockNumber\" ? 4 : _context2.t0 === \"getGasPrice\" ? 4 : _context2.t0 === \"getEtherPrice\" ? 5 : _context2.t0 === \"getBalance\" ? 8 : _context2.t0 === \"getTransactionCount\" ? 8 : _context2.t0 === \"getCode\" ? 8 : _context2.t0 === \"getStorageAt\" ? 13 : _context2.t0 === \"getBlock\" ? 18 : _context2.t0 === \"call\" ? 23 : _context2.t0 === \"estimateGas\" ? 23 : _context2.t0 === \"getTransaction\" ? 28 : _context2.t0 === \"getTransactionReceipt\" ? 28 : _context2.t0 === \"getLogs\" ? 29 : 35;\n            break;\n          case 4:\n            return _context2.abrupt(\"return\", provider[method]());\n          case 5:\n            if (!provider.getEtherPrice) {\n              _context2.next = 7;\n              break;\n            }\n            return _context2.abrupt(\"return\", provider.getEtherPrice());\n          case 7:\n            return _context2.abrupt(\"break\", 35);\n          case 8:\n            if (!(params.blockTag && isHexString(params.blockTag))) {\n              _context2.next = 12;\n              break;\n            }\n            _context2.next = 11;\n            return waitForSync(config, currentBlockNumber);\n          case 11:\n            provider = _context2.sent;\n          case 12:\n            return _context2.abrupt(\"return\", provider[method](params.address, params.blockTag || \"latest\"));\n          case 13:\n            if (!(params.blockTag && isHexString(params.blockTag))) {\n              _context2.next = 17;\n              break;\n            }\n            _context2.next = 16;\n            return waitForSync(config, currentBlockNumber);\n          case 16:\n            provider = _context2.sent;\n          case 17:\n            return _context2.abrupt(\"return\", provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\"));\n          case 18:\n            if (!(params.blockTag && isHexString(params.blockTag))) {\n              _context2.next = 22;\n              break;\n            }\n            _context2.next = 21;\n            return waitForSync(config, currentBlockNumber);\n          case 21:\n            provider = _context2.sent;\n          case 22:\n            return _context2.abrupt(\"return\", provider[params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\"](params.blockTag || params.blockHash));\n          case 23:\n            if (!(params.blockTag && isHexString(params.blockTag))) {\n              _context2.next = 27;\n              break;\n            }\n            _context2.next = 26;\n            return waitForSync(config, currentBlockNumber);\n          case 26:\n            provider = _context2.sent;\n          case 27:\n            return _context2.abrupt(\"return\", provider[method](params.transaction));\n          case 28:\n            return _context2.abrupt(\"return\", provider[method](params.transactionHash));\n          case 29:\n            filter = params.filter;\n            if (!(filter.fromBlock && isHexString(filter.fromBlock) || filter.toBlock && isHexString(filter.toBlock))) {\n              _context2.next = 34;\n              break;\n            }\n            _context2.next = 33;\n            return waitForSync(config, currentBlockNumber);\n          case 33:\n            provider = _context2.sent;\n          case 34:\n            return _context2.abrupt(\"return\", provider.getLogs(filter));\n          case 35:\n            return _context2.abrupt(\"return\", logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n              method: method,\n              params: params\n            }));\n          case 36:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\nexport var FallbackProvider = /*#__PURE__*/function (_BaseProvider) {\n  _inherits(FallbackProvider, _BaseProvider);\n  var _super = _createSuper(FallbackProvider);\n  function FallbackProvider(providers, quorum) {\n    var _this;\n    _classCallCheck(this, FallbackProvider);\n    logger.checkNew(this instanceof FallbackProvider ? this.constructor : void 0, FallbackProvider);\n    if (providers.length === 0) {\n      logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n    }\n    var providerConfigs = providers.map(function (configOrProvider, index) {\n      if (Provider.isProvider(configOrProvider)) {\n        var stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n        var priority = 1;\n        return Object.freeze({\n          provider: configOrProvider,\n          weight: 1,\n          stallTimeout: stallTimeout,\n          priority: priority\n        });\n      }\n      var config = shallowCopy(configOrProvider);\n      if (config.priority == null) {\n        config.priority = 1;\n      }\n      if (config.stallTimeout == null) {\n        config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n      }\n      if (config.weight == null) {\n        config.weight = 1;\n      }\n      var weight = config.weight;\n      if (weight % 1 || weight > 512 || weight < 1) {\n        logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", \"providers[\".concat(index, \"].weight\"), weight);\n      }\n      return Object.freeze(config);\n    });\n    var total = providerConfigs.reduce(function (accum, c) {\n      return accum + c.weight;\n    }, 0);\n    if (quorum == null) {\n      quorum = total / 2;\n    } else if (quorum > total) {\n      logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n    }\n    // Are all providers' networks are known\n    var networkOrReady = checkNetworks(providerConfigs.map(function (c) {\n      return c.provider.network;\n    }));\n    // Not all networks are known; we must stall\n    if (networkOrReady == null) {\n      networkOrReady = new Promise(function (resolve, reject) {\n        setTimeout(function () {\n          _this.detectNetwork().then(resolve, reject);\n        }, 0);\n      });\n    }\n    _this = _super.call(this, networkOrReady);\n    // Preserve a copy, so we do not get mutated\n    defineReadOnly(_assertThisInitialized(_this), \"providerConfigs\", Object.freeze(providerConfigs));\n    defineReadOnly(_assertThisInitialized(_this), \"quorum\", quorum);\n    _this._highestBlockNumber = -1;\n    return _this;\n  }\n  _createClass(FallbackProvider, [{\n    key: \"detectNetwork\",\n    value: function detectNetwork() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var networks;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return Promise.all(this.providerConfigs.map(function (c) {\n                  return c.provider.getNetwork();\n                }));\n              case 2:\n                networks = _context3.sent;\n                return _context3.abrupt(\"return\", checkNetworks(networks));\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"perform\",\n    value: function perform(method, params) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var _this2 = this;\n        var results, _i, result, processFunc, configs, currentBlockNumber, i, first, _loop, _ret;\n        return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(method === \"sendTransaction\")) {\n                  _context5.next = 13;\n                  break;\n                }\n                _context5.next = 3;\n                return Promise.all(this.providerConfigs.map(function (c) {\n                  return c.provider.sendTransaction(params.signedTransaction).then(function (result) {\n                    return result.hash;\n                  }, function (error) {\n                    return error;\n                  });\n                }));\n              case 3:\n                results = _context5.sent;\n                _i = 0;\n              case 5:\n                if (!(_i < results.length)) {\n                  _context5.next = 12;\n                  break;\n                }\n                result = results[_i];\n                if (!(typeof result === \"string\")) {\n                  _context5.next = 9;\n                  break;\n                }\n                return _context5.abrupt(\"return\", result);\n              case 9:\n                _i++;\n                _context5.next = 5;\n                break;\n              case 12:\n                throw results[0];\n              case 13:\n                if (!(this._highestBlockNumber === -1 && method !== \"getBlockNumber\")) {\n                  _context5.next = 16;\n                  break;\n                }\n                _context5.next = 16;\n                return this.getBlockNumber();\n              case 16:\n                processFunc = getProcessFunc(this, method, params); // Shuffle the providers and then sort them by their priority; we\n                // shallowCopy them since we will store the result in them too\n                configs = shuffled(this.providerConfigs.map(shallowCopy));\n                configs.sort(function (a, b) {\n                  return a.priority - b.priority;\n                });\n                currentBlockNumber = this._highestBlockNumber;\n                i = 0;\n                first = true;\n                _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                  var t0, inflightWeight, _loop2, waiting, results, _result, errors;\n                  return _regeneratorRuntime().wrap(function _loop$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          t0 = now(); // Compute the inflight weight (exclude anything past)\n                          inflightWeight = configs.filter(function (c) {\n                            return c.runner && t0 - c.start < c.stallTimeout;\n                          }).reduce(function (accum, c) {\n                            return accum + c.weight;\n                          }, 0); // Start running enough to meet quorum\n                          _loop2 = function _loop2() {\n                            var config = configs[i++];\n                            var rid = nextRid++;\n                            config.start = now();\n                            config.staller = stall(config.stallTimeout);\n                            config.staller.wait(function () {\n                              config.staller = null;\n                            });\n                            config.runner = getRunner(config, currentBlockNumber, method, params).then(function (result) {\n                              config.done = true;\n                              config.result = result;\n                              if (_this2.listenerCount(\"debug\")) {\n                                _this2.emit(\"debug\", {\n                                  action: \"request\",\n                                  rid: rid,\n                                  backend: exposeDebugConfig(config, now()),\n                                  request: {\n                                    method: method,\n                                    params: deepCopy(params)\n                                  },\n                                  provider: _this2\n                                });\n                              }\n                            }, function (error) {\n                              config.done = true;\n                              config.error = error;\n                              if (_this2.listenerCount(\"debug\")) {\n                                _this2.emit(\"debug\", {\n                                  action: \"request\",\n                                  rid: rid,\n                                  backend: exposeDebugConfig(config, now()),\n                                  request: {\n                                    method: method,\n                                    params: deepCopy(params)\n                                  },\n                                  provider: _this2\n                                });\n                              }\n                            });\n                            if (_this2.listenerCount(\"debug\")) {\n                              _this2.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, null),\n                                request: {\n                                  method: method,\n                                  params: deepCopy(params)\n                                },\n                                provider: _this2\n                              });\n                            }\n                            inflightWeight += config.weight;\n                          };\n                          while (inflightWeight < _this2.quorum && i < configs.length) {\n                            _loop2();\n                          }\n                          // Wait for anything meaningful to finish or stall out\n                          waiting = [];\n                          configs.forEach(function (c) {\n                            if (c.done || !c.runner) {\n                              return;\n                            }\n                            waiting.push(c.runner);\n                            if (c.staller) {\n                              waiting.push(c.staller.getPromise());\n                            }\n                          });\n                          if (!waiting.length) {\n                            _context4.next = 9;\n                            break;\n                          }\n                          _context4.next = 9;\n                          return Promise.race(waiting);\n                        case 9:\n                          // Check the quorum and process the results; the process function\n                          // may additionally decide the quorum is not met\n                          results = configs.filter(function (c) {\n                            return c.done && c.error == null;\n                          });\n                          if (!(results.length >= _this2.quorum)) {\n                            _context4.next = 19;\n                            break;\n                          }\n                          _result = processFunc(results);\n                          if (!(_result !== undefined)) {\n                            _context4.next = 15;\n                            break;\n                          }\n                          // Shut down any stallers\n                          configs.forEach(function (c) {\n                            if (c.staller) {\n                              c.staller.cancel();\n                            }\n                            c.cancelled = true;\n                          });\n                          return _context4.abrupt(\"return\", {\n                            v: _result\n                          });\n                        case 15:\n                          if (first) {\n                            _context4.next = 18;\n                            break;\n                          }\n                          _context4.next = 18;\n                          return stall(100).getPromise();\n                        case 18:\n                          first = false;\n                        case 19:\n                          // No result, check for errors that should be forwarded\n                          errors = configs.reduce(function (accum, c) {\n                            if (!c.done || c.error == null) {\n                              return accum;\n                            }\n                            var code = c.error.code;\n                            if (ForwardErrors.indexOf(code) >= 0) {\n                              if (!accum[code]) {\n                                accum[code] = {\n                                  error: c.error,\n                                  weight: 0\n                                };\n                              }\n                              accum[code].weight += c.weight;\n                            }\n                            return accum;\n                          }, {});\n                          Object.keys(errors).forEach(function (errorCode) {\n                            var tally = errors[errorCode];\n                            if (tally.weight < _this2.quorum) {\n                              return;\n                            }\n                            // Shut down any stallers\n                            configs.forEach(function (c) {\n                              if (c.staller) {\n                                c.staller.cancel();\n                              }\n                              c.cancelled = true;\n                            });\n                            var e = tally.error;\n                            var props = {};\n                            ForwardProperties.forEach(function (name) {\n                              if (e[name] == null) {\n                                return;\n                              }\n                              props[name] = e[name];\n                            });\n                            logger.throwError(e.reason || e.message, errorCode, props);\n                          });\n                          // All configs have run to completion; we will never get more data\n                          if (!(configs.filter(function (c) {\n                            return !c.done;\n                          }).length === 0)) {\n                            _context4.next = 23;\n                            break;\n                          }\n                          return _context4.abrupt(\"return\", \"break\");\n                        case 23:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _loop);\n                });\n              case 23:\n                if (!true) {\n                  _context5.next = 32;\n                  break;\n                }\n                return _context5.delegateYield(_loop(), \"t0\", 25);\n              case 25:\n                _ret = _context5.t0;\n                if (!(_ret === \"break\")) {\n                  _context5.next = 28;\n                  break;\n                }\n                return _context5.abrupt(\"break\", 32);\n              case 28:\n                if (!(typeof _ret === \"object\")) {\n                  _context5.next = 30;\n                  break;\n                }\n                return _context5.abrupt(\"return\", _ret.v);\n              case 30:\n                _context5.next = 23;\n                break;\n              case 32:\n                // Shut down any stallers; shouldn't be any\n                configs.forEach(function (c) {\n                  if (c.staller) {\n                    c.staller.cancel();\n                  }\n                  c.cancelled = true;\n                });\n                return _context5.abrupt(\"return\", logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n                  method: method,\n                  params: params,\n                  //results: configs.map((c) => c.result),\n                  //errors: configs.map((c) => c.error),\n                  results: configs.map(function (c) {\n                    return exposeDebugConfig(c);\n                  }),\n                  provider: this\n                }));\n              case 34:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }]);\n  return FallbackProvider;\n}(BaseProvider);","map":{"version":3,"sources":["../src.ts/fallback-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction now() { return (new Date()).getTime(); }\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks) {\n    let result = null;\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n        // Null! We do not know our network; bail.\n        if (network == null) {\n            return null;\n        }\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n            }\n        }\n        else {\n            result = network;\n        }\n    }\n    return result;\n}\nfunction median(values, maxDelta) {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n    return (a + b) / 2;\n}\nfunction serialize(value) {\n    if (value === null) {\n        return \"null\";\n    }\n    else if (typeof (value) === \"number\" || typeof (value) === \"boolean\") {\n        return JSON.stringify(value);\n    }\n    else if (typeof (value) === \"string\") {\n        return value;\n    }\n    else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    }\n    else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    }\n    else if (typeof (value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof (v) === \"function\") {\n                v = \"[function]\";\n            }\n            else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n    throw new Error(\"unknown value type: \" + typeof (value));\n}\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n;\nfunction stall(duration) {\n    let cancel = null;\n    let timer = null;\n    let promise = (new Promise((resolve) => {\n        cancel = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        };\n        timer = setTimeout(cancel, duration);\n    }));\n    const wait = (func) => {\n        promise = promise.then(func);\n        return promise;\n    };\n    function getPromise() {\n        return promise;\n    }\n    return { cancel, getPromise, wait };\n}\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n;\nfunction exposeDebugConfig(config, now) {\n    const result = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) {\n        result.start = config.start;\n    }\n    if (now) {\n        result.duration = (now - config.start);\n    }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        }\n        else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\nfunction normalizedTally(normalize, quorum) {\n    return function (configs) {\n        // Count the votes for each result\n        const tally = {};\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) {\n                tally[value] = { count: 0, result: c.result };\n            }\n            tally[value].count++;\n        });\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n        // No quroum\n        return undefined;\n    };\n}\nfunction getProcessFunc(provider, method, params) {\n    let normalize = serialize;\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) {\n                    return undefined;\n                }\n                blockNumber = Math.ceil(blockNumber);\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) {\n                    blockNumber++;\n                }\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n                return provider._highestBlockNumber;\n            };\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            };\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function (configs) {\n                return median(configs.map((c) => c.result));\n            };\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function (tx) {\n                if (tx == null) {\n                    return null;\n                }\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            };\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            }\n            else {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    return serialize(block);\n                };\n            }\n            break;\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n}\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nfunction waitForSync(config, blockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const provider = (config.provider);\n        if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n            return provider;\n        }\n        return poll(() => {\n            return new Promise((resolve, reject) => {\n                setTimeout(function () {\n                    // We are synced\n                    if (provider.blockNumber >= blockNumber) {\n                        return resolve(provider);\n                    }\n                    // We're done; just quit\n                    if (config.cancelled) {\n                        return resolve(null);\n                    }\n                    // Try again, next block\n                    return resolve(undefined);\n                }, 0);\n            });\n        }, { oncePoll: provider });\n    });\n}\nfunction getRunner(config, currentBlockNumber, method, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let provider = config.provider;\n        switch (method) {\n            case \"getBlockNumber\":\n            case \"getGasPrice\":\n                return provider[method]();\n            case \"getEtherPrice\":\n                if (provider.getEtherPrice) {\n                    return provider.getEtherPrice();\n                }\n                break;\n            case \"getBalance\":\n            case \"getTransactionCount\":\n            case \"getCode\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.address, params.blockTag || \"latest\");\n            case \"getStorageAt\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n            case \"getBlock\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[(params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\")](params.blockTag || params.blockHash);\n            case \"call\":\n            case \"estimateGas\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.transaction);\n            case \"getTransaction\":\n            case \"getTransactionReceipt\":\n                return provider[method](params.transactionHash);\n            case \"getLogs\": {\n                let filter = params.filter;\n                if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getLogs(filter);\n            }\n        }\n        return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n            method: method,\n            params: params\n        });\n    });\n}\nexport class FallbackProvider extends BaseProvider {\n    constructor(providers, quorum) {\n        logger.checkNew(new.target, FallbackProvider);\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n        const providerConfigs = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n            const config = shallowCopy(configOrProvider);\n            if (config.priority == null) {\n                config.priority = 1;\n            }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n            }\n            if (config.weight == null) {\n                config.weight = 1;\n            }\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${index}].weight`, weight);\n            }\n            return Object.freeze(config);\n        });\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n        if (quorum == null) {\n            quorum = total / 2;\n        }\n        else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n        // Are all providers' networks are known\n        let networkOrReady = checkNetworks(providerConfigs.map((c) => (c.provider).network));\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n        this._highestBlockNumber = -1;\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const networks = yield Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n            return checkNetworks(networks);\n        });\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sending transactions is special; always broadcast it to all backends\n            if (method === \"sendTransaction\") {\n                const results = yield Promise.all(this.providerConfigs.map((c) => {\n                    return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                        return result.hash;\n                    }, (error) => {\n                        return error;\n                    });\n                }));\n                // Any success is good enough (other errors are likely \"already seen\" errors\n                for (let i = 0; i < results.length; i++) {\n                    const result = results[i];\n                    if (typeof (result) === \"string\") {\n                        return result;\n                    }\n                }\n                // They were all an error; pick the first error\n                throw results[0];\n            }\n            // We need to make sure we are in sync with our backends, so we need\n            // to know this before we can make a lot of calls\n            if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n                yield this.getBlockNumber();\n            }\n            const processFunc = getProcessFunc(this, method, params);\n            // Shuffle the providers and then sort them by their priority; we\n            // shallowCopy them since we will store the result in them too\n            const configs = shuffled(this.providerConfigs.map(shallowCopy));\n            configs.sort((a, b) => (a.priority - b.priority));\n            const currentBlockNumber = this._highestBlockNumber;\n            let i = 0;\n            let first = true;\n            while (true) {\n                const t0 = now();\n                // Compute the inflight weight (exclude anything past)\n                let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                    .reduce((accum, c) => (accum + c.weight), 0);\n                // Start running enough to meet quorum\n                while (inflightWeight < this.quorum && i < configs.length) {\n                    const config = configs[i++];\n                    const rid = nextRid++;\n                    config.start = now();\n                    config.staller = stall(config.stallTimeout);\n                    config.staller.wait(() => { config.staller = null; });\n                    config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                        config.done = true;\n                        config.result = result;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    }, (error) => {\n                        config.done = true;\n                        config.error = error;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    });\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, null),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                    inflightWeight += config.weight;\n                }\n                // Wait for anything meaningful to finish or stall out\n                const waiting = [];\n                configs.forEach((c) => {\n                    if (c.done || !c.runner) {\n                        return;\n                    }\n                    waiting.push(c.runner);\n                    if (c.staller) {\n                        waiting.push(c.staller.getPromise());\n                    }\n                });\n                if (waiting.length) {\n                    yield Promise.race(waiting);\n                }\n                // Check the quorum and process the results; the process function\n                // may additionally decide the quorum is not met\n                const results = configs.filter((c) => (c.done && c.error == null));\n                if (results.length >= this.quorum) {\n                    const result = processFunc(results);\n                    if (result !== undefined) {\n                        // Shut down any stallers\n                        configs.forEach(c => {\n                            if (c.staller) {\n                                c.staller.cancel();\n                            }\n                            c.cancelled = true;\n                        });\n                        return result;\n                    }\n                    if (!first) {\n                        yield stall(100).getPromise();\n                    }\n                    first = false;\n                }\n                // No result, check for errors that should be forwarded\n                const errors = configs.reduce((accum, c) => {\n                    if (!c.done || c.error == null) {\n                        return accum;\n                    }\n                    const code = (c.error).code;\n                    if (ForwardErrors.indexOf(code) >= 0) {\n                        if (!accum[code]) {\n                            accum[code] = { error: c.error, weight: 0 };\n                        }\n                        accum[code].weight += c.weight;\n                    }\n                    return accum;\n                }, ({}));\n                Object.keys(errors).forEach((errorCode) => {\n                    const tally = errors[errorCode];\n                    if (tally.weight < this.quorum) {\n                        return;\n                    }\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) {\n                            c.staller.cancel();\n                        }\n                        c.cancelled = true;\n                    });\n                    const e = (tally.error);\n                    const props = {};\n                    ForwardProperties.forEach((name) => {\n                        if (e[name] == null) {\n                            return;\n                        }\n                        props[name] = e[name];\n                    });\n                    logger.throwError(e.reason || e.message, errorCode, props);\n                });\n                // All configs have run to completion; we will never get more data\n                if (configs.filter((c) => !c.done).length === 0) {\n                    break;\n                }\n            }\n            // Shut down any stallers; shouldn't be any\n            configs.forEach(c => {\n                if (c.staller) {\n                    c.staller.cancel();\n                }\n                c.cancelled = true;\n            });\n            return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n                method: method,\n                params: params,\n                //results: configs.map((c) => c.result),\n                //errors: configs.map((c) => c.error),\n                results: configs.map((c) => exposeDebugConfig(c)),\n                provider: this\n            });\n        });\n    }\n}\n//# sourceMappingURL=fallback-provider.js.map"]},"metadata":{},"sourceType":"module"}