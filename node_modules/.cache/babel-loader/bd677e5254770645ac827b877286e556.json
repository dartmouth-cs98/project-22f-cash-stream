{"ast":null,"code":"import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { nameprep, toUtf8Bytes } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nvar Zeros = new Uint8Array(32);\nZeros.fill(0);\nvar Partition = new RegExp(\"^((.*)\\\\.)?([^.]+)$\");\nexport function isValidName(name) {\n  try {\n    var comps = name.split(\".\");\n    for (var i = 0; i < comps.length; i++) {\n      if (nameprep(comps[i]).length === 0) {\n        throw new Error(\"empty\");\n      }\n    }\n    return true;\n  } catch (error) {}\n  return false;\n}\nexport function namehash(name) {\n  /* istanbul ignore if */\n  if (typeof name !== \"string\") {\n    logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n  }\n  var current = name;\n  var result = Zeros;\n  while (current.length) {\n    var partition = current.match(Partition);\n    if (partition == null || partition[2] === \"\") {\n      logger.throwArgumentError(\"invalid ENS address; missing component\", \"name\", name);\n    }\n    var label = toUtf8Bytes(nameprep(partition[3]));\n    result = keccak256(concat([result, keccak256(label)]));\n    current = partition[2] || \"\";\n  }\n  return hexlify(result);\n}\nexport function dnsEncode(name) {\n  return hexlify(concat(name.split(\".\").map(function (comp) {\n    // We jam in an _ prefix to fill in with the length later\n    // Note: Nameprep throws if the component is over 63 bytes\n    var bytes = toUtf8Bytes(\"_\" + nameprep(comp));\n    bytes[0] = bytes.length - 1;\n    return bytes;\n  }))) + \"00\";\n}","map":{"version":3,"sources":["../src.ts/namehash.ts"],"names":[],"mappings":"AAAA,SAAS,MAAM,EAAE,OAAO,QAAQ,sBAAsB;AACtD,SAAS,QAAQ,EAAE,WAAW,QAAQ,wBAAwB;AAC9D,SAAS,SAAS,QAAQ,0BAA0B;AAEpD,SAAS,MAAM,QAAQ,uBAAuB;AAC9C,SAAS,OAAO,QAAQ,YAAY;AACpC,IAAM,MAAM,GAAG,IAAI,MAAM,CAAC,OAAO,CAAC;AAElC,IAAM,KAAK,GAAG,IAAI,UAAU,CAAC,EAAE,CAAC;AAChC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;AAEb,IAAM,SAAS,GAAG,IAAI,MAAM,CAAC,qBAAqB,CAAC;AAEnD,OAAM,SAAU,WAAW,CAAC,IAAY,EAAA;EACpC,IAAI;IACA,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;IAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MACnC,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE;QACjC,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC;MAC3B;IACJ;IACD,OAAO,IAAI;GACd,CAAC,OAAO,KAAK,EAAE,CAAA;EAChB,OAAO,KAAK;AAChB;AAEA,OAAM,SAAU,QAAQ,CAAC,IAAY,EAAA;EACjC;EACA,IAAI,OAAO,IAAK,KAAK,QAAQ,EAAE;IAC3B,MAAM,CAAC,kBAAkB,CAAC,gCAAgC,EAAE,MAAM,EAAE,IAAI,CAAC;EAC5E;EAED,IAAI,OAAO,GAAG,IAAI;EAClB,IAAI,MAAM,GAAwB,KAAK;EACvC,OAAO,OAAO,CAAC,MAAM,EAAE;IACnB,IAAM,SAAS,GAAG,OAAO,CAAC,KAAK,CAAC,SAAS,CAAC;IAC1C,IAAI,SAAS,IAAI,IAAI,IAAI,SAAS,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;MAC1C,MAAM,CAAC,kBAAkB,CAAC,wCAAwC,EAAE,MAAM,EAAE,IAAI,CAAC;IACpF;IACD,IAAM,KAAK,GAAG,WAAW,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;IACjD,MAAM,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAEtD,OAAO,GAAG,SAAS,CAAC,CAAC,CAAC,IAAI,EAAE;EAC/B;EAED,OAAO,OAAO,CAAC,MAAM,CAAC;AAC1B;AAEA,OAAM,SAAU,SAAS,CAAC,IAAY,EAAA;EAClC,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,UAAC,IAAI,EAAI;IAC/C;IACA;IACA,IAAM,KAAK,GAAG,WAAW,CAAC,GAAG,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC;IAC/C,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC;IAC3B,OAAO,KAAK;EAChB,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI;AACf","sourceRoot":"","sourcesContent":["import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { nameprep, toUtf8Bytes } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nconst Partition = new RegExp(\"^((.*)\\\\.)?([^.]+)$\");\nexport function isValidName(name) {\n    try {\n        const comps = name.split(\".\");\n        for (let i = 0; i < comps.length; i++) {\n            if (nameprep(comps[i]).length === 0) {\n                throw new Error(\"empty\");\n            }\n        }\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nexport function namehash(name) {\n    /* istanbul ignore if */\n    if (typeof (name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n    let current = name;\n    let result = Zeros;\n    while (current.length) {\n        const partition = current.match(Partition);\n        if (partition == null || partition[2] === \"\") {\n            logger.throwArgumentError(\"invalid ENS address; missing component\", \"name\", name);\n        }\n        const label = toUtf8Bytes(nameprep(partition[3]));\n        result = keccak256(concat([result, keccak256(label)]));\n        current = partition[2] || \"\";\n    }\n    return hexlify(result);\n}\nexport function dnsEncode(name) {\n    return hexlify(concat(name.split(\".\").map((comp) => {\n        // We jam in an _ prefix to fill in with the length later\n        // Note: Nameprep throws if the component is over 63 bytes\n        const bytes = toUtf8Bytes(\"_\" + nameprep(comp));\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\n//# sourceMappingURL=namehash.js.map"]},"metadata":{},"sourceType":"module"}