{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _taggedTemplateLiteral = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral.js\").default;\nvar _createClass = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/taykim/Desktop/cs98/cfa-createflow-metamask-forked/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _templateObject, _templateObject2;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nvar codegen_1 = require(\"./codegen\");\nvar validation_error_1 = require(\"../runtime/validation_error\");\nvar names_1 = require(\"./names\");\nvar resolve_1 = require(\"./resolve\");\nvar util_1 = require(\"./util\");\nvar validate_1 = require(\"./validate\");\nvar SchemaEnv = /*#__PURE__*/_createClass(function SchemaEnv(env) {\n  _classCallCheck(this, SchemaEnv);\n  var _a;\n  this.refs = {};\n  this.dynamicAnchors = {};\n  var schema;\n  if (typeof env.schema == \"object\") schema = env.schema;\n  this.schema = env.schema;\n  this.schemaId = env.schemaId;\n  this.root = env.root || this;\n  this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n  this.schemaPath = env.schemaPath;\n  this.localRefs = env.localRefs;\n  this.meta = env.meta;\n  this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n  this.refs = {};\n});\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n  // TODO refactor - remove compilations\n  var _sch = getCompilingSchema.call(this, sch);\n  if (_sch) return _sch;\n  var rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n  var _this$opts$code = this.opts.code,\n    es5 = _this$opts$code.es5,\n    lines = _this$opts$code.lines;\n  var ownProperties = this.opts.ownProperties;\n  var gen = new codegen_1.CodeGen(this.scope, {\n    es5: es5,\n    lines: lines,\n    ownProperties: ownProperties\n  });\n  var _ValidationError;\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: validation_error_1.default,\n      code: (0, codegen_1._)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"require(\\\"ajv/dist/runtime/validation_error\\\").default\"])))\n    });\n  }\n  var validateName = gen.scopeName(\"validate\");\n  sch.validateName = validateName;\n  var schemaCxt = {\n    gen: gen,\n    allErrors: this.opts.allErrors,\n    data: names_1.default.data,\n    parentData: names_1.default.parentData,\n    parentDataProperty: names_1.default.parentDataProperty,\n    dataNames: [names_1.default.data],\n    dataPathArr: [codegen_1.nil],\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set(),\n    topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true ? {\n      ref: sch.schema,\n      code: (0, codegen_1.stringify)(sch.schema)\n    } : {\n      ref: sch.schema\n    }),\n    validateName: validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId: rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: (0, codegen_1._)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\\\"\\\"\"]))),\n    opts: this.opts,\n    self: this\n  };\n  var sourceCode;\n  try {\n    this._compilations.add(sch);\n    (0, validate_1.validateFunctionCode)(schemaCxt);\n    gen.optimize(this.opts.code.optimize);\n    // gen.optimize(1)\n    var validateCode = gen.toString();\n    sourceCode = \"\".concat(gen.scopeRefs(names_1.default.scope), \"return \").concat(validateCode);\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch);\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    var makeValidate = new Function(\"\".concat(names_1.default.self), \"\".concat(names_1.default.scope), sourceCode);\n    var validate = makeValidate(this, this.scope.get());\n    this.scope.value(validateName, {\n      ref: validate\n    });\n    validate.errors = null;\n    validate.schema = sch.schema;\n    validate.schemaEnv = sch;\n    if (sch.$async) validate.$async = true;\n    if (this.opts.code.source === true) {\n      validate.source = {\n        validateName: validateName,\n        validateCode: validateCode,\n        scopeValues: gen._values\n      };\n    }\n    if (this.opts.unevaluated) {\n      var props = schemaCxt.props,\n        items = schemaCxt.items;\n      validate.evaluated = {\n        props: props instanceof codegen_1.Name ? undefined : props,\n        items: items instanceof codegen_1.Name ? undefined : items,\n        dynamicProps: props instanceof codegen_1.Name,\n        dynamicItems: items instanceof codegen_1.Name\n      };\n      if (validate.source) validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n    }\n    sch.validate = validate;\n    return sch;\n  } catch (e) {\n    delete sch.validate;\n    delete sch.validateName;\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e;\n  } finally {\n    this._compilations.delete(sch);\n  }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n  var _a;\n  ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n  var schOrFunc = root.refs[ref];\n  if (schOrFunc) return schOrFunc;\n  var _sch = resolve.call(this, root, ref);\n  if (_sch === undefined) {\n    var schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n    var schemaId = this.opts.schemaId;\n    if (schema) _sch = new SchemaEnv({\n      schema: schema,\n      schemaId: schemaId,\n      root: root,\n      baseId: baseId\n    });\n  }\n  if (_sch === undefined) return;\n  return root.refs[ref] = inlineOrCompile.call(this, _sch);\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n  if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs)) return sch.schema;\n  return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n  var _iterator = _createForOfIteratorHelper(this._compilations),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var sch = _step.value;\n      if (sameSchemaEnv(sch, schEnv)) return sch;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root,\n// information about the root schema for the current schema\nref // reference to resolve\n) {\n  var sch;\n  while (typeof (sch = this.refs[ref]) == \"string\") {\n    ref = sch;\n  }\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root,\n// root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n  var p = this.opts.uriResolver.parse(ref);\n  var refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n  var baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root);\n  }\n  var id = (0, resolve_1.normalizeId)(refPath);\n  var schOrRef = this.refs[id] || this.schemas[id];\n  if (typeof schOrRef == \"string\") {\n    var sch = resolveSchema.call(this, root, schOrRef);\n    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\") return;\n    return getJsonPointer.call(this, p, sch);\n  }\n  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\") return;\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef);\n  if (id === (0, resolve_1.normalizeId)(ref)) {\n    var schema = schOrRef.schema;\n    var schemaId = this.opts.schemaId;\n    var schId = schema[schemaId];\n    if (schId) baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n    return new SchemaEnv({\n      schema: schema,\n      schemaId: schemaId,\n      root: root,\n      baseId: baseId\n    });\n  }\n  return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nvar PREVENT_SCOPE_CHANGE = new Set([\"properties\", \"patternProperties\", \"enum\", \"dependencies\", \"definitions\"]);\nfunction getJsonPointer(parsedRef, _ref) {\n  var baseId = _ref.baseId,\n    schema = _ref.schema,\n    root = _ref.root;\n  var _a;\n  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\") return;\n  var _iterator2 = _createForOfIteratorHelper(parsedRef.fragment.slice(1).split(\"/\")),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var part = _step2.value;\n      if (typeof schema === \"boolean\") return;\n      var partSchema = schema[(0, util_1.unescapeFragment)(part)];\n      if (partSchema === undefined) return;\n      schema = partSchema;\n      // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n      var schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n      if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var env;\n  if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n    var $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n    env = resolveSchema.call(this, root, $ref);\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  var schemaId = this.opts.schemaId;\n  env = env || new SchemaEnv({\n    schema: schema,\n    schemaId: schemaId,\n    root: root,\n    baseId: baseId\n  });\n  if (env.schema !== env.root.schema) return env;\n  return undefined;\n}","map":{"version":3,"sources":["../../lib/compile/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst validation_error_1 = require(\"../runtime/validation_error\");\nconst names_1 = require(\"./names\");\nconst resolve_1 = require(\"./resolve\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nclass SchemaEnv {\n    constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\")\n            schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n    }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n    // TODO refactor - remove compilations\n    const _sch = getCompilingSchema.call(this, sch);\n    if (_sch)\n        return _sch;\n    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n    const { es5, lines } = this.opts.code;\n    const { ownProperties } = this.opts;\n    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n    let _ValidationError;\n    if (sch.$async) {\n        _ValidationError = gen.scopeValue(\"Error\", {\n            ref: validation_error_1.default,\n            code: (0, codegen_1._) `require(\"ajv/dist/runtime/validation_error\").default`,\n        });\n    }\n    const validateName = gen.scopeName(\"validate\");\n    sch.validateName = validateName;\n    const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil],\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true\n            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }\n            : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: (0, codegen_1._) `\"\"`,\n        opts: this.opts,\n        self: this,\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        (0, validate_1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        // gen.optimize(1)\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n        if (this.opts.code.process)\n            sourceCode = this.opts.code.process(sourceCode, sch);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n            validate.$async = true;\n        if (this.opts.code.source === true) {\n            validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n            const { props, items } = schemaCxt;\n            validate.evaluated = {\n                props: props instanceof codegen_1.Name ? undefined : props,\n                items: items instanceof codegen_1.Name ? undefined : items,\n                dynamicProps: props instanceof codegen_1.Name,\n                dynamicItems: items instanceof codegen_1.Name,\n            };\n            if (validate.source)\n                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n    }\n    catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n            this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n        throw e;\n    }\n    finally {\n        this._compilations.delete(sch);\n    }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n    var _a;\n    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n    const schOrFunc = root.refs[ref];\n    if (schOrFunc)\n        return schOrFunc;\n    let _sch = resolve.call(this, root, ref);\n    if (_sch === undefined) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n        const { schemaId } = this.opts;\n        if (schema)\n            _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    if (_sch === undefined)\n        return;\n    return (root.refs[ref] = inlineOrCompile.call(this, _sch));\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n    return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n    for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n            return sch;\n    }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n    let sch;\n    while (typeof (sch = this.refs[ref]) == \"string\")\n        ref = sch;\n    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n    const p = this.opts.uriResolver.parse(ref);\n    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n    if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n    }\n    const id = (0, resolve_1.normalizeId)(refPath);\n    const schOrRef = this.refs[id] || this.schemas[id];\n    if (typeof schOrRef == \"string\") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\")\n            return;\n        return getJsonPointer.call(this, p, sch);\n    }\n    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\")\n        return;\n    if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n    if (id === (0, resolve_1.normalizeId)(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\n    \"properties\",\n    \"patternProperties\",\n    \"enum\",\n    \"dependencies\",\n    \"definitions\",\n]);\nfunction getJsonPointer(parsedRef, { baseId, schema, root }) {\n    var _a;\n    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\")\n        return;\n    for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n        if (typeof schema === \"boolean\")\n            return;\n        const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n        if (partSchema === undefined)\n            return;\n        schema = partSchema;\n        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n        const schId = typeof schema === \"object\" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        }\n    }\n    let env;\n    if (typeof schema != \"boolean\" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n    }\n    // even though resolution failed we need to return SchemaEnv to throw exception\n    // so that compileAsync loads missing schema.\n    const { schemaId } = this.opts;\n    env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n    if (env.schema !== env.root.schema)\n        return env;\n    return undefined;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}